{"parents": [], "prev": null, "next": null, "title": "Symmetric Diffeomorphic Registration in 3D", "meta": {}, "body": "<section id=\"symmetric-diffeomorphic-registration-in-3d\">\n<span id=\"example-syn-registration-3d\"></span><h1>Symmetric Diffeomorphic Registration in 3D<a class=\"headerlink\" href=\"#symmetric-diffeomorphic-registration-in-3d\" title=\"Permalink to this heading\">\u00b6</a></h1>\n<p>This example explains how to register 3D volumes using the Symmetric\nNormalization (SyN) algorithm proposed by Avants et al. <a class=\"reference internal\" href=\"../../interfaces/registration_flow/#avants09\" id=\"id1\"><span>[Avants09]</span></a>\n(also implemented in the ANTs software <a class=\"reference internal\" href=\"../../interfaces/registration_flow/#avants11\" id=\"id2\"><span>[Avants11]</span></a>)</p>\n<p>We will register two 3D volumes from the same modality using SyN with the Cross\n-Correlation (CC) metric.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.align.imwarp</span> <span class=\"kn\">import</span> <span class=\"n\">SymmetricDiffeomorphicRegistration</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.align.metrics</span> <span class=\"kn\">import</span> <span class=\"n\">CCMetric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"kn\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"kn\">import</span> <span class=\"n\">load_nifti</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"kn\">import</span> <span class=\"n\">regtools</span>\n</pre></div>\n</div>\n<p>Let\u2019s fetch two b0 volumes, the first one will be the b0 from the Stanford\nHARDI dataset</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">hardi_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;stanford_hardi&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">stanford_b0</span><span class=\"p\">,</span> <span class=\"n\">stanford_b0_affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">hardi_fname</span><span class=\"p\">)</span>\n<span class=\"n\">stanford_b0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">squeeze</span><span class=\"p\">(</span><span class=\"n\">stanford_b0</span><span class=\"p\">)[</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre></div>\n</div>\n<p>The second one will be the same b0 we used for the 2D registration tutorial</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">t1_fname</span><span class=\"p\">,</span> <span class=\"n\">b0_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;syn_data&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">syn_b0</span><span class=\"p\">,</span> <span class=\"n\">syn_b0_affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">b0_fname</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We first remove the skull from the b0\u2019s</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.mask</span> <span class=\"kn\">import</span> <span class=\"n\">median_otsu</span>\n<span class=\"n\">stanford_b0_masked</span><span class=\"p\">,</span> <span class=\"n\">stanford_b0_mask</span> <span class=\"o\">=</span> <span class=\"n\">median_otsu</span><span class=\"p\">(</span><span class=\"n\">stanford_b0</span><span class=\"p\">,</span>\n                                                   <span class=\"n\">median_radius</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span>\n                                                   <span class=\"n\">numpass</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">syn_b0_masked</span><span class=\"p\">,</span> <span class=\"n\">syn_b0_mask</span> <span class=\"o\">=</span> <span class=\"n\">median_otsu</span><span class=\"p\">(</span><span class=\"n\">syn_b0</span><span class=\"p\">,</span> <span class=\"n\">median_radius</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">numpass</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n\n<span class=\"n\">static</span> <span class=\"o\">=</span> <span class=\"n\">stanford_b0_masked</span>\n<span class=\"n\">static_affine</span> <span class=\"o\">=</span> <span class=\"n\">stanford_b0_affine</span>\n<span class=\"n\">moving</span> <span class=\"o\">=</span> <span class=\"n\">syn_b0_masked</span>\n<span class=\"n\">moving_affine</span> <span class=\"o\">=</span> <span class=\"n\">syn_b0_affine</span>\n</pre></div>\n</div>\n<p>Suppose we have already done a linear registration to roughly align the two\nimages</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">pre_align</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.02783543e+00</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">4.83019053e-02</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">6.07735639e-02</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.57654118e+00</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">4.34051706e-03</span><span class=\"p\">,</span> <span class=\"mf\">9.41918267e-01</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.66525861e-01</span><span class=\"p\">,</span> <span class=\"mf\">3.23579799e+01</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">5.34288908e-02</span><span class=\"p\">,</span> <span class=\"mf\">2.90262026e-01</span><span class=\"p\">,</span> <span class=\"mf\">9.80820307e-01</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.46216651e+01</span><span class=\"p\">],</span>\n                      <span class=\"p\">[</span><span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">0.00000000e+00</span><span class=\"p\">,</span> <span class=\"mf\">1.00000000e+00</span><span class=\"p\">]])</span>\n</pre></div>\n</div>\n<p>As we did in the 2D example, we would like to visualize (some slices of) the\ntwo volumes by overlapping them over two channels of a color image. To do that\nwe need them to be sampled on the same grid, so let\u2019s first re-sample the\nmoving image on the static grid. We create an AffineMap to transform the moving\nimage towards the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.align.imaffine</span> <span class=\"kn\">import</span> <span class=\"n\">AffineMap</span>\n<span class=\"n\">affine_map</span> <span class=\"o\">=</span> <span class=\"n\">AffineMap</span><span class=\"p\">(</span><span class=\"n\">pre_align</span><span class=\"p\">,</span>\n                       <span class=\"n\">static</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">static_affine</span><span class=\"p\">,</span>\n                       <span class=\"n\">moving</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">moving_affine</span><span class=\"p\">)</span>\n\n<span class=\"n\">resampled</span> <span class=\"o\">=</span> <span class=\"n\">affine_map</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">moving</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>plot the overlapped middle slices of the volumes</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">resampled</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Static&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Moving&#39;</span><span class=\"p\">,</span>\n                        <span class=\"s1\">&#39;input_3d.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id4\">\n<img alt=\"../../_images/input_3d.png\" src=\"../../_images/input_3d.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Static image in red on top of the pre-aligned moving image (in green).</span><a class=\"headerlink\" href=\"#id4\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>We want to find an invertible map that transforms the moving image into the\nstatic image. We will use the Cross-Correlation metric</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CCMetric</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Now we define an instance of the registration class. The SyN algorithm uses\na multi-resolution approach by building a Gaussian Pyramid. We instruct the\nregistration object to perform at most <span class=\"math notranslate nohighlight\">\\([n_0, n_1, ..., n_k]\\)</span> iterations at\neach level of the pyramid. The 0-th level corresponds to the finest resolution.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">level_iters</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">sdr</span> <span class=\"o\">=</span> <span class=\"n\">SymmetricDiffeomorphicRegistration</span><span class=\"p\">(</span><span class=\"n\">metric</span><span class=\"p\">,</span> <span class=\"n\">level_iters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Execute the optimization, which returns a DiffeomorphicMap object,\nthat can be used to register images back and forth between the static and\nmoving domains. We provide the pre-aligning matrix that brings the moving\nimage closer to the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">sdr</span><span class=\"o\">.</span><span class=\"n\">optimize</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">moving</span><span class=\"p\">,</span> <span class=\"n\">static_affine</span><span class=\"p\">,</span> <span class=\"n\">moving_affine</span><span class=\"p\">,</span> <span class=\"n\">pre_align</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Now let\u2019s warp the moving image and see if it gets similar to the static image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">warped_moving</span> <span class=\"o\">=</span> <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">transform</span><span class=\"p\">(</span><span class=\"n\">moving</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We plot the overlapped middle slices</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">,</span> <span class=\"n\">warped_moving</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Static&#39;</span><span class=\"p\">,</span>\n                        <span class=\"s1\">&#39;Warped moving&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;warped_moving.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id5\">\n<img alt=\"../../_images/warped_moving.png\" src=\"../../_images/warped_moving.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Moving image transformed under the (direct) transformation in green on top\nof the static image (in red).</span><a class=\"headerlink\" href=\"#id5\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<p>And we can also apply the inverse mapping to verify that the warped static\nimage is similar to the moving image</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">warped_static</span> <span class=\"o\">=</span> <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">transform_inverse</span><span class=\"p\">(</span><span class=\"n\">static</span><span class=\"p\">)</span>\n<span class=\"n\">regtools</span><span class=\"o\">.</span><span class=\"n\">overlay_slices</span><span class=\"p\">(</span><span class=\"n\">warped_static</span><span class=\"p\">,</span> <span class=\"n\">moving</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Warped static&#39;</span><span class=\"p\">,</span>\n                        <span class=\"s1\">&#39;Moving&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;warped_static.png&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id6\">\n<img alt=\"../../_images/warped_static.png\" src=\"../../_images/warped_static.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Static image transformed under the (inverse) transformation in red on top of\nthe moving image (in green). Note that the moving image has a lower\nresolution.</span><a class=\"headerlink\" href=\"#id6\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<section id=\"references\">\n<h2>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this heading\">\u00b6</a></h2>\n<div role=\"list\" class=\"citation-list\">\n<div class=\"citation\" id=\"avants09\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id1\">Avants09</a><span class=\"fn-bracket\">]</span></span>\n<p>Avants, B. B., Epstein, C. L., Grossman, M., &amp; Gee, J. C. (2009).\nSymmetric Diffeomorphic Image Registration with Cross-Correlation:\nEvaluating Automated Labeling of Elderly and Neurodegenerative Brain, 12(1),\n26-41.</p>\n</div>\n<div class=\"citation\" id=\"avants11\" role=\"doc-biblioentry\">\n<span class=\"label\"><span class=\"fn-bracket\">[</span><a role=\"doc-backlink\" href=\"#id2\">Avants11</a><span class=\"fn-bracket\">]</span></span>\n<p>Avants, B. B., Tustison, N., &amp; Song, G. (2011). Advanced\nNormalization Tools (ANTS), 1-35.</p>\n</div>\n</div>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"admonition-title\">Example source code</p>\n<p>You can download <a class=\"reference download internal\" download=\"\" href=\"../../_downloads/7e97783e89efb9f0bb3a9d40ac603895/syn_registration_3d.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>. This same script is also included in the dipy source distribution under the <code class=\"file docutils literal notranslate\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/syn_registration_3d.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Symmetric Diffeomorphic Registration in 3D</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/syn_registration_3d", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}