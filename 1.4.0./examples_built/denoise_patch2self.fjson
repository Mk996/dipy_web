{"parents": [], "prev": null, "next": null, "title": "Patch2Self: Self-Supervised Denoising via Statistical Independence", "meta": {}, "body": "<div class=\"section\" id=\"patch2self-self-supervised-denoising-via-statistical-independence\">\n<span id=\"example-denoise-patch2self\"></span><h1>Patch2Self: Self-Supervised Denoising via Statistical Independence<a class=\"headerlink\" href=\"#patch2self-self-supervised-denoising-via-statistical-independence\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>Patch2Self <a class=\"reference internal\" href=\"../../reference_cmd/dipy_denoise_patch2self/#fadnavis20\" id=\"id1\"><span>[Fadnavis20]</span></a> is  a self-supervised learning method for denoising\nDWI data, which uses the entire volume to learn a full-rank locally linear\ndenoiser for that volume. By taking advantage of the oversampled q-space of DWI\ndata, Patch2Self can separate structure from noise without requiring an\nexplicit model for either.</p>\n<p>Classical denoising algorithms such as Local PCA <a class=\"reference internal\" href=\"#manjon2013\" id=\"id2\"><span>[Manjon2013]</span></a>, <a class=\"reference internal\" href=\"#veraa2016a\" id=\"id3\"><span>[Veraa2016a]</span></a>,\nNon-local Means <a class=\"reference internal\" href=\"../../interfaces/denoise_flow/#coupe08\" id=\"id4\"><span>[Coupe08]</span></a>, Total Variation Norm <a class=\"reference internal\" href=\"#knoll11\" id=\"id5\"><span>[Knoll11]</span></a>, etc. assume\ncertain properties on the signal structure. Patch2Self <em>does not</em> make any such\nassumption on the signal instead using the fact that the noise across\ndifferent 3D volumes of the DWI signal originates from random fluctuations in\nthe acquired signal.</p>\n<p>Since Patch2Self only relies on the randomness of the noise, it can be applied\nat any step in the pre-processing pipeline. The design of Patch2Self is such\nthat it can work on any type of diffusion data/ any body part without\nrequiring a noise estimation or assumptions on the type of noise (such as its\ndistribution).</p>\n<p>The Patch2Self Framework:</p>\n<div class=\"figure align-center\" id=\"patch2self\">\n<a class=\"reference internal image-reference\" href=\"https://github.com/dipy/dipy_data/blob/master/Patch2Self_Framework.PNG?raw=true\"><img alt=\"https://github.com/dipy/dipy_data/blob/master/Patch2Self_Framework.PNG?raw=true\" src=\"https://github.com/dipy/dipy_data/blob/master/Patch2Self_Framework.PNG?raw=true\" /></a>\n</div>\n<p>The above figure demonstrates the working of Patch2Self. The idea is to build\na new regressor for denoising each 3D volume of the 4D diffusion data. This is\ndone in the following 2 phases:</p>\n<p>(A) Self-supervised training: First, we extract 3D Patches from all the \u2018n\u2019\nvolumes and hold out the target volume to denoise. Each patch from the rest of\nthe \u2018(n-1)\u2019 volumes predicts the center voxel of the corresponding patch in the\ntarget volume.</p>\n<p>This is done by using the self-supervised loss:\n<span class=\"math notranslate nohighlight\">\\(\\mathcal{L}\\left(\\Phi_{J}\\right)=\\mathbb{E}\\left\\|\\Phi_{J}\\left(Y_{*, *,-j}\\right)-Y_{*, 0, j}\\right\\|^{2}\\)</span></p>\n<p>(B) Prediction: The same \u2018n-1\u2019 volumes which were used in the training are now\nfed into the regressor <span class=\"math notranslate nohighlight\">\\(\\Phi\\)</span> built in phase (A). The prediction is a\ndenoised version of held-out volume.</p>\n<p><em>Note: The volume to be denoised is merely used as the target in the training\nphase. But is not used in the training set for (A) nor is used to predict the\ndenoised output in (B).</em></p>\n<p>Let\u2019s load the necessary modules:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"k\">import</span> <span class=\"n\">load_nifti</span><span class=\"p\">,</span> <span class=\"n\">save_nifti</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.denoise.patch2self</span> <span class=\"k\">import</span> <span class=\"n\">patch2self</span>\n</pre></div>\n</div>\n<p>Now let\u2019s load an example dataset and denoise it with Patch2Self. Patch2Self\ndoes not require noise estimation and should work with any kind of diffusion\ndata.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">hardi_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bval_fname</span><span class=\"p\">,</span> <span class=\"n\">hardi_bvec_fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;stanford_hardi&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">hardi_fname</span><span class=\"p\">)</span>\n<span class=\"n\">bvals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">loadtxt</span><span class=\"p\">(</span><span class=\"n\">hardi_bval_fname</span><span class=\"p\">)</span>\n<span class=\"n\">denoised_arr</span> <span class=\"o\">=</span> <span class=\"n\">patch2self</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">bvals</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The array <cite>denoised_arr</cite> contains the denoised output obtained from Patch2Self.\nNow lets visualize the output and the residuals obtained from the denoising.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\"># Gets the center slice and the middle volume of the 4D diffusion data.</span>\n<span class=\"n\">sli</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n<span class=\"n\">gra</span> <span class=\"o\">=</span> <span class=\"mi\">60</span>  <span class=\"c1\"># pick out a random volume for a particular gradient direction</span>\n\n<span class=\"n\">orig</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"n\">sli</span><span class=\"p\">,</span> <span class=\"n\">gra</span><span class=\"p\">]</span>\n<span class=\"n\">den</span> <span class=\"o\">=</span> <span class=\"n\">denoised_arr</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"n\">sli</span><span class=\"p\">,</span> <span class=\"n\">gra</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># computes the residuals</span>\n<span class=\"n\">rms_diff</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">((</span><span class=\"n\">orig</span> <span class=\"o\">-</span> <span class=\"n\">den</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">fig1</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">),</span>\n                        <span class=\"n\">subplot_kw</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">&#39;xticks&#39;</span><span class=\"p\">:</span> <span class=\"p\">[],</span> <span class=\"s1\">&#39;yticks&#39;</span><span class=\"p\">:</span> <span class=\"p\">[]})</span>\n\n<span class=\"n\">fig1</span><span class=\"o\">.</span><span class=\"n\">subplots_adjust</span><span class=\"p\">(</span><span class=\"n\">hspace</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"n\">wspace</span><span class=\"o\">=</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>\n\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">orig</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">,</span>\n                  <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Original&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">den</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">,</span>\n                  <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Denoised Output&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">rms_diff</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"o\">=</span><span class=\"s1\">&#39;gray&#39;</span><span class=\"p\">,</span> <span class=\"n\">interpolation</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span><span class=\"p\">,</span>\n                  <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"s1\">&#39;lower&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">flat</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"s1\">&#39;Residuals&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">fig1</span><span class=\"o\">.</span><span class=\"n\">savefig</span><span class=\"p\">(</span><span class=\"s1\">&#39;denoised_patch2self.png&#39;</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;The result saved in denoised_patch2self.png&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"figure align-center\">\n<img alt=\"../../_images/denoised_patch2self.png\" src=\"../../_images/denoised_patch2self.png\" />\n</div>\n<p>Patch2Self preserved anatomical detail. This can be visually verified by\ninspecting the residuals obtained above. Since we do not see any structure in\nthe difference residuals, it is clear that it preserved the underlying signal\nstructure and got rid of the stochastic noise.</p>\n<p>Below we show how the denoised data can be saved.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">save_nifti</span><span class=\"p\">(</span><span class=\"s1\">&#39;denoised_patch2self.nii.gz&#39;</span><span class=\"p\">,</span> <span class=\"n\">denoised_arr</span><span class=\"p\">,</span> <span class=\"n\">affine</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Entire denoised data saved in denoised_patch2self.nii.gz&quot;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"references\">\n<h2>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"fadnavis20\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id1\">Fadnavis20</a></span></dt>\n<dd><p>S. Fadnavis, J. Batson, E. Garyfallidis, Patch2Self:\nDenoising Diffusion MRI with Self-supervised Learning,\nAdvances in Neural Information Processing Systems 33 (2020)</p>\n</dd>\n<dt class=\"label\" id=\"manjon2013\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id2\">Manjon2013</a></span></dt>\n<dd><p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL \u201cDiffusion\nWeighted Image Denoising Using Overcomplete Local PCA\u201d (2013).\nPLoS ONE 8(9): e73021. doi:10.1371/journal.pone.0073021.</p>\n</dd>\n<dt class=\"label\" id=\"veraa2016a\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id3\">Veraa2016a</a></span></dt>\n<dd><p>Veraart J, Fieremans E, Novikov DS. 2016. Diffusion MRI noise\nmapping using random matrix theory. Magnetic Resonance in\nMedicine. doi: 10.1002/mrm.26059.</p>\n</dd>\n<dt class=\"label\" id=\"coupe08\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id4\">Coupe08</a></span></dt>\n<dd><p>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C.\nBarillot, An Optimized Blockwise Non Local Means Denoising\nFilter for 3D Magnetic Resonance Images, IEEE Transactions on\nMedical Imaging, 27(4):425-441, 2008</p>\n</dd>\n<dt class=\"label\" id=\"knoll11\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id5\">Knoll11</a></span></dt>\n<dd><p>F. Knoll, K. Bredies, T. Pock, R. Stollberger, Second order total\ngeneralized variation (TGV) for MRI. Magnetic resonance in\nmedicine, 65(2), pp.480-491.</p>\n</dd>\n</dl>\n<p>\u201c\u201d\u201d</p>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"admonition-title\">Example source code</p>\n<p>You can download <a class=\"reference download internal\" download=\"\" href=\"../../_downloads/62345ea233d5e10c6bbafd96306f0da5/denoise_patch2self.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>. This same script is also included in the dipy source distribution under the <code class=\"file docutils literal notranslate\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/denoise_patch2self.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Patch2Self: Self-Supervised Denoising via Statistical Independence</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/denoise_patch2self", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}