{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "API Reference"}], "prev": {"link": "../dipy.data/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">data</span></code>"}, "next": {"link": "../dipy.direction/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">direction</span></code>"}, "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code>", "meta": {}, "body": "<div class=\"section\" id=\"module-dipy.denoise\">\n<span id=\"denoise\"></span><h1><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.bench\" title=\"dipy.denoise.bench\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench</span></code></a>([label,\u00a0verbose,\u00a0extra_argv])</p></td>\n<td><p>Run benchmarks for module using nose.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.test\" title=\"dipy.denoise.test\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">test</span></code></a>([label,\u00a0verbose,\u00a0extra_argv,\u00a0doctests,\u00a0\u2026])</p></td>\n<td><p>Run tests for module using nose.</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"module-dipy.denoise.adaptive_soft_matching\">\n<span id=\"module-denoise-adaptive-soft-matching\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.adaptive_soft_matching\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adaptive_soft_matching</span></code></a>(ima,\u00a0fimau,\u00a0fimao,\u00a0sigma)</p></td>\n<td><p>Adaptive Soft Coefficient Matching</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.gibbs\">\n<span id=\"module-denoise-gibbs\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.gibbs</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.gibbs\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.gibbs.gibbs_removal\" title=\"dipy.denoise.gibbs.gibbs_removal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gibbs_removal</span></code></a>(vol[,\u00a0slice_axis,\u00a0n_points])</p></td>\n<td><p>Suppresses Gibbs ringing artefacts of images volumes.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.localpca\">\n<span id=\"module-denoise-localpca\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.localpca\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.eigh\" title=\"dipy.denoise.localpca.eigh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigh</span></code></a>(a[,\u00a0b,\u00a0lower,\u00a0eigvals_only,\u00a0\u2026])</p></td>\n<td><p>Solve a standard or generalized eigenvalue problem for a complex Hermitian or real symmetric matrix.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.genpca\" title=\"dipy.denoise.localpca.genpca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">genpca</span></code></a>(arr[,\u00a0sigma,\u00a0mask,\u00a0patch_radius,\u00a0\u2026])</p></td>\n<td><p>General function to perform PCA-based denoising of diffusion datasets.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.localpca\" title=\"dipy.denoise.localpca.localpca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">localpca</span></code></a>(arr,\u00a0sigma[,\u00a0mask,\u00a0patch_radius,\u00a0\u2026])</p></td>\n<td><p>Performs local PCA denoising according to Manjon et al.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.localpca.mppca\" title=\"dipy.denoise.localpca.mppca\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mppca</span></code></a>(arr[,\u00a0mask,\u00a0patch_radius,\u00a0pca_method,\u00a0\u2026])</p></td>\n<td><p>Performs PCA-based denoising using the Marcenko-Pastur distribution <a class=\"reference internal\" href=\"#ra3cd9ccad273-1\" id=\"id1\">[1]</a>.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.nlmeans\">\n<span id=\"module-denoise-nlmeans\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.nlmeans\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"dipy.denoise.nlmeans.nlmeans\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans</span></code></a>(arr,\u00a0sigma[,\u00a0mask,\u00a0patch_radius,\u00a0\u2026])</p></td>\n<td><p>Non-local means for denoising 3D and 4D images</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.nlmeans.nlmeans_3d\" title=\"dipy.denoise.nlmeans.nlmeans_3d\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans_3d</span></code></a>()</p></td>\n<td><p>Non-local means for denoising 3D images</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.noise_estimate\">\n<span id=\"module-denoise-noise-estimate\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.noise_estimate\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.convolve\" title=\"dipy.denoise.noise_estimate.convolve\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">convolve</span></code></a>(input,\u00a0weights[,\u00a0output,\u00a0mode,\u00a0\u2026])</p></td>\n<td><p>Multidimensional convolution.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"dipy.denoise.noise_estimate.estimate_sigma\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_sigma</span></code></a>(arr[,\u00a0\u2026])</p></td>\n<td><p>Standard deviation estimation from local patches</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"dipy.denoise.noise_estimate.piesno\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">piesno</span></code></a>(data,\u00a0N[,\u00a0alpha,\u00a0l,\u00a0itermax,\u00a0eps,\u00a0\u2026])</p></td>\n<td><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.denoise.non_local_means\">\n<span id=\"module-denoise-non-local-means\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code><a class=\"headerlink\" href=\"#module-dipy.denoise.non_local_means\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.nlmeans_block\" title=\"dipy.denoise.non_local_means.nlmeans_block\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlmeans_block</span></code></a>()</p></td>\n<td><p>Non-Local Means Denoising Using Blockwise Averaging</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"dipy.denoise.non_local_means.non_local_means\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">non_local_means</span></code></a>(arr,\u00a0sigma[,\u00a0mask,\u00a0\u2026])</p></td>\n<td><p>Non-local means for denoising 3D and 4D images, using</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"bench\">\n<h3>bench<a class=\"headerlink\" href=\"#bench\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.bench\">\n<code class=\"sig-prename descclassname\">dipy.denoise.</code><code class=\"sig-name descname\">bench</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">label='fast'</em>, <em class=\"sig-param\">verbose=1</em>, <em class=\"sig-param\">extra_argv=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.bench\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run benchmarks for module using nose.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>label</strong><span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt><dd><p>Identifies the benchmarks to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:</p>\n<ul class=\"simple\">\n<li><p>\u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code>\noption of \u2018not slow\u2019.</p></li>\n<li><p>\u2018full\u2019 - fast (as above) and slow benchmarks as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</p></li>\n<li><p>None or \u2018\u2019 - run all tests.</p></li>\n<li><p>attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p></li>\n</ul>\n</dd>\n<dt><strong>verbose</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong><span class=\"classifier\">list, optional</span></dt><dd><p>List with any extra arguments to pass to nosetests.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>success</strong><span class=\"classifier\">bool</span></dt><dd><p>Returns True if running the benchmarks works, False if an error\noccurred.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Benchmarks are like tests, but have names starting with \u201cbench\u201d instead\nof \u201ctest\u201d, and can be found under the \u201cbenchmarks\u201d sub-directory of the\nmodule.</p>\n<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks\nfor it.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span> \n<span class=\"go\">Running benchmarks for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">using 562341 items:</span>\n<span class=\"go\">unique:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">unique1d:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">ratio: 1.0</span>\n<span class=\"go\">nUnique: 56230 == 56230</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">OK</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> \n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"test\">\n<h3>test<a class=\"headerlink\" href=\"#test\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.test\">\n<code class=\"sig-prename descclassname\">dipy.denoise.</code><code class=\"sig-name descname\">test</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">label='fast'</em>, <em class=\"sig-param\">verbose=1</em>, <em class=\"sig-param\">extra_argv=None</em>, <em class=\"sig-param\">doctests=False</em>, <em class=\"sig-param\">coverage=False</em>, <em class=\"sig-param\">raise_warnings=None</em>, <em class=\"sig-param\">timer=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.test\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run tests for module using nose.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>label</strong><span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt><dd><p>Identifies the tests to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:</p>\n<ul class=\"simple\">\n<li><p>\u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code>\noption of \u2018not slow\u2019.</p></li>\n<li><p>\u2018full\u2019 - fast (as above) and slow tests as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</p></li>\n<li><p>None or \u2018\u2019 - run all tests.</p></li>\n<li><p>attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p></li>\n</ul>\n</dd>\n<dt><strong>verbose</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Verbosity value for test outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong><span class=\"classifier\">list, optional</span></dt><dd><p>List with any extra arguments to pass to nosetests.</p>\n</dd>\n<dt><strong>doctests</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, run doctests in module. Default is False.</p>\n</dd>\n<dt><strong>coverage</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, report coverage of NumPy code. Default is False.\n(This requires the\n<a class=\"reference external\" href=\"https://nedbatchelder.com/code/modules/coveragehtml\">coverage module</a>).</p>\n</dd>\n<dt><strong>raise_warnings</strong><span class=\"classifier\">None, str or sequence of warnings, optional</span></dt><dd><p>This specifies which warnings to configure as \u2018raise\u2019 instead\nof being shown once during the test execution. Valid strings are:</p>\n<ul class=\"simple\">\n<li><p>\u201cdevelop\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">(Warning,)</span></code></p></li>\n<li><p>\u201crelease\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">()</span></code>, do not raise on any warnings.</p></li>\n</ul>\n</dd>\n<dt><strong>timer</strong><span class=\"classifier\">bool or int, optional</span></dt><dd><p>Timing of individual tests with <code class=\"docutils literal notranslate\"><span class=\"pre\">nose-timer</span></code> (which needs to be\ninstalled).  If True, time tests and report on all of them.\nIf an integer (say <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code>), report timing results for <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> slowest\ntests.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">object</span></dt><dd><p>Returns the result of running the tests as a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">nose.result.TextTestResult</span></code> object.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.\nFor example, to run all tests for numpy.lib:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n</pre></div>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n<span class=\"go\">Running unit tests for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">Ran 976 tests in 3.933s</span>\n</pre></div>\n</div>\n<p>OK</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">errors</span> \n<span class=\"go\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">knownfail</span> \n<span class=\"go\">[]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"adaptive-soft-matching\">\n<h3>adaptive_soft_matching<a class=\"headerlink\" href=\"#adaptive-soft-matching\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\">\n<code class=\"sig-prename descclassname\">dipy.denoise.adaptive_soft_matching.</code><code class=\"sig-name descname\">adaptive_soft_matching</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ima</em>, <em class=\"sig-param\">fimau</em>, <em class=\"sig-param\">fimao</em>, <em class=\"sig-param\">sigma</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.adaptive_soft_matching.adaptive_soft_matching\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Adaptive Soft Coefficient Matching</p>\n<p>Combines two filtered 3D-images at different resolutions and the original\nimage. Returns the resulting combined image.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ima</strong><span class=\"classifier\">the original (not filtered) image</span></dt><dd></dd>\n<dt><strong>fimau</strong><span class=\"classifier\">3D double array,</span></dt><dd><p>filtered image with optimized non-local means using a small block\n(suggested:3x3), which corresponds to a \u201chigh resolution\u201d filter.</p>\n</dd>\n<dt><strong>fimao</strong><span class=\"classifier\">3D double array,</span></dt><dd><p>filtered image with optimized non-local means using a small block\n(suggested:5x5), which corresponds to a \u201clow resolution\u201d filter.</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">the estimated standard deviation of the Gaussian random variables</span></dt><dd><p>that explain the rician noise. Note: In P. Coupe et al. the\nrician noise was simulated as sqrt((f+x)^2 + (y)^2) where f is\nthe pixel value and x and y are independent realizations of a\nrandom variable with Normal distribution, with mean=0 and\nstandard deviation=h</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fima</strong><span class=\"classifier\">3D double array</span></dt><dd><p>output denoised array which is of the same shape as that of\nthe input</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"refa1efa84d4b-coupe11\"><span class=\"brackets\">Coupe11</span></dt>\n<dd><p>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\n\u201cMultiresolution Non-Local Means Filter for 3D MR Image\nDenoising\u201d IET Image Processing, Institution of Engineering\nand Technology,\n2011</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gibbs-removal\">\n<h3>gibbs_removal<a class=\"headerlink\" href=\"#gibbs-removal\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.gibbs.gibbs_removal\">\n<code class=\"sig-prename descclassname\">dipy.denoise.gibbs.</code><code class=\"sig-name descname\">gibbs_removal</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vol</em>, <em class=\"sig-param\">slice_axis=2</em>, <em class=\"sig-param\">n_points=3</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.gibbs.gibbs_removal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Suppresses Gibbs ringing artefacts of images volumes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vol</strong><span class=\"classifier\">ndarray ([X, Y]), ([X, Y, Z]) or ([X, Y, Z, g])</span></dt><dd><p>Matrix containing one volume (3D) or multiple (4D) volumes of images.</p>\n</dd>\n<dt><strong>slice_axis</strong><span class=\"classifier\">int (0, 1, or 2)</span></dt><dd><p>Data axis corresponding to the number of acquired slices.\nDefault is set to the third axis.</p>\n</dd>\n<dt><strong>n_points</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Number of neighbour points to access local TV (see note).\nDefault is set to 3.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>vol</strong><span class=\"classifier\">ndarray ([X, Y]), ([X, Y, Z]) or ([X, Y, Z, g])</span></dt><dd><p>Matrix containing one volume (3D) or multiple (4D) volumes of corrected\nimages.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For 4D matrix last element should always correspond to the number of\ndiffusion gradient directions.</p>\n<p class=\"rubric\">References</p>\n<p>Please cite the following articles\n.. [Rfce522a872fd-1] Neto Henriques, R., 2018. Advanced Methods for Diffusion MRI Data</p>\n<blockquote>\n<div><p>Analysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). <a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</div></blockquote>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rfce522a872fd-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Kellner E, Dhital B, Kiselev VG, Reisert M. Gibbs-ringing artifact\nremoval based on local subvoxel-shifts. Magn Reson Med. 2016\ndoi: 10.1002/mrm.26054.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"eigh\">\n<h3>eigh<a class=\"headerlink\" href=\"#eigh\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.eigh\">\n<code class=\"sig-prename descclassname\">dipy.denoise.localpca.</code><code class=\"sig-name descname\">eigh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">a</em>, <em class=\"sig-param\">b=None</em>, <em class=\"sig-param\">lower=True</em>, <em class=\"sig-param\">eigvals_only=False</em>, <em class=\"sig-param\">overwrite_a=False</em>, <em class=\"sig-param\">overwrite_b=False</em>, <em class=\"sig-param\">turbo=True</em>, <em class=\"sig-param\">eigvals=None</em>, <em class=\"sig-param\">type=1</em>, <em class=\"sig-param\">check_finite=True</em>, <em class=\"sig-param\">subset_by_index=None</em>, <em class=\"sig-param\">subset_by_value=None</em>, <em class=\"sig-param\">driver=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.eigh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Solve a standard or generalized eigenvalue problem for a complex\nHermitian or real symmetric matrix.</p>\n<p>Find eigenvalues array <code class=\"docutils literal notranslate\"><span class=\"pre\">w</span></code> and optionally eigenvectors array <code class=\"docutils literal notranslate\"><span class=\"pre\">v</span></code> of\narray <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code> is positive definite such that for every\neigenvalue \u03bb (i-th entry of w) and its eigenvector <code class=\"docutils literal notranslate\"><span class=\"pre\">vi</span></code> (i-th column of\n<code class=\"docutils literal notranslate\"><span class=\"pre\">v</span></code>) satisfies:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>              <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">vi</span> <span class=\"o\">=</span> <span class=\"n\">\u03bb</span> <span class=\"o\">*</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">vi</span>\n<span class=\"n\">vi</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">vi</span> <span class=\"o\">=</span> <span class=\"n\">\u03bb</span>\n<span class=\"n\">vi</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">vi</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n</pre></div>\n</div>\n<p>In the standard problem, <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code> is assumed to be the identity matrix.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>a</strong><span class=\"classifier\">(M, M) array_like</span></dt><dd><p>A complex Hermitian or real symmetric matrix whose eigenvalues and\neigenvectors will be computed.</p>\n</dd>\n<dt><strong>b</strong><span class=\"classifier\">(M, M) array_like, optional</span></dt><dd><p>A complex Hermitian or real symmetric definite positive matrix in.\nIf omitted, identity matrix is assumed.</p>\n</dd>\n<dt><strong>lower</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether the pertinent array data is taken from the lower or upper\ntriangle of <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code> and, if applicable, <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code>. (Default: lower)</p>\n</dd>\n<dt><strong>eigvals_only</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to calculate only eigenvalues and no eigenvectors.\n(Default: both are calculated)</p>\n</dd>\n<dt><strong>subset_by_index</strong><span class=\"classifier\">iterable, optional</span></dt><dd><p>If provided, this two-element iterable defines the start and the end\nindices of the desired eigenvalues (ascending order and 0-indexed).\nTo return only the second smallest to fifth smallest eigenvalues,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">[1,</span> <span class=\"pre\">4]</span></code> is used. <code class=\"docutils literal notranslate\"><span class=\"pre\">[n-3,</span> <span class=\"pre\">n-1]</span></code> returns the largest three. Only\navailable with \u201cevr\u201d, \u201cevx\u201d, and \u201cgvx\u201d drivers. The entries are\ndirectly converted to integers via <code class=\"docutils literal notranslate\"><span class=\"pre\">int()</span></code>.</p>\n</dd>\n<dt><strong>subset_by_value</strong><span class=\"classifier\">iterable, optional</span></dt><dd><p>If provided, this two-element iterable defines the half-open interval\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(a,</span> <span class=\"pre\">b]</span></code> that, if any, only the eigenvalues between these values\nare returned. Only available with \u201cevr\u201d, \u201cevx\u201d, and \u201cgvx\u201d drivers. Use\n<code class=\"docutils literal notranslate\"><span class=\"pre\">np.inf</span></code> for the unconstrained ends.</p>\n</dd>\n<dt><strong>driver: str, optional</strong></dt><dd><p>Defines which LAPACK driver should be used. Valid options are \u201cev\u201d,\n\u201cevd\u201d, \u201cevr\u201d, \u201cevx\u201d for standard problems and \u201cgv\u201d, \u201cgvd\u201d, \u201cgvx\u201d for\ngeneralized (where b is not None) problems. See the Notes section.</p>\n</dd>\n<dt><strong>type</strong><span class=\"classifier\">int, optional</span></dt><dd><p>For the generalized problems, this keyword specifies the problem type\nto be solved for <code class=\"docutils literal notranslate\"><span class=\"pre\">w</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">v</span></code> (only takes 1, 2, 3 as possible\ninputs):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"mi\">1</span> <span class=\"o\">=&gt;</span>     <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">w</span> <span class=\"o\">@</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">v</span>\n<span class=\"mi\">2</span> <span class=\"o\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">w</span> <span class=\"o\">@</span> <span class=\"n\">v</span>\n<span class=\"mi\">3</span> <span class=\"o\">=&gt;</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">w</span> <span class=\"o\">@</span> <span class=\"n\">v</span>\n</pre></div>\n</div>\n<p>This keyword is ignored for standard problems.</p>\n</dd>\n<dt><strong>overwrite_a</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to overwrite data in <code class=\"docutils literal notranslate\"><span class=\"pre\">a</span></code> (may improve performance). Default\nis False.</p>\n</dd>\n<dt><strong>overwrite_b</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to overwrite data in <code class=\"docutils literal notranslate\"><span class=\"pre\">b</span></code> (may improve performance). Default\nis False.</p>\n</dd>\n<dt><strong>check_finite</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to check that the input matrices contain only finite numbers.\nDisabling may give a performance gain, but may result in problems\n(crashes, non-termination) if the inputs do contain infinities or NaNs.</p>\n</dd>\n<dt><strong>turbo</strong><span class=\"classifier\">bool, optional</span></dt><dd><p><em>Deprecated since v1.5.0, use ``driver=gvd`` keyword instead</em>.\nUse divide and conquer algorithm (faster but expensive in memory, only\nfor generalized eigenvalue problem and if full set of eigenvalues are\nrequested.). Has no significant effect if eigenvectors are not\nrequested.</p>\n</dd>\n<dt><strong>eigvals</strong><span class=\"classifier\">tuple (lo, hi), optional</span></dt><dd><p><em>Deprecated since v1.5.0, use ``subset_by_index`` keyword instead</em>.\nIndexes of the smallest and largest (in ascending order) eigenvalues\nand corresponding eigenvectors to be returned: 0 &lt;= lo &lt;= hi &lt;= M-1.\nIf omitted, all eigenvalues and eigenvectors are returned.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>w</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>The N (1&lt;=N&lt;=M) selected eigenvalues, in ascending order, each\nrepeated according to its multiplicity.</p>\n</dd>\n<dt><strong>v</strong><span class=\"classifier\">(M, N) ndarray</span></dt><dd><p>(if <code class=\"docutils literal notranslate\"><span class=\"pre\">eigvals_only</span> <span class=\"pre\">==</span> <span class=\"pre\">False</span></code>)</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>LinAlgError</dt><dd><p>If eigenvalue computation does not converge, an error occurred, or\nb matrix is not definite positive. Note that if input matrices are\nnot symmetric or Hermitian, no error will be reported but results will\nbe wrong.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigvalsh</span></code></dt><dd><p>eigenvalues of symmetric or Hermitian arrays</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eig</span></code></dt><dd><p>eigenvalues and right eigenvectors for non-symmetric arrays</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eigh_tridiagonal</span></code></dt><dd><p>eigenvalues and right eiegenvectors for symmetric/Hermitian tridiagonal matrices</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>This function does not check the input array for being hermitian/symmetric\nin order to allow for representing arrays with only their upper/lower\ntriangular parts. Also, note that even though not taken into account,\nfiniteness check applies to the whole array and unaffected by \u201clower\u201d\nkeyword.</p>\n<p>This function uses LAPACK drivers for computations in all possible keyword\ncombinations, prefixed with <code class=\"docutils literal notranslate\"><span class=\"pre\">sy</span></code> if arrays are real and <code class=\"docutils literal notranslate\"><span class=\"pre\">he</span></code> if\ncomplex, e.g., a float array with \u201cevr\u201d driver is solved via\n\u201csyevr\u201d, complex arrays with \u201cgvx\u201d driver problem is solved via \u201chegvx\u201d\netc.</p>\n<p>As a brief summary, the slowest and the most robust driver is the\nclassical <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;sy/he&gt;ev</span></code> which uses symmetric QR. <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;sy/he&gt;evr</span></code> is seen as\nthe optimal choice for the most general cases. However, there are certain\noccassions that <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;sy/he&gt;evd</span></code> computes faster at the expense of more\nmemory usage. <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;sy/he&gt;evx</span></code>, while still being faster than <code class=\"docutils literal notranslate\"><span class=\"pre\">&lt;sy/he&gt;ev</span></code>,\noften performs worse than the rest except when very few eigenvalues are\nrequested for large arrays though there is still no performance guarantee.</p>\n<p>For the generalized problem, normalization with respoect to the given\ntype argument:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">type</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"mi\">3</span> <span class=\"p\">:</span>      <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">w</span>\n<span class=\"nb\">type</span> <span class=\"mi\">2</span>       <span class=\"p\">:</span> <span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">a</span> <span class=\"o\">@</span> <span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">w</span>\n\n<span class=\"nb\">type</span> <span class=\"mi\">1</span> <span class=\"ow\">or</span> <span class=\"mi\">2</span>  <span class=\"p\">:</span>      <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">b</span> <span class=\"o\">@</span> <span class=\"n\">v</span>  <span class=\"o\">=</span> <span class=\"n\">I</span>\n<span class=\"nb\">type</span> <span class=\"mi\">3</span>       <span class=\"p\">:</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">conj</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"o\">@</span> <span class=\"n\">v</span>  <span class=\"o\">=</span> <span class=\"n\">I</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.linalg</span> <span class=\"k\">import</span> <span class=\"n\">eigh</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">eigh</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">A</span> <span class=\"o\">@</span> <span class=\"n\">v</span> <span class=\"o\">-</span> <span class=\"n\">v</span> <span class=\"o\">@</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)))</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Request only the eigenvalues</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">eigh</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">eigvals_only</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Request eigenvalues that are less than 10.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">34</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">44</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">19</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">79</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">34</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">19</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">34</span><span class=\"p\">,</span> <span class=\"mi\">29</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">eigh</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">eigvals_only</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">subset_by_value</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inf</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"go\">array([6.69199443e-07, 9.11938152e+00])</span>\n</pre></div>\n</div>\n<p>Request the largest second eigenvalue and its eigenvector</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">eigh</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">subset_by_index</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">w</span>\n<span class=\"go\">array([9.11938152])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">v</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># only a single column is returned</span>\n<span class=\"go\">(5, 1)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"genpca\">\n<h3>genpca<a class=\"headerlink\" href=\"#genpca\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.genpca\">\n<code class=\"sig-prename descclassname\">dipy.denoise.localpca.</code><code class=\"sig-name descname\">genpca</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">sigma=None</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">patch_radius=2</em>, <em class=\"sig-param\">pca_method='eig'</em>, <em class=\"sig-param\">tau_factor=None</em>, <em class=\"sig-param\">return_sigma=False</em>, <em class=\"sig-param\">out_dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.genpca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>General function to perform PCA-based denoising of diffusion datasets.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float or 3D array (optional)</span></dt><dd><p>Standard deviation of the noise estimated from the data. If no sigma\nis given, this will be estimated based on random matrix theory\n<a class=\"reference internal\" href=\"#r4bed7265c934-1\" id=\"id5\">[1]</a>,[R4bed7265c934-2]_</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). Default: 2 (denoise in blocks of 5x5x5 voxels).</p>\n</dd>\n<dt><strong>pca_method</strong><span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt><strong>tau_factor</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Thresholding of PCA eigenvalues is done by nulling out eigenvalues that\nare smaller than:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\tau = (\\tau_{factor} \\sigma)^2\\]</div>\n<p>tau_{factor} can be set to a predefined values (e.g. tau_{factor} =\n2.3 <a class=\"reference internal\" href=\"#r4bed7265c934-3\" id=\"id6\">[3]</a>), or automatically calculated using random matrix theory\n(in case that tau_{factor} is set to None).\nDefault: None.</p>\n</dd>\n<dt><strong>return_sigma</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, the Standard deviation of the noise will be returned.\nDefault: False.</p>\n</dd>\n<dt><strong>out_dtype</strong><span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r4bed7265c934-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id5\">1</a></span></dt>\n<dd><p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</dd>\n<dt class=\"label\" id=\"r4bed7265c934-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Veraart J, Fieremans E, Novikov DS. 2016. Diffusion MRI noise\nmapping using random matrix theory. Magnetic Resonance in Medicine.\ndoi: 10.1002/mrm.26059.</p>\n</dd>\n<dt class=\"label\" id=\"r4bed7265c934-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id6\">3</a></span></dt>\n<dd><p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)\nDiffusion Weighted Image Denoising Using Overcomplete Local\nPCA. PLoS ONE 8(9): e73021.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0073021\">https://doi.org/10.1371/journal.pone.0073021</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"localpca\">\n<h3>localpca<a class=\"headerlink\" href=\"#localpca\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.localpca\">\n<code class=\"sig-prename descclassname\">dipy.denoise.localpca.</code><code class=\"sig-name descname\">localpca</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">sigma</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">patch_radius=2</em>, <em class=\"sig-param\">pca_method='eig'</em>, <em class=\"sig-param\">tau_factor=2.3</em>, <em class=\"sig-param\">out_dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.localpca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs local PCA denoising according to Manjon et al. <a class=\"reference internal\" href=\"#rc1f8d7038c98-1\" id=\"id10\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float or 3D array</span></dt><dd><p>Standard deviation of the noise estimated from the data.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). Default: 2 (denoise in blocks of 5x5x5 voxels).</p>\n</dd>\n<dt><strong>pca_method</strong><span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt><strong>tau_factor</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Thresholding of PCA eigenvalues is done by nulling out eigenvalues that\nare smaller than:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\tau = (\\tau_{factor} \\sigma)^2\\]</div>\n<p>tau_{factor} can be change to adjust the relationship between the\nnoise standard deviation and the threshold tau. If tau_{factor} is\nset to None, it will be automatically calculated using the\nMarcenko-Pastur distribution <a class=\"reference internal\" href=\"#rc1f8d7038c98-2\" id=\"id11\">[2]</a>.\nDefault: 2.3 (according to <a class=\"reference internal\" href=\"#rc1f8d7038c98-1\" id=\"id12\">[1]</a>)</p>\n</dd>\n<dt><strong>out_dtype</strong><span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc1f8d7038c98-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id10\">1</a>,<a href=\"#id12\">2</a>)</span></dt>\n<dd><p>Manjon JV, Coupe P, Concha L, Buades A, Collins DL (2013)\nDiffusion Weighted Image Denoising Using Overcomplete Local\nPCA. PLoS ONE 8(9): e73021.\n<a class=\"reference external\" href=\"https://doi.org/10.1371/journal.pone.0073021\">https://doi.org/10.1371/journal.pone.0073021</a></p>\n</dd>\n<dt class=\"label\" id=\"rc1f8d7038c98-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id11\">2</a></span></dt>\n<dd><p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mppca\">\n<h3>mppca<a class=\"headerlink\" href=\"#mppca\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.localpca.mppca\">\n<code class=\"sig-prename descclassname\">dipy.denoise.localpca.</code><code class=\"sig-name descname\">mppca</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">patch_radius=2</em>, <em class=\"sig-param\">pca_method='eig'</em>, <em class=\"sig-param\">return_sigma=False</em>, <em class=\"sig-param\">out_dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.localpca.mppca\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs PCA-based denoising using the Marcenko-Pastur\ndistribution <a class=\"reference internal\" href=\"#ra3cd9ccad273-1\" id=\"id15\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>Array of data to be denoised. The dimensions are (X, Y, Z, N), where N\nare the diffusion gradient directions.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D boolean array (optional)</span></dt><dd><p>A mask with voxels that are true inside the brain and false outside of\nit. The function denoises within the true part and returns zeros\noutside of those voxels.</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int or 1D array (optional)</span></dt><dd><p>The radius of the local patch to be taken around each voxel (in\nvoxels). Default: 2 (denoise in blocks of 5x5x5 voxels).</p>\n</dd>\n<dt><strong>pca_method</strong><span class=\"classifier\">\u2018eig\u2019 or \u2018svd\u2019 (optional)</span></dt><dd><p>Use either eigenvalue decomposition (eig) or singular value\ndecomposition (svd) for principal component analysis. The default\nmethod is \u2018eig\u2019 which is faster. However, occasionally \u2018svd\u2019 might be\nmore accurate.</p>\n</dd>\n<dt><strong>return_sigma</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If true, a noise standard deviation estimate based on the\nMarcenko-Pastur distribution is returned <a class=\"reference internal\" href=\"#ra3cd9ccad273-2\" id=\"id16\">[2]</a>.\nDefault: False.</p>\n</dd>\n<dt><strong>out_dtype</strong><span class=\"classifier\">str or dtype (optional)</span></dt><dd><p>The dtype for the output array. Default: output has the same dtype as\nthe input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">4D array</span></dt><dd><p>This is the denoised array of the same size as that of the input data,\nclipped to non-negative values</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">3D array (when return_sigma=True)</span></dt><dd><p>Estimate of the spatial varying standard deviation of the noise</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra3cd9ccad273-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id1\">1</a>,<a href=\"#id15\">2</a>)</span></dt>\n<dd><p>Veraart J, Novikov DS, Christiaens D, Ades-aron B, Sijbers,\nFieremans E, 2016. Denoising of Diffusion MRI using random matrix\ntheory. Neuroimage 142:394-406.\ndoi: 10.1016/j.neuroimage.2016.08.016</p>\n</dd>\n<dt class=\"label\" id=\"ra3cd9ccad273-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id16\">2</a></span></dt>\n<dd><p>Veraart J, Fieremans E, Novikov DS. 2016. Diffusion MRI noise\nmapping using random matrix theory. Magnetic Resonance in Medicine.\ndoi: 10.1002/mrm.26059.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans\">\n<h3>nlmeans<a class=\"headerlink\" href=\"#nlmeans\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.nlmeans.nlmeans\">\n<code class=\"sig-prename descclassname\">dipy.denoise.nlmeans.</code><code class=\"sig-name descname\">nlmeans</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">sigma</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">patch_radius=1</em>, <em class=\"sig-param\">block_radius=5</em>, <em class=\"sig-param\">rician=True</em>, <em class=\"sig-param\">num_threads=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.nlmeans.nlmeans\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-local means for denoising 3D and 4D images</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D ndarray</span></dt><dd></dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float or 3D array</span></dt><dd><p>standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int</span></dt><dd><p>patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong><span class=\"classifier\">int</span></dt><dd><p>block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong><span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n<dt><strong>num_threads</strong><span class=\"classifier\">int</span></dt><dd><p>Number of threads. If None (default) then all available threads\nwill be used (all CPU cores).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">ndarray</span></dt><dd><p>the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r764c162eb15f-descoteaux08\"><span class=\"brackets\">Descoteaux08</span></dt>\n<dd><p>Descoteaux, Maxime and Wiest-Daessl\u00e9, Nicolas and Prima,\nSylvain and Barillot, Christian and Deriche, Rachid\nImpact of Rician Adapted Non-Local Means Filtering on\nHARDI, MICCAI 2008</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans-3d\">\n<h3>nlmeans_3d<a class=\"headerlink\" href=\"#nlmeans-3d\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.nlmeans.nlmeans_3d\">\n<code class=\"sig-prename descclassname\">dipy.denoise.nlmeans.</code><code class=\"sig-name descname\">nlmeans_3d</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.nlmeans.nlmeans_3d\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-local means for denoising 3D images</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">3D ndarray</span></dt><dd><p>The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D ndarray</span></dt><dd></dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float or 3D array</span></dt><dd><p>standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int</span></dt><dd><p>patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong><span class=\"classifier\">int</span></dt><dd><p>block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong><span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n<dt><strong>num_threads</strong><span class=\"classifier\">int</span></dt><dd><p>Number of threads. If None (default) then all available threads\nwill be used.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">ndarray</span></dt><dd><p>the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"convolve\">\n<h3>convolve<a class=\"headerlink\" href=\"#convolve\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.convolve\">\n<code class=\"sig-prename descclassname\">dipy.denoise.noise_estimate.</code><code class=\"sig-name descname\">convolve</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">input</em>, <em class=\"sig-param\">weights</em>, <em class=\"sig-param\">output=None</em>, <em class=\"sig-param\">mode='reflect'</em>, <em class=\"sig-param\">cval=0.0</em>, <em class=\"sig-param\">origin=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.convolve\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Multidimensional convolution.</p>\n<p>The array is convolved with the given kernel.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>input</strong><span class=\"classifier\">array_like</span></dt><dd><p>The input array.</p>\n</dd>\n<dt><strong>weights</strong><span class=\"classifier\">array_like</span></dt><dd><p>Array of weights, same number of dimensions as input</p>\n</dd>\n<dt><strong>output</strong><span class=\"classifier\">array or dtype, optional</span></dt><dd><p>The array in which to place the output, or the dtype of the\nreturned array. By default an array of the same dtype as input\nwill be created.</p>\n</dd>\n<dt><strong>mode</strong><span class=\"classifier\">{\u2018reflect\u2019, \u2018constant\u2019, \u2018nearest\u2019, \u2018mirror\u2019, \u2018wrap\u2019}, optional</span></dt><dd><p>The <cite>mode</cite> parameter determines how the input array is extended\nbeyond its boundaries. Default is \u2018reflect\u2019. Behavior for each valid\nvalue is as follows:</p>\n<dl class=\"simple\">\n<dt>\u2018reflect\u2019 (<cite>d c b a | a b c d | d c b a</cite>)</dt><dd><p>The input is extended by reflecting about the edge of the last\npixel.</p>\n</dd>\n<dt>\u2018constant\u2019 (<cite>k k k k | a b c d | k k k k</cite>)</dt><dd><p>The input is extended by filling all values beyond the edge with\nthe same constant value, defined by the <cite>cval</cite> parameter.</p>\n</dd>\n<dt>\u2018nearest\u2019 (<cite>a a a a | a b c d | d d d d</cite>)</dt><dd><p>The input is extended by replicating the last pixel.</p>\n</dd>\n<dt>\u2018mirror\u2019 (<cite>d c b | a b c d | c b a</cite>)</dt><dd><p>The input is extended by reflecting about the center of the last\npixel.</p>\n</dd>\n<dt>\u2018wrap\u2019 (<cite>a b c d | a b c d | a b c d</cite>)</dt><dd><p>The input is extended by wrapping around to the opposite edge.</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>cval</strong><span class=\"classifier\">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is \u2018constant\u2019. Default\nis 0.0</p>\n</dd>\n<dt><strong>origin</strong><span class=\"classifier\">int or sequence, optional</span></dt><dd><p>Controls the placement of the filter on the input array\u2019s pixels.\nA value of 0 (the default) centers the filter over the pixel, with\npositive values shifting the filter to the left, and negative ones\nto the right. By passing a sequence of origins with length equal to\nthe number of dimensions of the input array, different shifts can\nbe specified along each axis.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The result of convolution of <cite>input</cite> with <cite>weights</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">correlate</span></code></dt><dd><p>Correlate an image with a kernel.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>Each value in result is <span class=\"math notranslate nohighlight\">\\(C_i = \\sum_j{I_{i+k-j} W_j}\\)</span>, where\nW is the <cite>weights</cite> kernel,\nj is the N-D spatial index over <span class=\"math notranslate nohighlight\">\\(W\\)</span>,\nI is the <cite>input</cite> and k is the coordinate of the center of\nW, specified by <cite>origin</cite> in the input parameters.</p>\n<p class=\"rubric\">Examples</p>\n<p>Perhaps the simplest case to understand is <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='constant',</span> <span class=\"pre\">cval=0.0</span></code>,\nbecause in this case borders (i.e., where the <cite>weights</cite> kernel, centered\non any one value, extends beyond an edge of <cite>input</cite>) are treated as zeros.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">ndimage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">)</span>\n<span class=\"go\">array([[11, 10,  7,  4],</span>\n<span class=\"go\">       [10,  3, 11, 11],</span>\n<span class=\"go\">       [15, 12, 14,  7],</span>\n<span class=\"go\">       [12,  3,  7,  0]])</span>\n</pre></div>\n</div>\n<p>Setting <code class=\"docutils literal notranslate\"><span class=\"pre\">cval=1.0</span></code> is equivalent to padding the outer edge of <cite>input</cite>\nwith 1.0\u2019s (and then extracting only the original region of the result).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;constant&#39;</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n<span class=\"go\">array([[13, 11,  8,  7],</span>\n<span class=\"go\">       [11,  3, 11, 14],</span>\n<span class=\"go\">       [16, 12, 14, 10],</span>\n<span class=\"go\">       [15,  6, 10,  5]])</span>\n</pre></div>\n</div>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='reflect'</span></code> (the default), outer values are reflected at the\nedge of <cite>input</cite> to fill in missing values.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;reflect&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([[5, 0, 0],</span>\n<span class=\"go\">       [3, 0, 0],</span>\n<span class=\"go\">       [1, 0, 0]])</span>\n</pre></div>\n</div>\n<p>This includes diagonally at the corners.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n<span class=\"go\">array([[4, 2, 0],</span>\n<span class=\"go\">       [3, 2, 0],</span>\n<span class=\"go\">       [1, 1, 0]])</span>\n</pre></div>\n</div>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">mode='nearest'</span></code>, the single nearest value in to an edge in\n<cite>input</cite> is repeated as many times as needed to match the overlapping\n<cite>weights</cite>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>              <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">convolve</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([[7, 0, 3],</span>\n<span class=\"go\">       [5, 0, 2],</span>\n<span class=\"go\">       [3, 0, 1]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"estimate-sigma\">\n<h3>estimate_sigma<a class=\"headerlink\" href=\"#estimate-sigma\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.estimate_sigma\">\n<code class=\"sig-prename descclassname\">dipy.denoise.noise_estimate.</code><code class=\"sig-name descname\">estimate_sigma</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">disable_background_masking=False</em>, <em class=\"sig-param\">N=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.estimate_sigma\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Standard deviation estimation from local patches</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be estimated</p>\n</dd>\n<dt><strong>disable_background_masking</strong><span class=\"classifier\">bool, default False</span></dt><dd><p>If True, uses all voxels for the estimation, otherwise, only non-zeros\nvoxels are used. Useful if the background is masked by the scanner.</p>\n</dd>\n<dt><strong>N</strong><span class=\"classifier\">int, default 0</span></dt><dd><p>Number of coils of the receiver array. Use N = 1 in case of a SENSE\nreconstruction (Philips scanners) or the number of coils for a GRAPPA\nreconstruction (Siemens and GE). Use 0 to disable the correction factor,\nas for example if the noise is Gaussian distributed. See [1] for more\ninformation.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sigma</strong><span class=\"classifier\">ndarray</span></dt><dd><p>standard deviation of the noise, one estimation per volume.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This function is the same as manually taking the standard deviation of the\nbackground and gives one value for the whole 3D array.\nIt also includes the coil-dependent correction factor of Koay 2006\n(see <a class=\"reference internal\" href=\"#rcc704f07ad21-1\" id=\"id20\">[1]</a>, equation 18) with theta = 0.\nSince this function was introduced in <a class=\"reference internal\" href=\"#rcc704f07ad21-2\" id=\"id21\">[2]</a> for T1 imaging,\nit is expected to perform ok on diffusion MRI data, but might oversmooth\nsome regions and leave others un-denoised for spatially varying noise\nprofiles. Consider using <a class=\"reference internal\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"dipy.denoise.noise_estimate.piesno\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">piesno()</span></code></a> to estimate sigma instead if visual\ninaccuracies are apparent in the denoised result.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcc704f07ad21-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id20\">1</a></span></dt>\n<dd><p>Koay, C. G., &amp; Basser, P. J. (2006). Analytically exact correction</p>\n</dd>\n</dl>\n<p>scheme for signal extraction from noisy magnitude MR signals.\nJournal of Magnetic Resonance), 179(2), 317-22.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcc704f07ad21-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id21\">2</a></span></dt>\n<dd><p>Coupe, P., Yger, P., Prima, S., Hellier, P., Kervrann, C., Barillot,</p>\n</dd>\n</dl>\n<p>C., 2008. An optimized blockwise nonlocal means denoising filter for 3-D\nmagnetic resonance images, IEEE Trans. Med. Imaging 27, 425-41.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"piesno\">\n<h3>piesno<a class=\"headerlink\" href=\"#piesno\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.noise_estimate.piesno\">\n<code class=\"sig-prename descclassname\">dipy.denoise.noise_estimate.</code><code class=\"sig-name descname\">piesno</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">N</em>, <em class=\"sig-param\">alpha=0.01</em>, <em class=\"sig-param\">l=100</em>, <em class=\"sig-param\">itermax=100</em>, <em class=\"sig-param\">eps=1e-05</em>, <em class=\"sig-param\">return_mask=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.noise_estimate.piesno\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Probabilistic Identification and Estimation of Noise (PIESNO).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The magnitude signals to analyse. The last dimension must contain the\nsame realisation of the volume, such as dMRI or fMRI data.</p>\n</dd>\n<dt><strong>N</strong><span class=\"classifier\">int</span></dt><dd><p>The number of phase array coils of the MRI scanner.\nIf your scanner does a SENSE reconstruction, ALWAYS use N=1, as the\nnoise profile is always Rician.\nIf your scanner does a GRAPPA reconstruction, set N as the number\nof phase array coils.</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float</span></dt><dd><p>Probabilistic estimation threshold for the gamma function.</p>\n</dd>\n<dt><strong>l</strong><span class=\"classifier\">int</span></dt><dd><p>number of initial estimates for sigma to try.</p>\n</dd>\n<dt><strong>itermax</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to execute if convergence\nis not reached.</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">float</span></dt><dd><p>Tolerance for the convergence criterion. Convergence is\nreached if two subsequent estimates are smaller than eps.</p>\n</dd>\n<dt><strong>return_mask</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, return a mask identifying all the pure noise voxel\nthat were found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sigma</strong><span class=\"classifier\">float</span></dt><dd><p>The estimated standard deviation of the gaussian noise.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray (optional)</span></dt><dd><p>A boolean mask indicating the voxels identified as pure noise.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This function assumes two things : 1. The data has a noisy, non-masked\nbackground and 2. The data is a repetition of the same measurements\nalong the last axis, i.e. dMRI or fMRI data, not structural data like\nT1/T2.</p>\n<p>This function processes the data slice by slice, as originally designed in\nthe paper. Use it to get a slice by slice estimation of the noise, as in\nspinal cord imaging for example.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc7d3e0e673f9-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Koay CG, Ozarslan E and Pierpaoli C.</p>\n</dd>\n</dl>\n<p>\u201cProbabilistic Identification and Estimation of Noise (PIESNO):\nA self-consistent approach and its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 199: 94-103.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc7d3e0e673f9-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Koay CG, Ozarslan E and Basser PJ.</p>\n</dd>\n</dl>\n<p>\u201cA signal transformational framework for breaking the noise floor\nand its applications in MRI.\u201d\nJournal of Magnetic Resonance 2009; 197: 108-119.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlmeans-block\">\n<h3>nlmeans_block<a class=\"headerlink\" href=\"#nlmeans-block\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.non_local_means.nlmeans_block\">\n<code class=\"sig-prename descclassname\">dipy.denoise.non_local_means.</code><code class=\"sig-name descname\">nlmeans_block</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.non_local_means.nlmeans_block\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Non-Local Means Denoising Using Blockwise Averaging</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>image</strong><span class=\"classifier\">3D array of doubles</span></dt><dd><p>the input image, corrupted with rician noise</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D array of doubles</span></dt><dd><p>the input mask</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int</span></dt><dd><p>similar patches in the non-local means are searched for locally,\ninside a cube of side 2*v+1 centered at each voxel of interest.</p>\n</dd>\n<dt><strong>block_radius</strong><span class=\"classifier\">int</span></dt><dd><p>the size of the block to be used (2*f+1)x(2*f+1)x(2*f+1) in the\nblockwise non-local means implementation (the Coupe\u2019s proposal).</p>\n</dd>\n<dt><strong>h</strong><span class=\"classifier\">double</span></dt><dd><p>the estimated amount of rician noise in the input image: in P.\nCoupe et al. the rician noise was simulated as\nsqrt((f+x)^2 + (y)^2) where f is the pixel value and x and y are\nindependent realizations of a random variable with Normal\ndistribution, with mean=0 and standard deviation=h</p>\n</dd>\n<dt><strong>rician</strong><span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>fima: 3D double array</dt><dd><p>the denoised output which has the same shape as input image.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"simple\">\n<dt>[1] P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C. Barillot,</dt><dd><p>\u201cAn Optimized Blockwise Non Local Means Denoising Filter for 3D Magnetic\nResonance Images\u201d\nIEEE Transactions on Medical Imaging, 27(4):425-441, 2008</p>\n</dd>\n<dt>[2] Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.</dt><dd><p>\u201cMultiresolution Non-Local Means Filter for 3D MR Image Denoising\u201d\nIET Image Processing, Institution of Engineering and Technology, 2011</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"non-local-means\">\n<h3>non_local_means<a class=\"headerlink\" href=\"#non-local-means\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.denoise.non_local_means.non_local_means\">\n<code class=\"sig-prename descclassname\">dipy.denoise.non_local_means.</code><code class=\"sig-name descname\">non_local_means</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">sigma</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">patch_radius=1</em>, <em class=\"sig-param\">block_radius=5</em>, <em class=\"sig-param\">rician=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.denoise.non_local_means.non_local_means\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Non-local means for denoising 3D and 4D images, using</dt><dd><p>blockwise averaging approach</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">3D or 4D ndarray</span></dt><dd><p>The array to be denoised</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">3D ndarray</span></dt><dd></dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float</span></dt><dd><p>standard deviation of the noise estimated from the data</p>\n</dd>\n<dt><strong>patch_radius</strong><span class=\"classifier\">int</span></dt><dd><p>patch size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">patch_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 1.</p>\n</dd>\n<dt><strong>block_radius</strong><span class=\"classifier\">int</span></dt><dd><p>block size is <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span> <span class=\"pre\">x</span> <span class=\"pre\">block_radius</span> <span class=\"pre\">+</span> <span class=\"pre\">1</span></code>. Default is 5.</p>\n</dd>\n<dt><strong>rician</strong><span class=\"classifier\">boolean</span></dt><dd><p>If True the noise is estimated as Rician, otherwise Gaussian noise\nis assumed.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>denoised_arr</strong><span class=\"classifier\">ndarray</span></dt><dd><p>the denoised <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code> which has the same shape as <code class=\"docutils literal notranslate\"><span class=\"pre\">arr</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rad5f4d89a56a-coupe08\"><span class=\"brackets\">Coupe08</span></dt>\n<dd><p>P. Coupe, P. Yger, S. Prima, P. Hellier, C. Kervrann, C.\nBarillot, An Optimized Blockwise Non Local Means Denoising\nFilter for 3D Magnetic Resonance Images, IEEE Transactions on\nMedical Imaging, 27(4):425-441, 2008</p>\n</dd>\n<dt class=\"label\" id=\"rad5f4d89a56a-coupe11\"><span class=\"brackets\">Coupe11</span></dt>\n<dd><p>Pierrick Coupe, Jose Manjon, Montserrat Robles, Louis Collins.\nAdaptive Multiresolution Non-Local Means Filter for 3D MR Image\nDenoising IET Image Processing, Institution of Engineering and\nTechnology, 2011</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["reference/dipy.direction", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">direction</span></code>", "N", "next"], ["reference/dipy.data", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">data</span></code>", "P", "previous"]], "sourcename": "reference/dipy.denoise.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.adaptive_soft_matching\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.adaptive_soft_matching</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.gibbs\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.gibbs</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.localpca\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.localpca</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.nlmeans\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.nlmeans</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.noise_estimate\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.noise_estimate</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.denoise.non_local_means\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">denoise.non_local_means</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#bench\">bench</a></li>\n<li><a class=\"reference internal\" href=\"#test\">test</a></li>\n<li><a class=\"reference internal\" href=\"#adaptive-soft-matching\">adaptive_soft_matching</a></li>\n<li><a class=\"reference internal\" href=\"#gibbs-removal\">gibbs_removal</a></li>\n<li><a class=\"reference internal\" href=\"#eigh\">eigh</a></li>\n<li><a class=\"reference internal\" href=\"#genpca\">genpca</a></li>\n<li><a class=\"reference internal\" href=\"#localpca\">localpca</a></li>\n<li><a class=\"reference internal\" href=\"#mppca\">mppca</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans\">nlmeans</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans-3d\">nlmeans_3d</a></li>\n<li><a class=\"reference internal\" href=\"#convolve\">convolve</a></li>\n<li><a class=\"reference internal\" href=\"#estimate-sigma\">estimate_sigma</a></li>\n<li><a class=\"reference internal\" href=\"#piesno\">piesno</a></li>\n<li><a class=\"reference internal\" href=\"#nlmeans-block\">nlmeans_block</a></li>\n<li><a class=\"reference internal\" href=\"#non-local-means\">non_local_means</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "reference/dipy.denoise", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}