{"parents": [], "prev": null, "next": null, "title": "Enhancing QuickBundles with different metrics and features", "meta": {}, "body": "<section id=\"enhancing-quickbundles-with-different-metrics-and-features\">\n<span id=\"example-segment-extending-clustering-framework\"></span><h1>Enhancing QuickBundles with different metrics and features<a class=\"headerlink\" href=\"#enhancing-quickbundles-with-different-metrics-and-features\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>QuickBundles <a class=\"reference internal\" href=\"../../interfaces/tracking_flow/#garyfallidis12\" id=\"id1\"><span>[Garyfallidis12]</span></a> is a flexible algorithm that requires only a\ndistance metric and an adjacency threshold to perform clustering. There is a\nwide variety of metrics that could be used to cluster streamlines.</p>\n<p>The purpose of this tutorial is to show how to easily create new <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code>\nand new <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code> classes that can be used by QuickBundles.</p>\n<section id=\"clustering-framework\">\n<span id=\"id2\"></span><h2>Clustering framework<a class=\"headerlink\" href=\"#clustering-framework\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><a class=\"reference external\" href=\"http://dipy.org\">DIPY</a> provides a simple, flexible and fast framework to do clustering of\nsequential data (e.g. streamlines).</p>\n<p>A <em>sequential datum</em> in DIPY is represented as a numpy array of size\n<span class=\"math notranslate nohighlight\">\\((N \\times D)\\)</span>, where each row of the array represents a <span class=\"math notranslate nohighlight\">\\(D\\)</span> dimensional\npoint of the sequence. A set of these sequences is represented as a list of\nnumpy arrays of size <span class=\"math notranslate nohighlight\">\\((N_i \\times D)\\)</span> for <span class=\"math notranslate nohighlight\">\\(i=1:M\\)</span> where <span class=\"math notranslate nohighlight\">\\(M\\)</span> is the\nnumber of sequences in the set.</p>\n<p>This clustering framework is modular and divided in three parts:</p>\n<ol class=\"arabic simple\">\n<li><p>Feature extraction</p></li>\n<li><p>Distance computation</p></li>\n<li><p>Clustering algorithm</p></li>\n</ol>\n<p>The <strong>feature extraction</strong> part includes any preprocessing needed to be done on\nthe data before computing distances between them (e.g. resampling the number of\npoints of a streamline). To define a new way of extracting features, one has to\nsubclass <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code> (see below).</p>\n<p>The <strong>distance computation</strong> part includes any metric capable of evaluating a\ndistance between two sets of features previously extracted from the data. To\ndefine a new way of extracting features, one has to subclass <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code> (see\nbelow).</p>\n<p>The <strong>clustering algorithm</strong> part represents the clustering algorithm itself\n(e.g. QuickBundles, K-means, Hierarchical Clustering). More precisely, it\nincludes any algorithms taking as input a list of sequential data and\noutputting a <code class=\"docutils literal notranslate\"><span class=\"pre\">ClusterMap</span></code> object.</p>\n</section>\n<section id=\"extending-feature\">\n<h2>Extending <cite>Feature</cite><a class=\"headerlink\" href=\"#extending-feature\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new feature extraction\nmethod that can be used in the context of this clustering framework. For a\nlist of available features in DIPY see <a class=\"reference internal\" href=\"../segment_clustering_features/#example-segment-clustering-features\"><span class=\"std std-ref\">Tractography Clustering - Available Features</span></a>.</p>\n<p>Assuming a set of streamlines, the type of features we want to extract is the\narc length (i.e. the sum of the length of each segment for a given streamline).</p>\n<p>Let\u2019s start by importing the necessary modules.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"kn\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.io.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">load_tractogram</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">Streamlines</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"kn\">import</span> <span class=\"n\">window</span><span class=\"p\">,</span> <span class=\"n\">actor</span><span class=\"p\">,</span> <span class=\"n\">colormap</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"kn\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.featurespeed</span> <span class=\"kn\">import</span> <span class=\"n\">Feature</span><span class=\"p\">,</span> <span class=\"n\">VectorOfEndpointsFeature</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"kn\">import</span> <span class=\"n\">Metric</span><span class=\"p\">,</span> <span class=\"n\">SumPointwiseEuclideanMetric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"kn\">import</span> <span class=\"n\">length</span>\n</pre></div>\n</div>\n<p>We now define the class <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code> that will perform the desired\nfeature extraction. When subclassing <code class=\"docutils literal notranslate\"><span class=\"pre\">Feature</span></code>, two methods have to be\nredefined: <code class=\"docutils literal notranslate\"><span class=\"pre\">infer_shape</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">extract</span></code>.</p>\n<p>Also, an important property about feature extraction is whether or not\nits process is invariant to the order of the points within a streamline.\nThis is needed as there is no way one can tell which extremity of a\nstreamline is the beginning and which one is the end.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">ArcLengthFeature</span><span class=\"p\">(</span><span class=\"n\">Feature</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Computes the arc length of a streamline. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># The arc length stays the same even if the streamline is reversed.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">is_order_invariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">infer_shape</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Infers the shape of features extracted from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># Arc length is a scalar</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">extract</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Extracts features from `streamline`. &quot;&quot;&quot;</span>\n        <span class=\"c1\"># return np.sum(np.sqrt(np.sum((streamline[1:] - streamline[:-1]) ** 2)))</span>\n        <span class=\"c1\"># or use a DIPY&#39;s function that computes the arc length of a streamline.</span>\n        <span class=\"k\">return</span> <span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">streamline</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The new feature extraction <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code> is ready to be used. Let\u2019s use\nit to cluster a set of streamlines by their arc length. For educational\npurposes we will try to cluster a small streamline bundle known from\nneuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span>\n                         <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">Streamlines</span><span class=\"p\">(</span><span class=\"n\">fornix</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using the metric\n<code class=\"docutils literal notranslate\"><span class=\"pre\">SumPointwiseEuclideanMetric</span></code> and our <code class=\"docutils literal notranslate\"><span class=\"pre\">ArcLengthFeature</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">SumPointwiseEuclideanMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">ArcLengthFeature</span><span class=\"p\">())</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">cmap</span> <span class=\"o\">=</span> <span class=\"n\">colormap</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"o\">.</span><span class=\"n\">centroids</span><span class=\"p\">))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_arclength.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Enables/disables interactive visualization</span>\n<span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id4\">\n<img alt=\"../../_images/fornix_clusters_arclength.png\" src=\"../../_images/fornix_clusters_arclength.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Showing the different clusters obtained by using the arc length.</span><a class=\"headerlink\" href=\"#id4\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n</section>\n<section id=\"extending-metric\">\n<h2>Extending <cite>Metric</cite><a class=\"headerlink\" href=\"#extending-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>This section will guide you through the creation of a new metric that can be\nused in the context of this clustering framework. For a list of available\nmetrics in DIPY see <a class=\"reference internal\" href=\"../segment_clustering_metrics/#example-segment-clustering-metrics\"><span class=\"std std-ref\">Tractography Clustering - Available Metrics</span></a>.</p>\n<p>Assuming a set of streamlines, we want a metric that computes the cosine\ndistance giving the vector between endpoints of each streamline (i.e. one\nminus the cosine of the angle between two vectors). For more information\nabout this distance check <a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Cosine_similarity\">http://en.wikipedia.org/wiki/Cosine_similarity</a>.</p>\n<p>Let\u2019s start by importing the necessary modules.</p>\n<p>We now define the class <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code> that will perform the desired\ndistance computation. When subclassing <code class=\"docutils literal notranslate\"><span class=\"pre\">Metric</span></code>, two methods have to be\nredefined: <code class=\"docutils literal notranslate\"><span class=\"pre\">are_compatible</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">dist</span></code>. Moreover, when implementing the\n<code class=\"docutils literal notranslate\"><span class=\"pre\">dist</span></code> method, one needs to make sure the distance returned is symmetric\n(i.e. <cite>dist(A, B) == dist(B, A)</cite>).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">CosineMetric</span><span class=\"p\">(</span><span class=\"n\">Metric</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; Computes the cosine distance between two streamlines. &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># For simplicity, features will be the vector between endpoints of a streamline.</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">CosineMetric</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">VectorOfEndpointsFeature</span><span class=\"p\">())</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">are_compatible</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">shape1</span><span class=\"p\">,</span> <span class=\"n\">shape2</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Checks if two features are vectors of same dimension.</span>\n\n<span class=\"sd\">        Basically this method exists so that we don&#39;t have to check</span>\n<span class=\"sd\">        inside the `dist` method (speedup).</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">return</span> <span class=\"n\">shape1</span> <span class=\"o\">==</span> <span class=\"n\">shape2</span> <span class=\"ow\">and</span> <span class=\"n\">shape1</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dist</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; Computes a the cosine distance between two vectors. &quot;&quot;&quot;</span>\n        <span class=\"n\">norm</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">))</span>\n\n        <span class=\"c1\"># Make sure it&#39;s in [-1, 1], i.e. within domain of arccosine</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">minimum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"n\">cos_theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arccos</span><span class=\"p\">(</span><span class=\"n\">cos_theta</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span>  <span class=\"c1\"># Normalized cosine distance</span>\n</pre></div>\n</div>\n<p>The new distance <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code> is ready to be used. Let\u2019s use\nit to cluster a set of streamlines according to the cosine distance of the\nvector between their endpoints. For educational purposes we will try to\ncluster a small streamline bundle known from neuroanatomy as the fornix.</p>\n<p>We start by loading the fornix streamlines.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span> <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">fornix</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n</pre></div>\n</div>\n<p>Perform QuickBundles clustering using our metric <code class=\"docutils literal notranslate\"><span class=\"pre\">CosineMetric</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CosineMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We will now visualize the clustering result.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">cmap</span> <span class=\"o\">=</span> <span class=\"n\">colormap</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">cmap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;fornix_clusters_cosine.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<figure class=\"align-center\" id=\"id5\">\n<img alt=\"../../_images/fornix_clusters_cosine.png\" src=\"../../_images/fornix_clusters_cosine.png\" />\n<figcaption>\n<p><span class=\"caption-text\">Showing the different clusters obtained by using the cosine metric.</span><a class=\"headerlink\" href=\"#id5\" title=\"Permalink to this image\">\u00b6</a></p>\n</figcaption>\n</figure>\n<section id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"garyfallidis12\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id1\">Garyfallidis12</a></span></dt>\n<dd><p>Garyfallidis E. et al., QuickBundles a method for\ntractography simplification, Frontiers in Neuroscience, vol 6, no 175,\n2012.</p>\n</dd>\n</dl>\n<div class=\"admonition-example-source-code admonition\">\n<p class=\"admonition-title\">Example source code</p>\n<p>You can download <a class=\"reference download internal\" download=\"\" href=\"../../_downloads/cbf9bfe1605f753229cdeb6f92bb7023/segment_extending_clustering_framework.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">the</span> <span class=\"pre\">full</span> <span class=\"pre\">source</span> <span class=\"pre\">code</span> <span class=\"pre\">of</span> <span class=\"pre\">this</span> <span class=\"pre\">example</span></code></a>. This same script is also included in the dipy source distribution under the <code class=\"file docutils literal notranslate\"><span class=\"pre\">doc/examples/</span></code> directory.</p>\n</div>\n</section>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.17.1: http://docutils.sourceforge.net/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/segment_extending_clustering_framework.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Enhancing QuickBundles with different metrics and features</a><ul>\n<li><a class=\"reference internal\" href=\"#clustering-framework\">Clustering framework</a></li>\n<li><a class=\"reference internal\" href=\"#extending-feature\">Extending <cite>Feature</cite></a></li>\n<li><a class=\"reference internal\" href=\"#extending-metric\">Extending <cite>Metric</cite></a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/segment_extending_clustering_framework", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.12"}