{"parents": [], "prev": null, "next": null, "title": "Tractography Clustering - Available Metrics", "meta": {}, "body": "<div class=\"sphx-glr-download-link-note admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>Click <a class=\"reference internal\" href=\"#sphx-glr-download-examples-built-segmentation-segment-clustering-metrics-py\"><span class=\"std std-ref\">here</span></a>     to download the full example code</p>\n</div>\n<div class=\"sphx-glr-example-title section\" id=\"tractography-clustering-available-metrics\">\n<span id=\"sphx-glr-examples-built-segmentation-segment-clustering-metrics-py\"></span><h1>Tractography Clustering - Available Metrics<a class=\"headerlink\" href=\"#tractography-clustering-available-metrics\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>This page lists available metrics that can be used by the tractography\nclustering framework. For every metric a brief description is provided\nexplaining: what it does, when it\u2019s useful and how to use it. If you are not\nfamiliar with the tractography clustering framework, check this tutorial\n<a class=\"reference internal\" href=\"../segment_extending_clustering_framework/#clustering-framework\"><span class=\"std std-ref\">Clustering framework</span></a>.</p>\n<div class=\"contents local topic\" id=\"available-metrics\">\n<p class=\"topic-title first\">Available Metrics</p>\n<ul class=\"simple\">\n<li><p><a class=\"reference internal\" href=\"#average-of-pointwise-euclidean-metric\" id=\"id2\">Average of Pointwise Euclidean Metric</a></p></li>\n<li><p><a class=\"reference internal\" href=\"#sum-of-pointwise-euclidean-metric\" id=\"id3\">Sum of Pointwise Euclidean Metric</a></p></li>\n<li><p><a class=\"reference internal\" href=\"#cosine-metric\" id=\"id4\">Cosine Metric</a></p></li>\n</ul>\n</div>\n<p><strong>Note</strong>:\nAll examples assume a function <cite>get_streamlines</cite> exists. We defined here a\nsimple function to do so. It imports the necessary modules and load a small\nstreamline bundle.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">get_streamlines</span><span class=\"p\">():</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_fnames</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">dipy.io.streamline</span> <span class=\"k\">import</span> <span class=\"n\">load_tractogram</span>\n\n    <span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span> <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">fornix</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"average-of-pointwise-euclidean-metric\">\n<span id=\"clustering-examples-averagepointwiseeuclideanmetric\"></span><h2><a class=\"toc-backref\" href=\"#id2\">Average of Pointwise Euclidean Metric</a><a class=\"headerlink\" href=\"#average-of-pointwise-euclidean-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>AveragePointwiseEuclideanMetric</cite> first compute the\npointwise Euclidean distance between two sequences <em>of same length</em> then\nreturn the average of those distances. This metric takes as inputs two\nfeatures that are sequences containing the same number of elements.</p>\n<p><strong>When:</strong> By default the <cite>QuickBundles</cite> clustering will resample your\nstreamlines on-the-fly so they have 12 points. If for some reason you want\nto avoid this and you made sure all your streamlines have already the same\nnumber of points, you can manually provide an instance of\n<cite>AveragePointwiseEuclideanMetric</cite> to <cite>QuickBundles</cite>. Since the default\n<cite>Feature</cite> is the <cite>IdentityFeature</cite> the streamlines won\u2019t be resampled thus\nsaving some computational time.</p>\n<p><strong>Note:</strong> Inputs must be sequences of same length.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"c1\"># Make sure our streamlines have the same number of points.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the instance of `AveragePointwiseEuclideanMetric` to use.</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Nb. clusters:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cluster sizes:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p class=\"sphx-glr-script-out\">Out:</p>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Nb. clusters: 4\nCluster sizes: &lt;map object at 0x17c382f50&gt;\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"sum-of-pointwise-euclidean-metric\">\n<span id=\"clustering-examples-sumpointwiseeuclideanmetric\"></span><h2><a class=\"toc-backref\" href=\"#id3\">Sum of Pointwise Euclidean Metric</a><a class=\"headerlink\" href=\"#sum-of-pointwise-euclidean-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>SumPointwiseEuclideanMetric</cite> first compute the\npointwise Euclidean distance between two sequences <em>of same length</em> then\nreturn the sum of those distances.</p>\n<p><strong>When:</strong> This metric mainly exists because it is used internally by\n<cite>AveragePointwiseEuclideanMetric</cite>.</p>\n<p><strong>Note:</strong> Inputs must be sequences of same length.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">SumPointwiseEuclideanMetric</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"c1\"># Make sure our streamlines have the same number of points.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"n\">nb_points</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"n\">nb_points</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the instance of `SumPointwiseEuclideanMetric` to use.</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">SumPointwiseEuclideanMetric</span><span class=\"p\">()</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"o\">*</span><span class=\"n\">nb_points</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Nb. clusters:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Cluster sizes:&quot;</span><span class=\"p\">,</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p class=\"sphx-glr-script-out\">Out:</p>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>Nb. clusters: 4\nCluster sizes: &lt;map object at 0x17c47ea50&gt;\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"cosine-metric\">\n<h2><a class=\"toc-backref\" href=\"#id4\">Cosine Metric</a><a class=\"headerlink\" href=\"#cosine-metric\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p><strong>What:</strong> Instances of <cite>CosineMetric</cite> compute the cosine distance between two\nvectors (for more information see the\n<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Cosine_similarity\">wiki page</a>).</p>\n<p><strong>When:</strong> This metric can be useful when you <em>only</em> need information about\nthe orientation of a streamline.</p>\n<p><strong>Note:</strong> Inputs must be vectors (i.e. 1D array).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.viz</span> <span class=\"k\">import</span> <span class=\"n\">window</span><span class=\"p\">,</span> <span class=\"n\">actor</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">VectorOfEndpointsFeature</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">CosineMetric</span>\n\n<span class=\"c1\"># Enables/disables interactive visualization</span>\n<span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n<span class=\"c1\"># Get some streamlines.</span>\n<span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">get_streamlines</span><span class=\"p\">()</span>  <span class=\"c1\"># Previously defined.</span>\n\n<span class=\"n\">feature</span> <span class=\"o\">=</span> <span class=\"n\">VectorOfEndpointsFeature</span><span class=\"p\">()</span>\n<span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">CosineMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">)</span>\n<span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Color each streamline according to the cluster they belong to.</span>\n<span class=\"n\">colormap</span> <span class=\"o\">=</span> <span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">create_colormap</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)))</span>\n<span class=\"n\">colormap_full</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">),</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"k\">for</span> <span class=\"n\">cluster</span><span class=\"p\">,</span> <span class=\"n\">color</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">,</span> <span class=\"n\">colormap</span><span class=\"p\">):</span>\n    <span class=\"n\">colormap_full</span><span class=\"p\">[</span><span class=\"n\">cluster</span><span class=\"o\">.</span><span class=\"n\">indices</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">color</span>\n\n<span class=\"c1\"># Visualization</span>\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">SetBackground</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">actor</span><span class=\"o\">.</span><span class=\"n\">streamtube</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"n\">colormap_full</span><span class=\"p\">))</span>\n<span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;cosine_metric.png&#39;</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">interactive</span><span class=\"p\">:</span>\n    <span class=\"n\">window</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<img alt=\"segment clustering metrics\" class=\"sphx-glr-single-img\" src=\"../../../_images/sphx_glr_segment_clustering_metrics_001.png\" />\n<p class=\"sphx-glr-script-out\">Out:</p>\n<div class=\"sphx-glr-script-out highlight-none notranslate\"><div class=\"highlight\"><pre><span></span>/Users/koudoro/miniconda3/envs/dipy-env-37/lib/python3.7/site-packages/vtkmodules/util/numpy_support.py:66: DeprecationWarning: Converting `np.character` to a dtype is deprecated. The current result is `np.dtype(np.str_)` which is not strictly correct. Note that `np.character` is generally deprecated and &#39;S1&#39; should be used.\n  if numpy_array_type == key or \\\n/Users/koudoro/miniconda3/envs/dipy-env-37/lib/python3.7/site-packages/vtkmodules/util/numpy_support.py:68: DeprecationWarning: Converting `np.character` to a dtype is deprecated. The current result is `np.dtype(np.str_)` which is not strictly correct. Note that `np.character` is generally deprecated and &#39;S1&#39; should be used.\n  numpy_array_type == numpy.dtype(key):\n/Users/koudoro/miniconda3/envs/dipy-env-37/lib/python3.7/site-packages/fury/utils.py:97: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray\n  data = np.array(data)\n</pre></div>\n</div>\n<div class=\"figure align-center\" id=\"id1\">\n<img alt=\"examples_built/segmentation/cosine_metric.png\" src=\"examples_built/segmentation/cosine_metric.png\" />\n<p class=\"caption\"><span class=\"caption-text\">Showing the streamlines colored according to their orientation.</span><a class=\"headerlink\" href=\"#id1\" title=\"Permalink to this image\">\u00b6</a></p>\n</div>\n<div class=\"section\" id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"garyfallidis12\"><span class=\"brackets\">Garyfallidis12</span></dt>\n<dd><p>Garyfallidis E. et al., QuickBundles a method for\ntractography simplification, Frontiers in Neuroscience, vol 6, no 175,\n2012.</p>\n</dd>\n</dl>\n<p class=\"sphx-glr-timing\"><strong>Total running time of the script:</strong> ( 0 minutes  0.202 seconds)</p>\n<div class=\"sphx-glr-footer class sphx-glr-footer-example docutils container\" id=\"sphx-glr-download-examples-built-segmentation-segment-clustering-metrics-py\">\n<div class=\"sphx-glr-download sphx-glr-download-python docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/1afbfb811ea7bbdba52f5f84da26bd95/segment_clustering_metrics.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Python</span> <span class=\"pre\">source</span> <span class=\"pre\">code:</span> <span class=\"pre\">segment_clustering_metrics.py</span></code></a></p>\n</div>\n<div class=\"sphx-glr-download sphx-glr-download-jupyter docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/de5049d1477b7cffe51a78e7902c2824/segment_clustering_metrics.ipynb\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Jupyter</span> <span class=\"pre\">notebook:</span> <span class=\"pre\">segment_clustering_metrics.ipynb</span></code></a></p>\n</div>\n</div>\n<p class=\"sphx-glr-signature\"><a class=\"reference external\" href=\"https://sphinx-gallery.github.io\">Gallery generated by Sphinx-Gallery</a></p>\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "sourcename": "examples_built/segmentation/segment_clustering_metrics.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Tractography Clustering - Available Metrics</a><ul>\n<li><a class=\"reference internal\" href=\"#average-of-pointwise-euclidean-metric\">Average of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#sum-of-pointwise-euclidean-metric\">Sum of Pointwise Euclidean Metric</a></li>\n<li><a class=\"reference internal\" href=\"#cosine-metric\">Cosine Metric</a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples_built/segmentation/segment_clustering_metrics", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}