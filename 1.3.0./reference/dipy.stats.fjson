{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "API Reference"}], "prev": {"link": "../dipy.sims/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">sims</span></code>"}, "next": {"link": "../dipy.tracking/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">tracking</span></code>"}, "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">stats</span></code>", "meta": {}, "body": "<div class=\"section\" id=\"module-dipy.stats\">\n<span id=\"stats\"></span><h1><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">stats</span></code><a class=\"headerlink\" href=\"#module-dipy.stats\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n</tbody>\n</table>\n<div class=\"section\" id=\"module-dipy.stats.analysis\">\n<span id=\"module-stats-analysis\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">stats.analysis</span></code><a class=\"headerlink\" href=\"#module-dipy.stats.analysis\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.AveragePointwiseEuclideanMetric\" title=\"dipy.stats.analysis.AveragePointwiseEuclideanMetric\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">AveragePointwiseEuclideanMetric</span></code></a></p></td>\n<td><p>Computes the average of pointwise Euclidean distances between two sequential data.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.QuickBundles\" title=\"dipy.stats.analysis.QuickBundles\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QuickBundles</span></code></a>(threshold[,\u00a0metric,\u00a0\u2026])</p></td>\n<td><p>Clusters streamlines using QuickBundles <a class=\"reference internal\" href=\"#r2bead99ec474-garyfallidis12\" id=\"id1\">[Garyfallidis12]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.Streamlines\" title=\"dipy.stats.analysis.Streamlines\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Streamlines</span></code></a></p></td>\n<td><p>alias of <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">nibabel.streamlines.array_sequence.ArraySequence</span></code></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree\" title=\"dipy.stats.analysis.cKDTree\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cKDTree</span></code></a>(data[,\u00a0leafsize,\u00a0compact_nodes,\u00a0\u2026])</p></td>\n<td><p>kd-tree for quick nearest-neighbor lookup</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.afq_profile\" title=\"dipy.stats.analysis.afq_profile\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">afq_profile</span></code></a>(data,\u00a0bundle,\u00a0affine[,\u00a0\u2026])</p></td>\n<td><p>Calculates a summarized profile of data for a bundle or tract along its length.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.anatomical_measures\" title=\"dipy.stats.analysis.anatomical_measures\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">anatomical_measures</span></code></a>(bundle,\u00a0metric,\u00a0dt,\u00a0\u2026)</p></td>\n<td><p>Calculates dti measure (eg: FA, MD) per point on streamlines and</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.assignment_map\" title=\"dipy.stats.analysis.assignment_map\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">assignment_map</span></code></a>(target_bundle,\u00a0model_bundle,\u00a0\u2026)</p></td>\n<td><p>Calculates assignment maps of the target bundle with reference to model bundle centroids.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.gaussian_weights\" title=\"dipy.stats.analysis.gaussian_weights\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gaussian_weights</span></code></a>(bundle[,\u00a0n_points,\u00a0\u2026])</p></td>\n<td><p>Calculate weights for each streamline/node in a bundle, based on a Mahalanobis distance from the core the bundle, at that node (mean, per default).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.mahalanobis\" title=\"dipy.stats.analysis.mahalanobis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mahalanobis</span></code></a>(u,\u00a0v,\u00a0VI)</p></td>\n<td><p>Compute the Mahalanobis distance between two 1-D arrays.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.map_coordinates\" title=\"dipy.stats.analysis.map_coordinates\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">map_coordinates</span></code></a>(input,\u00a0coordinates[,\u00a0\u2026])</p></td>\n<td><p>Map the input array to new coordinates by interpolation.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.optional_package\" title=\"dipy.stats.analysis.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.orient_by_streamline\" title=\"dipy.stats.analysis.orient_by_streamline\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">orient_by_streamline</span></code></a>(streamlines,\u00a0standard)</p></td>\n<td><p>Orient a bundle of streamlines to a standard streamline.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.peak_values\" title=\"dipy.stats.analysis.peak_values\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">peak_values</span></code></a>(bundle,\u00a0peaks,\u00a0dt,\u00a0pname,\u00a0bname,\u00a0\u2026)</p></td>\n<td><p>Peak_values function finds the generalized fractional anisotropy (gfa)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.save_buan_profiles_hdf5\" title=\"dipy.stats.analysis.save_buan_profiles_hdf5\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">save_buan_profiles_hdf5</span></code></a>(fname,\u00a0dt)</p></td>\n<td><p>Saves the given input dataframe to .h5 file</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.set_number_of_points\" title=\"dipy.stats.analysis.set_number_of_points\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">set_number_of_points</span></code></a></p></td>\n<td><p>Change the number of points of streamlines</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.transform_streamlines\" title=\"dipy.stats.analysis.transform_streamlines\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">transform_streamlines</span></code></a>(streamlines,\u00a0mat[,\u00a0\u2026])</p></td>\n<td><p>Apply affine transformation to streamlines</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.values_from_volume\" title=\"dipy.stats.analysis.values_from_volume\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">values_from_volume</span></code></a>(data,\u00a0streamlines,\u00a0affine)</p></td>\n<td><p>Extract values of a scalar/vector along each streamline from a volume.</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"averagepointwiseeuclideanmetric\">\n<h3><a class=\"reference internal\" href=\"#dipy.stats.analysis.AveragePointwiseEuclideanMetric\" title=\"dipy.stats.analysis.AveragePointwiseEuclideanMetric\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AveragePointwiseEuclideanMetric</span></code></a><a class=\"headerlink\" href=\"#averagepointwiseeuclideanmetric\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.stats.analysis.AveragePointwiseEuclideanMetric\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">AveragePointwiseEuclideanMetric</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.AveragePointwiseEuclideanMetric\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.segment.metricspeed.SumPointwiseEuclideanMetric</span></code></p>\n<p>Computes the average of pointwise Euclidean distances between two\nsequential data.</p>\n<p>A sequence of N-dimensional points is represented as a 2D array with\nshape (nb_points, nb_dimensions). A <cite>feature</cite> object can be specified\nin order to calculate the distance between the features, rather than\ndirectly between the sequential data.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>feature</strong><span class=\"classifier\"><cite>Feature</cite> object, optional</span></dt><dd><p>It is used to extract features before computing the distance.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The distance between two 2D sequential data:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">s1</span>       <span class=\"n\">s2</span>\n\n<span class=\"mi\">0</span><span class=\"o\">*</span>   <span class=\"n\">a</span>    <span class=\"o\">*</span><span class=\"mi\">0</span>\n  \\       <span class=\"o\">|</span>\n   \\      <span class=\"o\">|</span>\n   <span class=\"mi\">1</span><span class=\"o\">*</span>     <span class=\"o\">|</span>\n    <span class=\"o\">|</span>  <span class=\"n\">b</span>  <span class=\"o\">*</span><span class=\"mi\">1</span>\n    <span class=\"o\">|</span>      \\\n    <span class=\"mi\">2</span><span class=\"o\">*</span>      \\\n        <span class=\"n\">c</span>    <span class=\"o\">*</span><span class=\"mi\">2</span>\n</pre></div>\n</div>\n<p>is equal to <span class=\"math notranslate nohighlight\">\\((a+b+c)/3\\)</span> where <span class=\"math notranslate nohighlight\">\\(a\\)</span> is the Euclidean distance between s1[0] and\ns2[0], <span class=\"math notranslate nohighlight\">\\(b\\)</span> between s1[1] and s2[1] and <span class=\"math notranslate nohighlight\">\\(c\\)</span> between s1[2] and s2[2].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">feature</span></code></dt><dd><p><cite>Feature</cite> object used to extract features from sequential data</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">is_order_invariant</span></code></dt><dd><p>Is this metric invariant to the sequence\u2019s ordering</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">are_compatible</span></code></p></td>\n<td><p>Checks if features can be used by <cite>metric.dist</cite> based on their shape.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dist</span></code></p></td>\n<td><p>Computes a distance between two data points based on their features.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.AveragePointwiseEuclideanMetric.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.AveragePointwiseEuclideanMetric.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"quickbundles\">\n<h3><a class=\"reference internal\" href=\"#dipy.stats.analysis.QuickBundles\" title=\"dipy.stats.analysis.QuickBundles\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QuickBundles</span></code></a><a class=\"headerlink\" href=\"#quickbundles\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.stats.analysis.QuickBundles\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">QuickBundles</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">threshold</em>, <em class=\"sig-param\">metric='MDF_12points'</em>, <em class=\"sig-param\">max_nb_clusters=2147483647</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.QuickBundles\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"../dipy.segment/#dipy.segment.clustering.Clustering\" title=\"dipy.segment.clustering.Clustering\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.segment.clustering.Clustering</span></code></a></p>\n<p>Clusters streamlines using QuickBundles <a class=\"reference internal\" href=\"#r2bead99ec474-garyfallidis12\" id=\"id2\">[Garyfallidis12]</a>.</p>\n<p>Given a list of streamlines, the QuickBundles algorithm sequentially\nassigns each streamline to its closest bundle in <span class=\"math notranslate nohighlight\">\\(\\mathcal{O}(Nk)\\)</span> where\n<span class=\"math notranslate nohighlight\">\\(N\\)</span> is the number of streamlines and <span class=\"math notranslate nohighlight\">\\(k\\)</span> is the final number of bundles.\nIf for a given streamline its closest bundle is farther than <cite>threshold</cite>,\na new bundle is created and the streamline is assigned to it except if the\nnumber of bundles has already exceeded <cite>max_nb_clusters</cite>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>threshold</strong><span class=\"classifier\">float</span></dt><dd><p>The maximum distance from a bundle for a streamline to be still\nconsidered as part of it.</p>\n</dd>\n<dt><strong>metric</strong><span class=\"classifier\">str or <cite>Metric</cite> object (optional)</span></dt><dd><p>The distance metric to use when comparing two streamlines. By default,\nthe Minimum average Direct-Flip (MDF) distance <a class=\"reference internal\" href=\"#r2bead99ec474-garyfallidis12\" id=\"id3\">[Garyfallidis12]</a> is\nused and streamlines are automatically resampled so they have\n12 points.</p>\n</dd>\n<dt><strong>max_nb_clusters</strong><span class=\"classifier\">int</span></dt><dd><p>Limits the creation of bundles.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2bead99ec474-garyfallidis12\"><span class=\"brackets\">Garyfallidis12</span><span class=\"fn-backref\">(<a href=\"#id1\">1</a>,<a href=\"#id2\">2</a>,<a href=\"#id3\">3</a>)</span></dt>\n<dd><p>Garyfallidis E. et al., QuickBundles a method for\ntractography simplification, Frontiers in Neuroscience,\nvol 6, no 175, 2012.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.clustering</span> <span class=\"k\">import</span> <span class=\"n\">QuickBundles</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.io.streamline</span> <span class=\"k\">import</span> <span class=\"n\">load_tractogram</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">Streamlines</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;fornix&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fornix</span> <span class=\"o\">=</span> <span class=\"n\">load_tractogram</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;same&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                         <span class=\"n\">bbox_valid_check</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">streamlines</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"n\">Streamlines</span><span class=\"p\">(</span><span class=\"n\">fornix</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Segment fornix with a threshold of 10mm and streamlines resampled</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># to 12 points.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)</span>\n<span class=\"go\">4</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"go\">[61, 191, 47, 1]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Resampling streamlines differently is done explicitly as follows.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># Note this has an impact on the speed and the accuracy (tradeoff).</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">ResampleFeature</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.segment.metric</span> <span class=\"k\">import</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">feature</span> <span class=\"o\">=</span> <span class=\"n\">ResampleFeature</span><span class=\"p\">(</span><span class=\"n\">nb_points</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">metric</span> <span class=\"o\">=</span> <span class=\"n\">AveragePointwiseEuclideanMetric</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">qb</span> <span class=\"o\">=</span> <span class=\"n\">QuickBundles</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">metric</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">clusters</span> <span class=\"o\">=</span> <span class=\"n\">qb</span><span class=\"o\">.</span><span class=\"n\">cluster</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">clusters</span><span class=\"p\">)</span>\n<span class=\"go\">4</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">clusters</span><span class=\"p\">))</span>\n<span class=\"go\">[58, 142, 72, 28]</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.QuickBundles.cluster\" title=\"dipy.stats.analysis.QuickBundles.cluster\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cluster</span></code></a>(streamlines[,\u00a0ordering])</p></td>\n<td><p>Clusters <cite>streamlines</cite> into bundles.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.QuickBundles.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">threshold</em>, <em class=\"sig-param\">metric='MDF_12points'</em>, <em class=\"sig-param\">max_nb_clusters=2147483647</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.QuickBundles.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.QuickBundles.cluster\">\n<code class=\"sig-name descname\">cluster</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">streamlines</em>, <em class=\"sig-param\">ordering=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.QuickBundles.cluster\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clusters <cite>streamlines</cite> into bundles.</p>\n<p>Performs quickbundles algorithm using predefined metric and threshold.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>streamlines</strong><span class=\"classifier\">list of 2D arrays</span></dt><dd><p>Each 2D array represents a sequence of 3D points (points, 3).</p>\n</dd>\n<dt><strong>ordering</strong><span class=\"classifier\">iterable of indices</span></dt><dd><p>Specifies the order in which data points will be clustered.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><cite>ClusterMapCentroid</cite> object</dt><dd><p>Result of the clustering.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"streamlines\">\n<h3><a class=\"reference internal\" href=\"#dipy.stats.analysis.Streamlines\" title=\"dipy.stats.analysis.Streamlines\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Streamlines</span></code></a><a class=\"headerlink\" href=\"#streamlines\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.Streamlines\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">Streamlines</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.Streamlines\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>alias of <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">nibabel.streamlines.array_sequence.ArraySequence</span></code></p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ckdtree\">\n<h3><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree\" title=\"dipy.stats.analysis.cKDTree\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">cKDTree</span></code></a><a class=\"headerlink\" href=\"#ckdtree\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.stats.analysis.cKDTree\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">cKDTree</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">leafsize=16</em>, <em class=\"sig-param\">compact_nodes=True</em>, <em class=\"sig-param\">copy_data=False</em>, <em class=\"sig-param\">balanced_tree=True</em>, <em class=\"sig-param\">boxsize=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>kd-tree for quick nearest-neighbor lookup</p>\n<p>This class provides an index into a set of k-dimensional points\nwhich can be used to rapidly look up the nearest neighbors of any\npoint.</p>\n<p>The algorithm used is described in Maneewongvatana and Mount 1999.\nThe general idea is that the kd-tree is a binary trie, each of whose\nnodes represents an axis-aligned hyperrectangle. Each node specifies\nan axis and splits the set of points based on whether their coordinate\nalong that axis is greater than or less than a particular value.</p>\n<p>During construction, the axis and splitting point are chosen by the\n\u201csliding midpoint\u201d rule, which ensures that the cells do not all\nbecome long and thin.</p>\n<p>The tree can be queried for the r closest neighbors of any given point\n(optionally returning only those within some maximum distance of the\npoint). It can also be queried, with a substantial gain in efficiency,\nfor the r approximate closest neighbors.</p>\n<p>For large dimensions (20 is already large) do not expect this to run\nsignificantly faster than brute force. High-dimensional nearest-neighbor\nqueries are a substantial open problem in computer science.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array_like, shape (n,m)</span></dt><dd><p>The n data points of dimension m to be indexed. This array is\nnot copied unless this is necessary to produce a contiguous\narray of doubles, and so modifying this data will result in\nbogus results. The data are also copied if the kd-tree is built\nwith copy_data=True.</p>\n</dd>\n<dt><strong>leafsize</strong><span class=\"classifier\">positive int, optional</span></dt><dd><p>The number of points at which the algorithm switches over to\nbrute-force. Default: 16.</p>\n</dd>\n<dt><strong>compact_nodes</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, the kd-tree is built to shrink the hyperrectangles to\nthe actual data range. This usually gives a more compact tree that\nis robust against degenerated input data and gives faster queries\nat the expense of longer build time. Default: True.</p>\n</dd>\n<dt><strong>copy_data</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True the data is always copied to protect the kd-tree against\ndata corruption. Default: False.</p>\n</dd>\n<dt><strong>balanced_tree</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, the median is used to split the hyperrectangles instead of\nthe midpoint. This usually gives a more compact tree and\nfaster queries at the expense of longer build time. Default: True.</p>\n</dd>\n<dt><strong>boxsize</strong><span class=\"classifier\">array_like or scalar, optional</span></dt><dd><p>Apply a m-d toroidal topology to the KDTree.. The topology is generated\nby <span class=\"math notranslate nohighlight\">\\(x_i + n_i L_i\\)</span> where <span class=\"math notranslate nohighlight\">\\(n_i\\)</span> are integers and <span class=\"math notranslate nohighlight\">\\(L_i\\)</span>\nis the boxsize along i-th dimension. The input data shall be wrapped\ninto <span class=\"math notranslate nohighlight\">\\([0, L_i)\\)</span>. A ValueError is raised if any of the data is\noutside of this bound.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">KDTree</span></code></dt><dd><p>Implementation of <cite>cKDTree</cite> in pure Python</p>\n</dd>\n</dl>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray, shape (n,m)</span></dt><dd><p>The n data points of dimension m to be indexed. This array is\nnot copied unless this is necessary to produce a contiguous\narray of doubles. The data are also copied if the kd-tree is built\nwith <cite>copy_data=True</cite>.</p>\n</dd>\n<dt><strong>leafsize</strong><span class=\"classifier\">positive int</span></dt><dd><p>The number of points at which the algorithm switches over to\nbrute-force.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">int</span></dt><dd><p>The dimension of a single data-point.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int</span></dt><dd><p>The number of data points.</p>\n</dd>\n<dt><strong>maxes</strong><span class=\"classifier\">ndarray, shape (m,)</span></dt><dd><p>The maximum value in each dimension of the n data points.</p>\n</dd>\n<dt><strong>mins</strong><span class=\"classifier\">ndarray, shape (m,)</span></dt><dd><p>The minimum value in each dimension of the n data points.</p>\n</dd>\n<dt><strong>tree</strong><span class=\"classifier\">object, class cKDTreeNode</span></dt><dd><p>This attribute exposes a Python view of the root node in the cKDTree \nobject. A full Python view of the kd-tree is created dynamically \non the first access. This attribute allows you to create your own \nquery functions in Python.</p>\n</dd>\n<dt><strong>size</strong><span class=\"classifier\">int</span></dt><dd><p>The number of nodes in the tree.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.count_neighbors\" title=\"dipy.stats.analysis.cKDTree.count_neighbors\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">count_neighbors</span></code></a>(self,\u00a0other,\u00a0r[,\u00a0p,\u00a0\u2026])</p></td>\n<td><p>Count how many nearby pairs can be formed.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.query\" title=\"dipy.stats.analysis.cKDTree.query\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">query</span></code></a>(self,\u00a0x[,\u00a0k,\u00a0eps,\u00a0p,\u00a0\u2026])</p></td>\n<td><p>Query the kd-tree for nearest neighbors</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.query_ball_point\" title=\"dipy.stats.analysis.cKDTree.query_ball_point\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">query_ball_point</span></code></a>(self,\u00a0x,\u00a0r[,\u00a0p,\u00a0eps])</p></td>\n<td><p>Find all points within distance r of point(s) x.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.query_ball_tree\" title=\"dipy.stats.analysis.cKDTree.query_ball_tree\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">query_ball_tree</span></code></a>(self,\u00a0other,\u00a0r[,\u00a0p,\u00a0eps])</p></td>\n<td><p>Find all pairs of points whose distance is at most r</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.query_pairs\" title=\"dipy.stats.analysis.cKDTree.query_pairs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">query_pairs</span></code></a>(self,\u00a0r[,\u00a0p,\u00a0eps])</p></td>\n<td><p>Find all pairs of points whose distance is at most r.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.stats.analysis.cKDTree.sparse_distance_matrix\" title=\"dipy.stats.analysis.cKDTree.sparse_distance_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sparse_distance_matrix</span></code></a>(self,\u00a0other,\u00a0max_distance)</p></td>\n<td><p>Compute a sparse distance matrix</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.boxsize\">\n<code class=\"sig-name descname\">boxsize</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.boxsize\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.count_neighbors\">\n<code class=\"sig-name descname\">count_neighbors</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">other</em>, <em class=\"sig-param\">r</em>, <em class=\"sig-param\">p=2.</em>, <em class=\"sig-param\">weights=None</em>, <em class=\"sig-param\">cumulative=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.count_neighbors\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Count how many nearby pairs can be formed. (pair-counting)</p>\n<p>Count the number of pairs (x1,x2) can be formed, with x1 drawn\nfrom self and x2 drawn from <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code>, and where\n<code class=\"docutils literal notranslate\"><span class=\"pre\">distance(x1,</span> <span class=\"pre\">x2,</span> <span class=\"pre\">p)</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">r</span></code>.</p>\n<p>Data points on self and other are optionally weighted by the <code class=\"docutils literal notranslate\"><span class=\"pre\">weights</span></code>\nargument. (See below)</p>\n<p>The algorithm we implement here is based on <a class=\"reference internal\" href=\"#r6517d87a3955-1\" id=\"id5\">[1]</a>. See notes for further discussion.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>other</strong><span class=\"classifier\">cKDTree instance</span></dt><dd><p>The other tree to draw points from, can be the same tree as self.</p>\n</dd>\n<dt><strong>r</strong><span class=\"classifier\">float or one-dimensional array of floats</span></dt><dd><p>The radius to produce a count for. Multiple radii are searched with\na single tree traversal.\nIf the count is non-cumulative(<code class=\"docutils literal notranslate\"><span class=\"pre\">cumulative=False</span></code>), <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span></code> defines\nthe edges of the bins, and must be non-decreasing.</p>\n</dd>\n<dt><strong>p</strong><span class=\"classifier\">float, optional</span></dt><dd><p>1&lt;=p&lt;=infinity.\nWhich Minkowski p-norm to use.\nDefault 2.0.\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>weights</strong><span class=\"classifier\">tuple, array_like, or None, optional</span></dt><dd><p>If None, the pair-counting is unweighted.\nIf given as a tuple, weights[0] is the weights of points in <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code>, and\nweights[1] is the weights of points in <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code>; either can be None to\nindicate the points are unweighted.\nIf given as an array_like, weights is the weights of points in <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code>\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code>. For this to make sense, <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code> must be the\nsame tree. If <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">other</span></code> are two different trees, a <code class=\"docutils literal notranslate\"><span class=\"pre\">ValueError</span></code>\nis raised.\nDefault: None</p>\n</dd>\n<dt><strong>cumulative</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether the returned counts are cumulative. When cumulative is set to <code class=\"docutils literal notranslate\"><span class=\"pre\">False</span></code>\nthe algorithm is optimized to work with a large number of bins (&gt;10) specified\nby <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span></code>. When <code class=\"docutils literal notranslate\"><span class=\"pre\">cumulative</span></code> is set to True, the algorithm is optimized to work\nwith a small number of <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span></code>. Default: True</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">scalar or 1-D array</span></dt><dd><p>The number of pairs. For unweighted counts, the result is integer.\nFor weighted counts, the result is float.\nIf cumulative is False, <code class=\"docutils literal notranslate\"><span class=\"pre\">result[i]</span></code> contains the counts with\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(-inf</span> <span class=\"pre\">if</span> <span class=\"pre\">i</span> <span class=\"pre\">==</span> <span class=\"pre\">0</span> <span class=\"pre\">else</span> <span class=\"pre\">r[i-1])</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">R</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">r[i]</span></code></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Pair-counting is the basic operation used to calculate the two point\ncorrelation functions from a data set composed of position of objects.</p>\n<p>Two point correlation function measures the clustering of objects and\nis widely used in cosmology to quantify the large scale structure\nin our Universe, but it may be useful for data analysis in other fields\nwhere self-similar assembly of objects also occur.</p>\n<p>The Landy-Szalay estimator for the two point correlation function of\n<code class=\"docutils literal notranslate\"><span class=\"pre\">D</span></code> measures the clustering signal in <code class=\"docutils literal notranslate\"><span class=\"pre\">D</span></code>. <a class=\"reference internal\" href=\"#r6517d87a3955-2\" id=\"id6\">[2]</a></p>\n<p>For example, given the position of two sets of objects,</p>\n<ul class=\"simple\">\n<li><p>objects <code class=\"docutils literal notranslate\"><span class=\"pre\">D</span></code> (data) contains the clustering signal, and</p></li>\n<li><p>objects <code class=\"docutils literal notranslate\"><span class=\"pre\">R</span></code> (random) that contains no signal,</p></li>\n</ul>\n<div class=\"math notranslate nohighlight\">\n\\[\\xi(r) = \\frac{&lt;D, D&gt; - 2 f &lt;D, R&gt; + f^2&lt;R, R&gt;}{f^2&lt;R, R&gt;},\\]</div>\n<p>where the brackets represents counting pairs between two data sets\nin a finite bin around <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span></code> (distance), corresponding to setting\n<cite>cumulative=False</cite>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">f</span> <span class=\"pre\">=</span> <span class=\"pre\">float(len(D))</span> <span class=\"pre\">/</span> <span class=\"pre\">float(len(R))</span></code> is the\nratio between number of objects from data and random.</p>\n<p>The algorithm implemented here is loosely based on the dual-tree\nalgorithm described in <a class=\"reference internal\" href=\"#r6517d87a3955-1\" id=\"id7\">[1]</a>. We switch between two different\npair-cumulation scheme depending on the setting of <code class=\"docutils literal notranslate\"><span class=\"pre\">cumulative</span></code>.\nThe computing time of the method we use when for\n<code class=\"docutils literal notranslate\"><span class=\"pre\">cumulative</span> <span class=\"pre\">==</span> <span class=\"pre\">False</span></code> does not scale with the total number of bins.\nThe algorithm for <code class=\"docutils literal notranslate\"><span class=\"pre\">cumulative</span> <span class=\"pre\">==</span> <span class=\"pre\">True</span></code> scales linearly with the\nnumber of bins, though it is slightly faster when only\n1 or 2 bins are used. <a class=\"reference internal\" href=\"#r6517d87a3955-5\" id=\"id8\">[5]</a>.</p>\n<p>As an extension to the naive pair-counting,\nweighted pair-counting counts the product of weights instead\nof number of pairs.\nWeighted pair-counting is used to estimate marked correlation functions\n(<a class=\"reference internal\" href=\"#r6517d87a3955-3\" id=\"id9\">[3]</a>, section 2.2),\nor to properly calculate the average of data per distance bin\n(e.g. <a class=\"reference internal\" href=\"#r6517d87a3955-4\" id=\"id10\">[4]</a>, section 2.1 on redshift).</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6517d87a3955-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id5\">1</a>,<a href=\"#id7\">2</a>)</span></dt>\n<dd><p>Gray and Moore,\n\u201cN-body problems in statistical learning\u201d,\nMining the sky, 2000,\n<a class=\"reference external\" href=\"https://arxiv.org/abs/astro-ph/0012333\">https://arxiv.org/abs/astro-ph/0012333</a></p>\n</dd>\n<dt class=\"label\" id=\"r6517d87a3955-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id6\">2</a></span></dt>\n<dd><p>Landy and Szalay,\n\u201cBias and variance of angular correlation functions\u201d,\nThe Astrophysical Journal, 1993,\n<a class=\"reference external\" href=\"http://adsabs.harvard.edu/abs/1993ApJ...412...64L\">http://adsabs.harvard.edu/abs/1993ApJ\u2026412\u202664L</a></p>\n</dd>\n<dt class=\"label\" id=\"r6517d87a3955-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id9\">3</a></span></dt>\n<dd><p>Sheth, Connolly and Skibba,\n\u201cMarked correlations in galaxy formation models\u201d,\nArxiv e-print, 2005,\n<a class=\"reference external\" href=\"https://arxiv.org/abs/astro-ph/0511773\">https://arxiv.org/abs/astro-ph/0511773</a></p>\n</dd>\n<dt class=\"label\" id=\"r6517d87a3955-4\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id10\">4</a></span></dt>\n<dd><p>Hawkins, et al.,\n\u201cThe 2dF Galaxy Redshift Survey: correlation functions,\npeculiar velocities and the matter density of the Universe\u201d,\nMonthly Notices of the Royal Astronomical Society, 2002,\n<a class=\"reference external\" href=\"http://adsabs.harvard.edu/abs/2003MNRAS.346...78H\">http://adsabs.harvard.edu/abs/2003MNRAS.346\u202678H</a></p>\n</dd>\n<dt class=\"label\" id=\"r6517d87a3955-5\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id8\">5</a></span></dt>\n<dd><p><a class=\"reference external\" href=\"https://github.com/scipy/scipy/pull/5647#issuecomment-168474926\">https://github.com/scipy/scipy/pull/5647#issuecomment-168474926</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.data\">\n<code class=\"sig-name descname\">data</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.data\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.indices\">\n<code class=\"sig-name descname\">indices</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.indices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.leafsize\">\n<code class=\"sig-name descname\">leafsize</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.leafsize\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.m\">\n<code class=\"sig-name descname\">m</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.m\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.maxes\">\n<code class=\"sig-name descname\">maxes</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.maxes\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.mins\">\n<code class=\"sig-name descname\">mins</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.mins\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.n\">\n<code class=\"sig-name descname\">n</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.n\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.query\">\n<code class=\"sig-name descname\">query</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">x</em>, <em class=\"sig-param\">k=1</em>, <em class=\"sig-param\">eps=0</em>, <em class=\"sig-param\">p=2</em>, <em class=\"sig-param\">distance_upper_bound=np.inf</em>, <em class=\"sig-param\">n_jobs=1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.query\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Query the kd-tree for nearest neighbors</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like, last dimension self.m</span></dt><dd><p>An array of points to query.</p>\n</dd>\n<dt><strong>k</strong><span class=\"classifier\">list of integer or integer</span></dt><dd><p>The list of k-th nearest neighbors to return. If k is an\ninteger it is treated as a list of [1, \u2026 k] (range(1, k+1)).\nNote that the counting starts from 1.</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">non-negative float</span></dt><dd><p>Return approximate nearest neighbors; the k-th returned value\nis guaranteed to be no further than (1+eps) times the\ndistance to the real k-th nearest neighbor.</p>\n</dd>\n<dt><strong>p</strong><span class=\"classifier\">float, 1&lt;=p&lt;=infinity</span></dt><dd><p>Which Minkowski p-norm to use.\n1 is the sum-of-absolute-values \u201cManhattan\u201d distance\n2 is the usual Euclidean distance\ninfinity is the maximum-coordinate-difference distance\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>distance_upper_bound</strong><span class=\"classifier\">nonnegative float</span></dt><dd><p>Return only neighbors within this distance.  This is used to prune\ntree searches, so if you are doing a series of nearest-neighbor\nqueries, it may help to supply the distance to the nearest neighbor\nof the most recent point.</p>\n</dd>\n<dt><strong>n_jobs</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Number of jobs to schedule for parallel processing. If -1 is given\nall processors are used. Default: 1.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>d</strong><span class=\"classifier\">array of floats</span></dt><dd><p>The distances to the nearest neighbors.\nIf <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> has shape <code class=\"docutils literal notranslate\"><span class=\"pre\">tuple+(self.m,)</span></code>, then <code class=\"docutils literal notranslate\"><span class=\"pre\">d</span></code> has shape <code class=\"docutils literal notranslate\"><span class=\"pre\">tuple+(k,)</span></code>.\nWhen k == 1, the last dimension of the output is squeezed.\nMissing neighbors are indicated with infinite distances.</p>\n</dd>\n<dt><strong>i</strong><span class=\"classifier\">ndarray of ints</span></dt><dd><p>The locations of the neighbors in <code class=\"docutils literal notranslate\"><span class=\"pre\">self.data</span></code>.\nIf <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> has shape <code class=\"docutils literal notranslate\"><span class=\"pre\">tuple+(self.m,)</span></code>, then <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> has shape <code class=\"docutils literal notranslate\"><span class=\"pre\">tuple+(k,)</span></code>.\nWhen k == 1, the last dimension of the output is squeezed.\nMissing neighbors are indicated with <code class=\"docutils literal notranslate\"><span class=\"pre\">self.n</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>If the KD-Tree is periodic, the position <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> is wrapped into the\nbox.</p>\n<p>When the input k is a list, a query for arange(max(k)) is performed, but\nonly columns that store the requested values of k are preserved. This is\nimplemented in a manner that reduces memory usage.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.spatial</span> <span class=\"k\">import</span> <span class=\"n\">cKDTree</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">mgrid</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"mi\">8</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">cKDTree</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">c_</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">(),</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()])</span>\n</pre></div>\n</div>\n<p>To query the nearest neighbours and return squeezed result, use</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.1</span><span class=\"p\">,</span> <span class=\"mf\">2.9</span><span class=\"p\">]],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"go\">[2.         0.14142136] [ 0 13]</span>\n</pre></div>\n</div>\n<p>To query the nearest neighbours and return unsqueezed result, use</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.1</span><span class=\"p\">,</span> <span class=\"mf\">2.9</span><span class=\"p\">]],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"go\">[[2.        ]</span>\n<span class=\"go\"> [0.14142136]] [[ 0]</span>\n<span class=\"go\"> [13]]</span>\n</pre></div>\n</div>\n<p>To query the second nearest neighbours and return unsqueezed result, use</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.1</span><span class=\"p\">,</span> <span class=\"mf\">2.9</span><span class=\"p\">]],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"go\">[[2.23606798]</span>\n<span class=\"go\"> [0.90553851]] [[ 6]</span>\n<span class=\"go\"> [12]]</span>\n</pre></div>\n</div>\n<p>To query the first and second nearest neighbours, use</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.1</span><span class=\"p\">,</span> <span class=\"mf\">2.9</span><span class=\"p\">]],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"go\">[[2.         2.23606798]</span>\n<span class=\"go\"> [0.14142136 0.90553851]] [[ 0  6]</span>\n<span class=\"go\"> [13 12]]</span>\n</pre></div>\n</div>\n<p>or, be more specific</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.1</span><span class=\"p\">,</span> <span class=\"mf\">2.9</span><span class=\"p\">]],</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dd</span><span class=\"p\">,</span> <span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"go\">[[2.         2.23606798]</span>\n<span class=\"go\"> [0.14142136 0.90553851]] [[ 0  6]</span>\n<span class=\"go\"> [13 12]]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.query_ball_point\">\n<code class=\"sig-name descname\">query_ball_point</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">x</em>, <em class=\"sig-param\">r</em>, <em class=\"sig-param\">p=2.</em>, <em class=\"sig-param\">eps=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.query_ball_point\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find all points within distance r of point(s) x.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>x</strong><span class=\"classifier\">array_like, shape tuple + (self.m,)</span></dt><dd><p>The point or points to search for neighbors of.</p>\n</dd>\n<dt><strong>r</strong><span class=\"classifier\">array_like, float</span></dt><dd><p>The radius of points to return, shall broadcast to the length of x.</p>\n</dd>\n<dt><strong>p</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Which Minkowski p-norm to use.  Should be in the range [1, inf].\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">nonnegative float, optional</span></dt><dd><p>Approximate search. Branches of the tree are not explored if their\nnearest points are further than <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span> <span class=\"pre\">/</span> <span class=\"pre\">(1</span> <span class=\"pre\">+</span> <span class=\"pre\">eps)</span></code>, and branches are\nadded in bulk if their furthest points are nearer than\n<code class=\"docutils literal notranslate\"><span class=\"pre\">r</span> <span class=\"pre\">*</span> <span class=\"pre\">(1</span> <span class=\"pre\">+</span> <span class=\"pre\">eps)</span></code>.</p>\n</dd>\n<dt><strong>n_jobs</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Number of jobs to schedule for parallel processing. If -1 is given\nall processors are used. Default: 1.</p>\n</dd>\n<dt><strong>return_sorted</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Sorts returned indicies if True and does not sort them if False. If\nNone, does not sort single point queries, but does sort\nmulti-point queries which was the behavior before this option\nwas added.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.2.0.</span></p>\n</div>\n</dd>\n<dt><strong>return_length: bool, optional</strong></dt><dd><p>Return the number of points inside the radius instead of a list\nof the indices.\n.. versionadded:: 1.3.0</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>results</strong><span class=\"classifier\">list or array of lists</span></dt><dd><p>If <cite>x</cite> is a single point, returns a list of the indices of the\nneighbors of <cite>x</cite>. If <cite>x</cite> is an array of points, returns an object\narray of shape tuple containing lists of neighbors.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>If you have many points whose neighbors you want to find, you may save\nsubstantial amounts of time by putting them in a cKDTree and using\nquery_ball_tree.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">spatial</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">mgrid</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">4</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">points</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">c_</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">(),</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">spatial</span><span class=\"o\">.</span><span class=\"n\">cKDTree</span><span class=\"p\">(</span><span class=\"n\">points</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">query_ball_point</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">[4, 8, 9, 12]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.query_ball_tree\">\n<code class=\"sig-name descname\">query_ball_tree</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">other</em>, <em class=\"sig-param\">r</em>, <em class=\"sig-param\">p=2.</em>, <em class=\"sig-param\">eps=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.query_ball_tree\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find all pairs of points whose distance is at most r</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>other</strong><span class=\"classifier\">cKDTree instance</span></dt><dd><p>The tree containing points to search against.</p>\n</dd>\n<dt><strong>r</strong><span class=\"classifier\">float</span></dt><dd><p>The maximum distance, has to be positive.</p>\n</dd>\n<dt><strong>p</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Which Minkowski norm to use.  <cite>p</cite> has to meet the condition\n<code class=\"docutils literal notranslate\"><span class=\"pre\">1</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">p</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">infinity</span></code>.\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Approximate search.  Branches of the tree are not explored\nif their nearest points are further than <code class=\"docutils literal notranslate\"><span class=\"pre\">r/(1+eps)</span></code>, and\nbranches are added in bulk if their furthest points are nearer\nthan <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span> <span class=\"pre\">*</span> <span class=\"pre\">(1+eps)</span></code>.  <cite>eps</cite> has to be non-negative.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>results</strong><span class=\"classifier\">list of lists</span></dt><dd><p>For each element <code class=\"docutils literal notranslate\"><span class=\"pre\">self.data[i]</span></code> of this tree, <code class=\"docutils literal notranslate\"><span class=\"pre\">results[i]</span></code> is a\nlist of the indices of its neighbors in <code class=\"docutils literal notranslate\"><span class=\"pre\">other.data</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.query_pairs\">\n<code class=\"sig-name descname\">query_pairs</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">r</em>, <em class=\"sig-param\">p=2.</em>, <em class=\"sig-param\">eps=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.query_pairs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find all pairs of points whose distance is at most r.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">positive float</span></dt><dd><p>The maximum distance.</p>\n</dd>\n<dt><strong>p</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Which Minkowski norm to use.  <code class=\"docutils literal notranslate\"><span class=\"pre\">p</span></code> has to meet the condition\n<code class=\"docutils literal notranslate\"><span class=\"pre\">1</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">p</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">infinity</span></code>.\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Approximate search.  Branches of the tree are not explored\nif their nearest points are further than <code class=\"docutils literal notranslate\"><span class=\"pre\">r/(1+eps)</span></code>, and\nbranches are added in bulk if their furthest points are nearer\nthan <code class=\"docutils literal notranslate\"><span class=\"pre\">r</span> <span class=\"pre\">*</span> <span class=\"pre\">(1+eps)</span></code>.  <cite>eps</cite> has to be non-negative.</p>\n</dd>\n<dt><strong>output_type</strong><span class=\"classifier\">string, optional</span></dt><dd><p>Choose the output container, \u2018set\u2019 or \u2018ndarray\u2019. Default: \u2018set\u2019</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>results</strong><span class=\"classifier\">set or ndarray</span></dt><dd><p>Set of pairs <code class=\"docutils literal notranslate\"><span class=\"pre\">(i,j)</span></code>, with <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">j</span></code>, for which the corresponding\npositions are close. If output_type is \u2018ndarray\u2019, an ndarry is\nreturned instead of a set.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.size\">\n<code class=\"sig-name descname\">size</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.size\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.stats.analysis.cKDTree.sparse_distance_matrix\">\n<code class=\"sig-name descname\">sparse_distance_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">other</em>, <em class=\"sig-param\">max_distance</em>, <em class=\"sig-param\">p=2.</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.sparse_distance_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute a sparse distance matrix</p>\n<p>Computes a distance matrix between two cKDTrees, leaving as zero\nany distance greater than max_distance.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>other</strong><span class=\"classifier\">cKDTree</span></dt><dd></dd>\n<dt><strong>max_distance</strong><span class=\"classifier\">positive float</span></dt><dd></dd>\n<dt><strong>p</strong><span class=\"classifier\">float, 1&lt;=p&lt;=infinity</span></dt><dd><p>Which Minkowski p-norm to use.\nA finite large p may cause a ValueError if overflow can occur.</p>\n</dd>\n<dt><strong>output_type</strong><span class=\"classifier\">string, optional</span></dt><dd><p>Which container to use for output data. Options: \u2018dok_matrix\u2019,\n\u2018coo_matrix\u2019, \u2018dict\u2019, or \u2018ndarray\u2019. Default: \u2018dok_matrix\u2019.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">dok_matrix, coo_matrix, dict or ndarray</span></dt><dd><p>Sparse matrix representing the results in \u201cdictionary of keys\u201d\nformat. If a dict is returned the keys are (i,j) tuples of indices.\nIf output_type is \u2018ndarray\u2019 a record array with fields \u2018i\u2019, \u2018j\u2019,\nand \u2018v\u2019 is returned,</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.stats.analysis.cKDTree.tree\">\n<code class=\"sig-name descname\">tree</code><a class=\"headerlink\" href=\"#dipy.stats.analysis.cKDTree.tree\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"afq-profile\">\n<h3>afq_profile<a class=\"headerlink\" href=\"#afq-profile\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.afq_profile\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">afq_profile</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">bundle</em>, <em class=\"sig-param\">affine</em>, <em class=\"sig-param\">n_points=100</em>, <em class=\"sig-param\">orient_by=None</em>, <em class=\"sig-param\">weights=None</em>, <em class=\"sig-param\">**weights_kwarg</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.afq_profile\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates a summarized profile of data for a bundle or tract\nalong its length.</p>\n<p>Follows the approach outlined in <a class=\"reference internal\" href=\"#r59d3e2f0a60f-yeatman2012\" id=\"id11\">[Yeatman2012]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">3D volume</span></dt><dd><p>The statistic to sample with the streamlines.</p>\n</dd>\n<dt><strong>bundle</strong><span class=\"classifier\">StreamLines class instance</span></dt><dd><dl class=\"simple\">\n<dt>The collection of streamlines (possibly already resampled into an array</dt><dd><p>for each to have the same length) with which we are resampling. See\nNote below about orienting the streamlines.</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>affine</strong><span class=\"classifier\">array_like (4, 4)</span></dt><dd><p>The mapping from voxel coordinates to streamline points.\nThe voxel_to_rasmm matrix, typically from a NIFTI file.</p>\n</dd>\n<dt><strong>n_points: int, optional</strong></dt><dd><p>The number of points to sample along the bundle. Default: 100.</p>\n</dd>\n<dt><strong>orient_by: streamline, optional.</strong></dt><dd><p>A streamline to use as a standard to orient all of the streamlines in\nthe bundle according to.</p>\n</dd>\n<dt><strong>weights</strong><span class=\"classifier\">1D array or 2D array or callable (optional)</span></dt><dd><p>Weight each streamline (1D) or each node (2D) when calculating the\ntract-profiles. Must sum to 1 across streamlines (in each node if\nrelevant). If callable, this is a function that calculates weights.</p>\n</dd>\n<dt><strong>weights_kwarg</strong><span class=\"classifier\">key-word arguments</span></dt><dd><p>Additional key-word arguments to pass to the weight-calculating\nfunction. Only to be used if weights is a callable.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>ndarray</strong><span class=\"classifier\">a 1D array with the profile of <cite>data</cite> along the length of</span></dt><dd><p><cite>bundle</cite></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Before providing a bundle as input to this function, you will need to make\nsure that the streamlines in the bundle are all oriented in the same\norientation relative to the bundle (use <a class=\"reference internal\" href=\"#dipy.stats.analysis.orient_by_streamline\" title=\"dipy.stats.analysis.orient_by_streamline\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">orient_by_streamline()</span></code></a>).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r59d3e2f0a60f-yeatman2012\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id11\">Yeatman2012</a></span></dt>\n<dd><p>Yeatman, Jason D., Robert F. Dougherty,\nNathaniel J. Myall, Brian A. Wandell, and Heidi M. Feldman. 2012.\n\u201cTract Profiles of White Matter Properties: Automating Fiber-Tract\nQuantification\u201d PloS One 7 (11): e49790.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"anatomical-measures\">\n<h3>anatomical_measures<a class=\"headerlink\" href=\"#anatomical-measures\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.anatomical_measures\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">anatomical_measures</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bundle</em>, <em class=\"sig-param\">metric</em>, <em class=\"sig-param\">dt</em>, <em class=\"sig-param\">pname</em>, <em class=\"sig-param\">bname</em>, <em class=\"sig-param\">subject</em>, <em class=\"sig-param\">group_id</em>, <em class=\"sig-param\">ind</em>, <em class=\"sig-param\">dir</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.anatomical_measures\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Calculates dti measure (eg: FA, MD) per point on streamlines and</dt><dd><p>save it in hd5 file.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bundle</strong><span class=\"classifier\">string</span></dt><dd><p>Name of bundle being analyzed</p>\n</dd>\n<dt><strong>metric</strong><span class=\"classifier\">matrix of float values</span></dt><dd><p>dti metric e.g. FA, MD</p>\n</dd>\n<dt><strong>dt</strong><span class=\"classifier\">DataFrame</span></dt><dd><p>DataFrame to be populated</p>\n</dd>\n<dt><strong>pname</strong><span class=\"classifier\">string</span></dt><dd><p>Name of the dti metric</p>\n</dd>\n<dt><strong>bname</strong><span class=\"classifier\">string</span></dt><dd><p>Name of bundle being analyzed.</p>\n</dd>\n<dt><strong>subject</strong><span class=\"classifier\">string</span></dt><dd><p>subject number as a string (e.g. 10001)</p>\n</dd>\n<dt><strong>group_id</strong><span class=\"classifier\">integer</span></dt><dd><p>which group subject belongs to 1 for patient and 0 control</p>\n</dd>\n<dt><strong>ind</strong><span class=\"classifier\">integer list</span></dt><dd><p>ind tells which disk number a point belong.</p>\n</dd>\n<dt><strong>dir</strong><span class=\"classifier\">string</span></dt><dd><p>path of output directory</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"assignment-map\">\n<h3>assignment_map<a class=\"headerlink\" href=\"#assignment-map\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.assignment_map\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">assignment_map</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">target_bundle</em>, <em class=\"sig-param\">model_bundle</em>, <em class=\"sig-param\">no_disks</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.assignment_map\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates assignment maps of the target bundle with reference to\nmodel bundle centroids.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>target_bundle</strong><span class=\"classifier\">streamlines</span></dt><dd><p>target bundle extracted from subject data in common space</p>\n</dd>\n<dt><strong>model_bundle</strong><span class=\"classifier\">streamlines</span></dt><dd><p>atlas bundle used as reference</p>\n</dd>\n<dt><strong>no_disks</strong><span class=\"classifier\">integer, optional</span></dt><dd><p>Number of disks used for dividing bundle into disks. (Default 100)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8bc623e4d73a-chandio2020\"><span class=\"brackets\">Chandio2020</span></dt>\n<dd><p>Chandio, B.Q., Risacher, S.L., Pestilli, F., Bullock, D.,</p>\n</dd>\n</dl>\n<p>Yeh, FC., Koudoro, S., Rokem, A., Harezlack, J., and Garyfallidis, E.\nBundle analytics, a computational framework for investigating the\nshapes and profiles of brain pathways across populations.\nSci Rep 10, 17149 (2020)</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gaussian-weights\">\n<h3>gaussian_weights<a class=\"headerlink\" href=\"#gaussian-weights\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.gaussian_weights\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">gaussian_weights</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bundle</em>, <em class=\"sig-param\">n_points=100</em>, <em class=\"sig-param\">return_mahalnobis=False</em>, <em class=\"sig-param\">stat=&lt;function mean&gt;</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.gaussian_weights\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate weights for each streamline/node in a bundle, based on a\nMahalanobis distance from the core the bundle, at that node (mean, per\ndefault).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bundle</strong><span class=\"classifier\">Streamlines</span></dt><dd><p>The streamlines to weight.</p>\n</dd>\n<dt><strong>n_points</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The number of points to resample to. <em>If the `bundle` is an array, this\ninput is ignored</em>. Default: 100.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>w</strong><span class=\"classifier\">array of shape (n_streamlines, n_points)</span></dt><dd><p>Weights for each node in each streamline, calculated as its relative\ninverse of the Mahalanobis distance, relative to the distribution of\ncoordinates at that node position across streamlines.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mahalanobis\">\n<h3>mahalanobis<a class=\"headerlink\" href=\"#mahalanobis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.mahalanobis\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">mahalanobis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">u</em>, <em class=\"sig-param\">v</em>, <em class=\"sig-param\">VI</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.mahalanobis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the Mahalanobis distance between two 1-D arrays.</p>\n<p>The Mahalanobis distance between 1-D arrays <cite>u</cite> and <cite>v</cite>, is defined as</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\sqrt{ (u-v) V^{-1} (u-v)^T }\\]</div>\n<p>where <code class=\"docutils literal notranslate\"><span class=\"pre\">V</span></code> is the covariance matrix.  Note that the argument <cite>VI</cite>\nis the inverse of <code class=\"docutils literal notranslate\"><span class=\"pre\">V</span></code>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>u</strong><span class=\"classifier\">(N,) array_like</span></dt><dd><p>Input array.</p>\n</dd>\n<dt><strong>v</strong><span class=\"classifier\">(N,) array_like</span></dt><dd><p>Input array.</p>\n</dd>\n<dt><strong>VI</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The inverse of the covariance matrix.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mahalanobis</strong><span class=\"classifier\">double</span></dt><dd><p>The Mahalanobis distance between vectors <cite>u</cite> and <cite>v</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.spatial</span> <span class=\"k\">import</span> <span class=\"n\">distance</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">iv</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">distance</span><span class=\"o\">.</span><span class=\"n\">mahalanobis</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">iv</span><span class=\"p\">)</span>\n<span class=\"go\">1.0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">distance</span><span class=\"o\">.</span><span class=\"n\">mahalanobis</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">iv</span><span class=\"p\">)</span>\n<span class=\"go\">1.0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">distance</span><span class=\"o\">.</span><span class=\"n\">mahalanobis</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">iv</span><span class=\"p\">)</span>\n<span class=\"go\">1.7320508075688772</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"map-coordinates\">\n<h3>map_coordinates<a class=\"headerlink\" href=\"#map-coordinates\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.map_coordinates\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">map_coordinates</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">input</em>, <em class=\"sig-param\">coordinates</em>, <em class=\"sig-param\">output=None</em>, <em class=\"sig-param\">order=3</em>, <em class=\"sig-param\">mode='constant'</em>, <em class=\"sig-param\">cval=0.0</em>, <em class=\"sig-param\">prefilter=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.map_coordinates\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Map the input array to new coordinates by interpolation.</p>\n<p>The array of coordinates is used to find, for each point in the output,\nthe corresponding coordinates in the input. The value of the input at\nthose coordinates is determined by spline interpolation of the\nrequested order.</p>\n<p>The shape of the output is derived from that of the coordinate\narray by dropping the first axis. The values of the array along\nthe first axis are the coordinates in the input array at which the\noutput value is found.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>input</strong><span class=\"classifier\">array_like</span></dt><dd><p>The input array.</p>\n</dd>\n<dt><strong>coordinates</strong><span class=\"classifier\">array_like</span></dt><dd><p>The coordinates at which <cite>input</cite> is evaluated.</p>\n</dd>\n<dt><strong>output</strong><span class=\"classifier\">array or dtype, optional</span></dt><dd><p>The array in which to place the output, or the dtype of the\nreturned array. By default an array of the same dtype as input\nwill be created.</p>\n</dd>\n<dt><strong>order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 3.\nThe order has to be in the range 0-5.</p>\n</dd>\n<dt><strong>mode</strong><span class=\"classifier\">{\u2018reflect\u2019, \u2018constant\u2019, \u2018nearest\u2019, \u2018mirror\u2019, \u2018wrap\u2019}, optional</span></dt><dd><p>The <cite>mode</cite> parameter determines how the input array is extended\nbeyond its boundaries. Default is \u2018constant\u2019. Behavior for each valid\nvalue is as follows:</p>\n<dl class=\"simple\">\n<dt>\u2018reflect\u2019 (<cite>d c b a | a b c d | d c b a</cite>)</dt><dd><p>The input is extended by reflecting about the edge of the last\npixel.</p>\n</dd>\n<dt>\u2018constant\u2019 (<cite>k k k k | a b c d | k k k k</cite>)</dt><dd><p>The input is extended by filling all values beyond the edge with\nthe same constant value, defined by the <cite>cval</cite> parameter.</p>\n</dd>\n<dt>\u2018nearest\u2019 (<cite>a a a a | a b c d | d d d d</cite>)</dt><dd><p>The input is extended by replicating the last pixel.</p>\n</dd>\n<dt>\u2018mirror\u2019 (<cite>d c b | a b c d | c b a</cite>)</dt><dd><p>The input is extended by reflecting about the center of the last\npixel.</p>\n</dd>\n<dt>\u2018wrap\u2019 (<cite>a b c d | a b c d | a b c d</cite>)</dt><dd><p>The input is extended by wrapping around to the opposite edge.</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>cval</strong><span class=\"classifier\">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is \u2018constant\u2019. Default\nis 0.0.</p>\n</dd>\n<dt><strong>prefilter</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Determines if the input array is prefiltered with <cite>spline_filter</cite>\nbefore interpolation. The default is True, which will create a\ntemporary <cite>float64</cite> array of filtered values if <cite>order &gt; 1</cite>. If\nsetting this to False, the output will be slightly blurred if\n<cite>order &gt; 1</cite>, unless the input is prefiltered, i.e. it is the result\nof calling <cite>spline_filter</cite> on the original input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>map_coordinates</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The result of transforming the input. The shape of the output is\nderived from that of <cite>coordinates</cite> by dropping the first axis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">spline_filter</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">geometric_transform</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.interpolate</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">ndimage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mf\">12.</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span>\n<span class=\"go\">array([[  0.,   1.,   2.],</span>\n<span class=\"go\">       [  3.,   4.,   5.],</span>\n<span class=\"go\">       [  6.,   7.,   8.],</span>\n<span class=\"go\">       [  9.,  10.,  11.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"p\">[[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]],</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 2.,  7.])</span>\n</pre></div>\n</div>\n<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while\na[2, 1] is output[1].</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">inds</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=-</span><span class=\"mf\">33.3</span><span class=\"p\">)</span>\n<span class=\"go\">array([  2. , -33.3])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 2.,  8.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"nb\">bool</span><span class=\"p\">)</span>\n<span class=\"go\">array([ True, False], dtype=bool)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"optional-package\">\n<h3>optional_package<a class=\"headerlink\" href=\"#optional-package\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"orient-by-streamline\">\n<h3>orient_by_streamline<a class=\"headerlink\" href=\"#orient-by-streamline\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.orient_by_streamline\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">orient_by_streamline</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">streamlines</em>, <em class=\"sig-param\">standard</em>, <em class=\"sig-param\">n_points=12</em>, <em class=\"sig-param\">in_place=False</em>, <em class=\"sig-param\">as_generator=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.orient_by_streamline\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Orient a bundle of streamlines to a standard streamline.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>streamlines</strong><span class=\"classifier\">Streamlines, list</span></dt><dd><p>The input streamlines to orient.</p>\n</dd>\n<dt><strong>standard</strong><span class=\"classifier\">Streamlines, list, or ndarrray</span></dt><dd><p>This provides the standard orientation according to which the\nstreamlines in the provided bundle should be reoriented.</p>\n</dd>\n<dt><strong>n_points: int, optional</strong></dt><dd><p>The number of samples to apply to each of the streamlines.</p>\n</dd>\n<dt><strong>in_place</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to make the change in-place in the original input\n(and return a reference), or to make a copy of the list\nand return this copy, with the relevant streamlines reoriented.\nDefault: False.</p>\n</dd>\n<dt><strong>as_generator</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to return a generator as output. Default: False</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>Streamlines</strong><span class=\"classifier\">with each individual array oriented to be as similar as</span></dt><dd><p>possible to the standard.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"peak-values\">\n<h3>peak_values<a class=\"headerlink\" href=\"#peak-values\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.peak_values\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">peak_values</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bundle</em>, <em class=\"sig-param\">peaks</em>, <em class=\"sig-param\">dt</em>, <em class=\"sig-param\">pname</em>, <em class=\"sig-param\">bname</em>, <em class=\"sig-param\">subject</em>, <em class=\"sig-param\">group_id</em>, <em class=\"sig-param\">ind</em>, <em class=\"sig-param\">dir</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.peak_values\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Peak_values function finds the generalized fractional anisotropy (gfa)</dt><dd><p>and quantitative anisotropy (qa) values from peaks object (eg: csa) for\nevery point on a streamline used while tracking and saves it in hd5\nfile.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bundle</strong><span class=\"classifier\">string</span></dt><dd><p>Name of bundle being analyzed</p>\n</dd>\n<dt><strong>peaks</strong><span class=\"classifier\">peaks</span></dt><dd><p>contains peak directions and values</p>\n</dd>\n<dt><strong>dt</strong><span class=\"classifier\">DataFrame</span></dt><dd><p>DataFrame to be populated</p>\n</dd>\n<dt><strong>pname</strong><span class=\"classifier\">string</span></dt><dd><p>Name of the dti metric</p>\n</dd>\n<dt><strong>bname</strong><span class=\"classifier\">string</span></dt><dd><p>Name of bundle being analyzed.</p>\n</dd>\n<dt><strong>subject</strong><span class=\"classifier\">string</span></dt><dd><p>subject number as a string (e.g. 10001)</p>\n</dd>\n<dt><strong>group_id</strong><span class=\"classifier\">integer</span></dt><dd><p>which group subject belongs to 1 patient and 0 for control</p>\n</dd>\n<dt><strong>ind</strong><span class=\"classifier\">integer list</span></dt><dd><p>ind tells which disk number a point belong.</p>\n</dd>\n<dt><strong>dir</strong><span class=\"classifier\">string</span></dt><dd><p>path of output directory</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"save-buan-profiles-hdf5\">\n<h3>save_buan_profiles_hdf5<a class=\"headerlink\" href=\"#save-buan-profiles-hdf5\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.save_buan_profiles_hdf5\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">save_buan_profiles_hdf5</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fname</em>, <em class=\"sig-param\">dt</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.save_buan_profiles_hdf5\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Saves the given input dataframe to .h5 file</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fname</strong><span class=\"classifier\">string</span></dt><dd><p>file name for saving the hdf5 file</p>\n</dd>\n<dt><strong>dt</strong><span class=\"classifier\">Pandas DataFrame</span></dt><dd><p>DataFrame to be saved as .h5 file</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"set-number-of-points\">\n<h3>set_number_of_points<a class=\"headerlink\" href=\"#set-number-of-points\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.set_number_of_points\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">set_number_of_points</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.set_number_of_points\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Change the number of points of streamlines</dt><dd><p>(either by downsampling or upsampling)</p>\n</dd>\n</dl>\n<p>Change the number of points of streamlines in order to obtain\n<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be\nmodified along the curve.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>streamlines</strong><span class=\"classifier\">ndarray or a list or <a class=\"reference internal\" href=\"../dipy.tracking/#dipy.tracking.Streamlines\" title=\"dipy.tracking.Streamlines\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points\nof the streamline.\nIf list, each item must be ndarray shape (Ni,3) where Ni is the number\nof points of streamline i.\nIf <a class=\"reference internal\" href=\"../dipy.tracking/#dipy.tracking.Streamlines\" title=\"dipy.tracking.Streamlines\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>\n</dd>\n<dt><strong>nb_points</strong><span class=\"classifier\">int</span></dt><dd><p>integer representing number of points wanted along the curve.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>new_streamlines</strong><span class=\"classifier\">ndarray or a list or <a class=\"reference internal\" href=\"../dipy.tracking/#dipy.tracking.Streamlines\" title=\"dipy.tracking.Streamlines\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>Results of the downsampling or upsampling process.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.tracking.streamline</span> <span class=\"k\">import</span> <span class=\"n\">set_number_of_points</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n</pre></div>\n</div>\n<p>One streamline, a semi-circle:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"o\">*</span> <span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">streamline</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">vstack</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">T</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">modified_streamline</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamline</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">modified_streamline</span><span class=\"p\">)</span>\n<span class=\"go\">3</span>\n</pre></div>\n</div>\n<p>Multiple streamlines:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">streamlines</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">streamline</span><span class=\"p\">,</span> <span class=\"n\">streamline</span><span class=\"p\">[::</span><span class=\"mi\">2</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">new_streamlines</span> <span class=\"o\">=</span> <span class=\"n\">set_number_of_points</span><span class=\"p\">(</span><span class=\"n\">streamlines</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"n\">streamlines</span><span class=\"p\">]</span>\n<span class=\"go\">[100, 50]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"n\">new_streamlines</span><span class=\"p\">]</span>\n<span class=\"go\">[10, 10]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"transform-streamlines\">\n<h3>transform_streamlines<a class=\"headerlink\" href=\"#transform-streamlines\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.transform_streamlines\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">transform_streamlines</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">streamlines</em>, <em class=\"sig-param\">mat</em>, <em class=\"sig-param\">in_place=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.transform_streamlines\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Apply affine transformation to streamlines</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>streamlines</strong><span class=\"classifier\">Streamlines</span></dt><dd><p>Streamlines object</p>\n</dd>\n<dt><strong>mat</strong><span class=\"classifier\">array, (4, 4)</span></dt><dd><p>transformation matrix</p>\n</dd>\n<dt><strong>in_place</strong><span class=\"classifier\">bool</span></dt><dd><p>If True then change data in place.\nBe careful changes input streamlines.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>new_streamlines</strong><span class=\"classifier\">Streamlines</span></dt><dd><p>Sequence transformed 2D ndarrays of shape[-1]==3</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"values-from-volume\">\n<h3>values_from_volume<a class=\"headerlink\" href=\"#values-from-volume\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.stats.analysis.values_from_volume\">\n<code class=\"sig-prename descclassname\">dipy.stats.analysis.</code><code class=\"sig-name descname\">values_from_volume</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">streamlines</em>, <em class=\"sig-param\">affine</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.stats.analysis.values_from_volume\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Extract values of a scalar/vector along each streamline from a volume.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">3D or 4D array</span></dt><dd><p>Scalar (for 3D) and vector (for 4D) values to be extracted. For 4D\ndata, interpolation will be done on the 3 spatial dimensions in each\nvolume.</p>\n</dd>\n<dt><strong>streamlines</strong><span class=\"classifier\">ndarray or list</span></dt><dd><p>If array, of shape (n_streamlines, n_nodes, 3)\nIf list, len(n_streamlines) with (n_nodes, 3) array in\neach element of the list.</p>\n</dd>\n<dt><strong>affine</strong><span class=\"classifier\">array_like (4, 4)</span></dt><dd><p>The mapping from voxel coordinates to streamline points.\nThe voxel_to_rasmm matrix, typically from a NIFTI file.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>array or list (depending on the input)</strong><span class=\"classifier\">values interpolate to each</span></dt><dd><p>coordinate along the length of each streamline.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Values are extracted from the image based on the 3D coordinates of the\nnodes that comprise the points in the streamline, without any interpolation\ninto segments between the nodes. Using this function with streamlines that\nhave been resampled into a very small number of nodes will result in very\nfew values.</p>\n</dd></dl>\n\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["reference/dipy.tracking", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">tracking</span></code>", "N", "next"], ["reference/dipy.sims", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">sims</span></code>", "P", "previous"]], "sourcename": "reference/dipy.stats.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">stats</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#module-dipy.stats.analysis\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">stats.analysis</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#averagepointwiseeuclideanmetric\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AveragePointwiseEuclideanMetric</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#quickbundles\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QuickBundles</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#streamlines\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Streamlines</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#ckdtree\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">cKDTree</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#afq-profile\">afq_profile</a></li>\n<li><a class=\"reference internal\" href=\"#anatomical-measures\">anatomical_measures</a></li>\n<li><a class=\"reference internal\" href=\"#assignment-map\">assignment_map</a></li>\n<li><a class=\"reference internal\" href=\"#gaussian-weights\">gaussian_weights</a></li>\n<li><a class=\"reference internal\" href=\"#mahalanobis\">mahalanobis</a></li>\n<li><a class=\"reference internal\" href=\"#map-coordinates\">map_coordinates</a></li>\n<li><a class=\"reference internal\" href=\"#optional-package\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#orient-by-streamline\">orient_by_streamline</a></li>\n<li><a class=\"reference internal\" href=\"#peak-values\">peak_values</a></li>\n<li><a class=\"reference internal\" href=\"#save-buan-profiles-hdf5\">save_buan_profiles_hdf5</a></li>\n<li><a class=\"reference internal\" href=\"#set-number-of-points\">set_number_of_points</a></li>\n<li><a class=\"reference internal\" href=\"#transform-streamlines\">transform_streamlines</a></li>\n<li><a class=\"reference internal\" href=\"#values-from-volume\">values_from_volume</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "reference/dipy.stats", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}