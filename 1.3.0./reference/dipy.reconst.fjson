{"parents": [{"link": "../../documentation/", "title": "Documentation"}, {"link": "../", "title": "API Reference"}], "prev": {"link": "../dipy.nn/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">nn</span></code>"}, "next": {"link": "../dipy.segment/", "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">segment</span></code>"}, "title": "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst</span></code>", "meta": {}, "body": "<div class=\"section\" id=\"module-dipy.reconst\">\n<span id=\"reconst\"></span><h1><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.bench\" title=\"dipy.reconst.bench\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench</span></code></a>([label,\u00a0verbose,\u00a0extra_argv])</p></td>\n<td><p>Run benchmarks for module using nose.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.test\" title=\"dipy.reconst.test\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">test</span></code></a>([label,\u00a0verbose,\u00a0extra_argv,\u00a0doctests,\u00a0\u2026])</p></td>\n<td><p>Run tests for module using nose.</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"module-dipy.reconst.base\">\n<span id=\"module-reconst-base\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.base</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.base\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Base-classes for reconstruction models and reconstruction fits.</p>\n<p>All the models in the reconst module follow the same template: a Model object\nis used to represent the abstract properties of the model, that are independent\nof the specifics of the data . These properties are reused whenver fitting a\nparticular set of data (different voxels, for example).</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p>Abstract class which holds the fit result of ReconstModel</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks\">\n<span id=\"module-reconst-benchmarks\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks.bench_bounding_box\">\n<span id=\"module-reconst-benchmarks-bench-bounding-box\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_bounding_box</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks.bench_bounding_box\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Benchmarks for bounding_box</p>\n<p>Run all benchmarks with:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">dipy.reconst</span> <span class=\"k\">as</span> <span class=\"nn\">dire</span>\n<span class=\"n\">dire</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>With Pytest, Run this benchmark with:</p>\n<blockquote>\n<div><p>pytest -svv -c bench.ini /path/to/bench_bounding_box.py</p>\n</div></blockquote>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box\" title=\"dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench_bounding_box</span></code></a>()</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.bounding_box\" title=\"dipy.reconst.benchmarks.bench_bounding_box.bounding_box\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bounding_box</span></code></a>(vol)</p></td>\n<td><p>Compute the bounding box of nonzero intensity voxels in the volume.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.measure\" title=\"dipy.reconst.benchmarks.bench_bounding_box.measure\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">measure</span></code></a>(code_str[,\u00a0times,\u00a0label])</p></td>\n<td><p>Return elapsed time for executing code in the namespace of the caller.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks.bench_csd\">\n<span id=\"module-reconst-benchmarks-bench-csd\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_csd</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks.bench_csd\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\" title=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a>(gtab,\u00a0response)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable\" title=\"dipy.reconst.benchmarks.bench_csd.GradientTable\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a>(gradients[,\u00a0big_delta,\u00a0\u2026])</p></td>\n<td><p>Diffusion gradient information</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.bench_csdeconv\" title=\"dipy.reconst.benchmarks.bench_csd.bench_csdeconv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench_csdeconv</span></code></a>([center,\u00a0width])</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.load_nifti_data\" title=\"dipy.reconst.benchmarks.bench_csd.load_nifti_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">load_nifti_data</span></code></a>(fname[,\u00a0as_ndarray])</p></td>\n<td><p>Load only the data array from a nifti file.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.num_grad\" title=\"dipy.reconst.benchmarks.bench_csd.num_grad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">num_grad</span></code></a>(gtab)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.read_stanford_labels\" title=\"dipy.reconst.benchmarks.bench_csd.read_stanford_labels\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">read_stanford_labels</span></code></a>()</p></td>\n<td><p>Read stanford hardi data and label map.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks.bench_peaks\">\n<span id=\"module-reconst-benchmarks-bench-peaks\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_peaks</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks.bench_peaks\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Benchmarks for peak finding</p>\n<p>Run all benchmarks with:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">dipy.reconst</span> <span class=\"k\">as</span> <span class=\"nn\">dire</span>\n<span class=\"n\">dire</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>With Pytest, Run this benchmark with:</p>\n<blockquote>\n<div><p>pytest -svv -c bench.ini /path/to/bench_peaks.py</p>\n</div></blockquote>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima\" title=\"dipy.reconst.benchmarks.bench_peaks.bench_local_maxima\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench_local_maxima</span></code></a>()</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_peaks.local_maxima\" title=\"dipy.reconst.benchmarks.bench_peaks.local_maxima\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">local_maxima</span></code></a></p></td>\n<td><p>Local maxima of a function evaluated on a discrete set of points.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_peaks.measure\" title=\"dipy.reconst.benchmarks.bench_peaks.measure\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">measure</span></code></a>(code_str[,\u00a0times,\u00a0label])</p></td>\n<td><p>Return elapsed time for executing code in the namespace of the caller.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_peaks.unique_edges\" title=\"dipy.reconst.benchmarks.bench_peaks.unique_edges\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">unique_edges</span></code></a>(faces[,\u00a0return_mapping])</p></td>\n<td><p>Extract all unique edges from given triangular faces.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks.bench_squash\">\n<span id=\"module-reconst-benchmarks-bench-squash\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_squash</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks.bench_squash\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Benchmarks for fast squashing</p>\n<p>Run all benchmarks with:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">dipy.reconst</span> <span class=\"k\">as</span> <span class=\"nn\">dire</span>\n<span class=\"n\">dire</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>With Pytest, Run this benchmark with:</p>\n<blockquote>\n<div><p>pytest -svv -c bench.ini /path/to/bench_squash.py</p>\n</div></blockquote>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.bench_quick_squash\" title=\"dipy.reconst.benchmarks.bench_squash.bench_quick_squash\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench_quick_squash</span></code></a>()</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.measure\" title=\"dipy.reconst.benchmarks.bench_squash.measure\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">measure</span></code></a>(code_str[,\u00a0times,\u00a0label])</p></td>\n<td><p>Return elapsed time for executing code in the namespace of the caller.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.ndindex\" title=\"dipy.reconst.benchmarks.bench_squash.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.old_squash\" title=\"dipy.reconst.benchmarks.bench_squash.old_squash\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">old_squash</span></code></a>(arr[,\u00a0mask,\u00a0fill])</p></td>\n<td><p>Try and make a standard array from an object array</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.quick_squash\" title=\"dipy.reconst.benchmarks.bench_squash.quick_squash\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quick_squash</span></code></a></p></td>\n<td><p>Try and make a standard array from an object array</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_squash.reduce\" title=\"dipy.reconst.benchmarks.bench_squash.reduce\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">reduce</span></code></a>(function,\u00a0sequence[,\u00a0initial])</p></td>\n<td><p>Apply a function of two arguments cumulatively to the items of a sequence, from left to right, so as to reduce the sequence to a single value.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.benchmarks.bench_vec_val_sum\">\n<span id=\"module-reconst-benchmarks-bench-vec-val-sum\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_vec_val_sum</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.benchmarks.bench_vec_val_sum\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Benchmarks for vec / val summation routine</p>\n<p>Run benchmarks with:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">dipy.reconst</span> <span class=\"k\">as</span> <span class=\"nn\">dire</span>\n<span class=\"n\">dire</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>With Pytest, Run this benchmark with:</p>\n<blockquote>\n<div><p>pytest -svv -c bench.ini /path/to/bench_vec_val_sum.py</p>\n</div></blockquote>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect\" title=\"dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bench_vec_val_vect</span></code></a>()</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.measure\" title=\"dipy.reconst.benchmarks.bench_vec_val_sum.measure\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">measure</span></code></a>(code_str[,\u00a0times,\u00a0label])</p></td>\n<td><p>Return elapsed time for executing code in the namespace of the caller.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.randn\" title=\"dipy.reconst.benchmarks.bench_vec_val_sum.randn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">randn</span></code></a>(d0,\u00a0d1,\u00a0\u2026,\u00a0dn)</p></td>\n<td><p>Return a sample (or samples) from the \u201cstandard normal\u201d distribution.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect\" title=\"dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec_val_vect</span></code></a></p></td>\n<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.cache\">\n<span id=\"module-reconst-cache\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.cache</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.cache\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cache.auto_attr\" title=\"dipy.reconst.cache.auto_attr\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_attr</span></code></a>(func)</p></td>\n<td><p>Decorator to create OneTimeProperty attributes.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.cross_validation\">\n<span id=\"module-reconst-cross-validation\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.cross_validation</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.cross_validation\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Cross-validation analysis of diffusion models.</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cross_validation.coeff_of_determination\" title=\"dipy.reconst.cross_validation.coeff_of_determination\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">coeff_of_determination</span></code></a>(data,\u00a0model[,\u00a0axis])</p></td>\n<td><p>Calculate the coefficient of determination for a model prediction,</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cross_validation.kfold_xval\" title=\"dipy.reconst.cross_validation.kfold_xval\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kfold_xval</span></code></a>(model,\u00a0data,\u00a0folds,\u00a0*model_args,\u00a0\u2026)</p></td>\n<td><p>Perform k-fold cross-validation.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.csdeconv\">\n<span id=\"module-reconst-csdeconv\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.csdeconv</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.csdeconv\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.AxSymShResponse\" title=\"dipy.reconst.csdeconv.AxSymShResponse\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">AxSymShResponse</span></code></a>(S0,\u00a0dwi_response[,\u00a0bvalue])</p></td>\n<td><p>A simple wrapper for response functions represented using only axially symmetric, even spherical harmonic functions (ie, m == 0 and n even).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel\" title=\"dipy.reconst.csdeconv.ConstrainedSDTModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ConstrainedSDTModel</span></code></a>(gtab,\u00a0ratio[,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\" title=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a>(gtab,\u00a0response)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmFit\" title=\"dipy.reconst.csdeconv.SphHarmFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a>(model,\u00a0shm_coef,\u00a0mask)</p></td>\n<td><p>Diffusion data fit to a spherical harmonic model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmModel\" title=\"dipy.reconst.csdeconv.SphHarmModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a>(gtab)</p></td>\n<td><p>To be subclassed by all models that return a SphHarmFit when fit.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.TensorModel\" title=\"dipy.reconst.csdeconv.TensorModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a>(gtab[,\u00a0fit_method,\u00a0return_S0_hat])</p></td>\n<td><p>Diffusion Tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.auto_response\" title=\"dipy.reconst.csdeconv.auto_response\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_response</span></code></a>(gtab,\u00a0data[,\u00a0roi_center,\u00a0\u2026])</p></td>\n<td><p>Automatic estimation of ssst response function using FA.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.auto_response_ssst\" title=\"dipy.reconst.csdeconv.auto_response_ssst\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_response_ssst</span></code></a>(gtab,\u00a0data[,\u00a0roi_center,\u00a0\u2026])</p></td>\n<td><p>Automatic estimation of single-shell single-tissue (ssst) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.cart2sphere\" title=\"dipy.reconst.csdeconv.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.csdeconv\" title=\"dipy.reconst.csdeconv.csdeconv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">csdeconv</span></code></a>(dwsignal,\u00a0X,\u00a0B_reg[,\u00a0tau,\u00a0\u2026])</p></td>\n<td><p>Constrained-regularized spherical deconvolution (CSD) <a class=\"reference internal\" href=\"#r537fd66f8bb4-1\" id=\"id1\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.deprecate_with_version\" title=\"dipy.reconst.csdeconv.deprecate_with_version\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">deprecate_with_version</span></code></a>(message[,\u00a0since,\u00a0\u2026])</p></td>\n<td><p>Return decorator function function for deprecation warning / error.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.estimate_response\" title=\"dipy.reconst.csdeconv.estimate_response\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_response</span></code></a>(gtab,\u00a0evals,\u00a0S0)</p></td>\n<td><p>Estimate single fiber response function</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.fa_trace_to_lambdas\" title=\"dipy.reconst.csdeconv.fa_trace_to_lambdas\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa_trace_to_lambdas</span></code></a>([fa,\u00a0trace])</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.forward_sdeconv_mat\" title=\"dipy.reconst.csdeconv.forward_sdeconv_mat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">forward_sdeconv_mat</span></code></a>(r_rh,\u00a0n)</p></td>\n<td><p>Build forward spherical deconvolution matrix</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.forward_sdt_deconv_mat\" title=\"dipy.reconst.csdeconv.forward_sdt_deconv_mat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">forward_sdt_deconv_mat</span></code></a>(ratio,\u00a0n[,\u00a0r2_term])</p></td>\n<td><p>Build forward sharpening deconvolution transform (SDT) matrix</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.fractional_anisotropy\" title=\"dipy.reconst.csdeconv.fractional_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fractional_anisotropy</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.get_sphere\" title=\"dipy.reconst.csdeconv.get_sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_sphere</span></code></a>([name])</p></td>\n<td><p>provide triangulated spheres</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.lazy_index\" title=\"dipy.reconst.csdeconv.lazy_index\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lazy_index</span></code></a>(index)</p></td>\n<td><p>Produces a lazy index</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.lpn\" title=\"dipy.reconst.csdeconv.lpn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lpn</span></code></a>(n,\u00a0z)</p></td>\n<td><p>Legendre function of the first kind.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.mask_for_response_ssst\" title=\"dipy.reconst.csdeconv.mask_for_response_ssst\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mask_for_response_ssst</span></code></a>(gtab,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Computation of mask for single-shell single-tissue (ssst) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.multi_voxel_fit\" title=\"dipy.reconst.csdeconv.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ndindex\" title=\"dipy.reconst.csdeconv.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.odf_deconv\" title=\"dipy.reconst.csdeconv.odf_deconv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_deconv</span></code></a>(odf_sh,\u00a0R,\u00a0B_reg[,\u00a0lambda_,\u00a0tau,\u00a0\u2026])</p></td>\n<td><p>ODF constrained-regularized spherical deconvolution using the Sharpening Deconvolution Transform (SDT) <a class=\"reference internal\" href=\"#ra707a2933099-1\" id=\"id2\">[1]</a>, <a class=\"reference internal\" href=\"#ra707a2933099-2\" id=\"id3\">[2]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.odf_sh_to_sharp\" title=\"dipy.reconst.csdeconv.odf_sh_to_sharp\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_sh_to_sharp</span></code></a>(odfs_sh,\u00a0sphere[,\u00a0basis,\u00a0\u2026])</p></td>\n<td><p>Sharpen odfs using the sharpening deconvolution transform <a class=\"reference internal\" href=\"#rc713c9e45b9d-2\" id=\"id4\">[2]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.peaks_from_model\" title=\"dipy.reconst.csdeconv.peaks_from_model\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">peaks_from_model</span></code></a>(model,\u00a0data,\u00a0sphere,\u00a0\u2026[,\u00a0\u2026])</p></td>\n<td><p>Fit the model to data and computes peaks and metrics</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.quad\" title=\"dipy.reconst.csdeconv.quad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quad</span></code></a>(func,\u00a0a,\u00a0b[,\u00a0args,\u00a0full_output,\u00a0\u2026])</p></td>\n<td><p>Compute a definite integral.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.real_sph_harm\" title=\"dipy.reconst.csdeconv.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.real_sym_sh_basis\" title=\"dipy.reconst.csdeconv.real_sym_sh_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sym_sh_basis</span></code></a>(sh_order,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.recursive_response\" title=\"dipy.reconst.csdeconv.recursive_response\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">recursive_response</span></code></a>(gtab,\u00a0data[,\u00a0mask,\u00a0\u2026])</p></td>\n<td><p>Recursive calibration of response function using peak threshold</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.response_from_mask\" title=\"dipy.reconst.csdeconv.response_from_mask\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">response_from_mask</span></code></a>(gtab,\u00a0data,\u00a0mask)</p></td>\n<td><p>Computation of single-shell single-tissue (ssst) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.response_from_mask_ssst\" title=\"dipy.reconst.csdeconv.response_from_mask_ssst\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">response_from_mask_ssst</span></code></a>(gtab,\u00a0data,\u00a0mask)</p></td>\n<td><p>Computation of single-shell single-tissue (ssst) response</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.sh_to_rh\" title=\"dipy.reconst.csdeconv.sh_to_rh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sh_to_rh</span></code></a>(r_sh,\u00a0m,\u00a0n)</p></td>\n<td><p>Spherical harmonics (SH) to rotational harmonics (RH)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.single_tensor\" title=\"dipy.reconst.csdeconv.single_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">single_tensor</span></code></a>(gtab[,\u00a0S0,\u00a0evals,\u00a0evecs,\u00a0snr])</p></td>\n<td><p>Simulate diffusion-weighted signals with a single tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.sph_harm_ind_list\" title=\"dipy.reconst.csdeconv.sph_harm_ind_list\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sph_harm_ind_list</span></code></a>(sh_order[,\u00a0full_basis])</p></td>\n<td><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical harmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.vec2vec_rotmat\" title=\"dipy.reconst.csdeconv.vec2vec_rotmat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec2vec_rotmat</span></code></a>(u,\u00a0v)</p></td>\n<td><p>rotation matrix from 2 unit vectors</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.dki\">\n<span id=\"module-reconst-dki\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dki</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.dki\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting the diffusion kurtosis model</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit\" title=\"dipy.reconst.dki.DiffusionKurtosisFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p>Class for fitting the Diffusion Kurtosis Model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel\" title=\"dipy.reconst.dki.DiffusionKurtosisModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Class for the Diffusion Kurtosis Model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.ReconstModel\" title=\"dipy.reconst.dki.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit\" title=\"dipy.reconst.dki.TensorFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a>(model,\u00a0model_params[,\u00a0model_S0])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.Wcons\" title=\"dipy.reconst.dki.Wcons\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Wcons</span></code></a>(k_elements)</p></td>\n<td><p>Construct the full 4D kurtosis tensors from its 15 independent elements</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.Wrotate\" title=\"dipy.reconst.dki.Wrotate\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Wrotate</span></code></a>(kt,\u00a0Basis)</p></td>\n<td><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system to another coordinate system basis</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.Wrotate_element\" title=\"dipy.reconst.dki.Wrotate_element\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Wrotate_element</span></code></a>(kt,\u00a0indi,\u00a0indj,\u00a0indk,\u00a0indl,\u00a0B)</p></td>\n<td><p>Computes the the specified index element of a kurtosis tensor rotated to the coordinate system basis B.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.apparent_kurtosis_coef\" title=\"dipy.reconst.dki.apparent_kurtosis_coef\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">apparent_kurtosis_coef</span></code></a>(dki_params,\u00a0sphere[,\u00a0\u2026])</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (AKC) in each direction of a sphere <a class=\"reference internal\" href=\"#r1b3e9922dec3-1\" id=\"id5\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.axial_kurtosis\" title=\"dipy.reconst.dki.axial_kurtosis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">axial_kurtosis</span></code></a>(dki_params[,\u00a0min_kurtosis,\u00a0\u2026])</p></td>\n<td><p>Computes axial Kurtosis (AK) from the kurtosis tensor <a class=\"reference internal\" href=\"#rf80d380179f9-1\" id=\"id6\">[1]</a>, <a class=\"reference internal\" href=\"#rf80d380179f9-2\" id=\"id7\">[2]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.carlson_rd\" title=\"dipy.reconst.dki.carlson_rd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">carlson_rd</span></code></a>(x,\u00a0y,\u00a0z[,\u00a0errtol])</p></td>\n<td><p>Computes the Carlson\u2019s incomplete elliptic integral of the second kind defined as:</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.carlson_rf\" title=\"dipy.reconst.dki.carlson_rf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">carlson_rf</span></code></a>(x,\u00a0y,\u00a0z[,\u00a0errtol])</p></td>\n<td><p>Computes the Carlson\u2019s incomplete elliptic integral of the first kind defined as:</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.cart2sphere\" title=\"dipy.reconst.dki.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.check_multi_b\" title=\"dipy.reconst.dki.check_multi_b\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">check_multi_b</span></code></a>(gtab,\u00a0n_bvals[,\u00a0non_zero,\u00a0bmag])</p></td>\n<td><p>Check if you have enough different b-values in your gradient table</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.decompose_tensor\" title=\"dipy.reconst.dki.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a>(tensor[,\u00a0min_diffusivity])</p></td>\n<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.design_matrix\" title=\"dipy.reconst.dki.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a>(gtab)</p></td>\n<td><p>Construct B design matrix for DKI.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.directional_diffusion\" title=\"dipy.reconst.dki.directional_diffusion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directional_diffusion</span></code></a>(dt,\u00a0V[,\u00a0min_diffusivity])</p></td>\n<td><p>Calculates the apparent diffusion coefficient (adc) in each direction of a sphere for a single voxel <a class=\"reference internal\" href=\"#r62a8a421f533-1\" id=\"id8\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.directional_diffusion_variance\" title=\"dipy.reconst.dki.directional_diffusion_variance\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directional_diffusion_variance</span></code></a>(kt,\u00a0V[,\u00a0\u2026])</p></td>\n<td><p>Calculates the apparent diffusion variance (adv) in each direction of a sphere for a single voxel <a class=\"reference internal\" href=\"#r87e53edeef9c-1\" id=\"id9\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.directional_kurtosis\" title=\"dipy.reconst.dki.directional_kurtosis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directional_kurtosis</span></code></a>(dt,\u00a0md,\u00a0kt,\u00a0V[,\u00a0\u2026])</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel <a class=\"reference internal\" href=\"#ra6181896282f-1\" id=\"id10\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.dki_prediction\" title=\"dipy.reconst.dki.dki_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dki_prediction</span></code></a>(dki_params,\u00a0gtab[,\u00a0S0])</p></td>\n<td><p>Predict a signal given diffusion kurtosis imaging parameters.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.from_lower_triangular\" title=\"dipy.reconst.dki.from_lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">from_lower_triangular</span></code></a>(D)</p></td>\n<td><p>Returns a tensor given the six unique tensor elements</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.get_fnames\" title=\"dipy.reconst.dki.get_fnames\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_fnames</span></code></a>([name])</p></td>\n<td><p>Provide full paths to example or test datasets.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.get_sphere\" title=\"dipy.reconst.dki.get_sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_sphere</span></code></a>([name])</p></td>\n<td><p>provide triangulated spheres</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.kurtosis_fractional_anisotropy\" title=\"dipy.reconst.dki.kurtosis_fractional_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kurtosis_fractional_anisotropy</span></code></a>(dki_params)</p></td>\n<td><p>Computes the anisotropy of the kurtosis tensor (KFA) <a class=\"reference internal\" href=\"#r1c91af01b9f3-1\" id=\"id11\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.kurtosis_maximum\" title=\"dipy.reconst.dki.kurtosis_maximum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kurtosis_maximum</span></code></a>(dki_params[,\u00a0sphere,\u00a0gtol,\u00a0\u2026])</p></td>\n<td><p>Computes kurtosis maximum value</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.local_maxima\" title=\"dipy.reconst.dki.local_maxima\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">local_maxima</span></code></a></p></td>\n<td><p>Local maxima of a function evaluated on a discrete set of points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.lower_triangular\" title=\"dipy.reconst.dki.lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lower_triangular</span></code></a>(tensor[,\u00a0b0])</p></td>\n<td><p>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.mean_diffusivity\" title=\"dipy.reconst.dki.mean_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.mean_kurtosis\" title=\"dipy.reconst.dki.mean_kurtosis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_kurtosis</span></code></a>(dki_params[,\u00a0min_kurtosis,\u00a0\u2026])</p></td>\n<td><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.mean_kurtosis_tensor\" title=\"dipy.reconst.dki.mean_kurtosis_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_kurtosis_tensor</span></code></a>(dki_params[,\u00a0\u2026])</p></td>\n<td><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#r36a19797d370-1\" id=\"id12\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.ndindex\" title=\"dipy.reconst.dki.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.nlls_fit_tensor\" title=\"dipy.reconst.dki.nlls_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlls_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Fit the cumulant expansion params (e.g.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.ols_fit_dki\" title=\"dipy.reconst.dki.ols_fit_dki\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ols_fit_dki</span></code></a>(design_matrix,\u00a0data)</p></td>\n<td><p>Computes the diffusion and kurtosis tensors using an ordinary linear least squares (OLS) approach <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id13\">1</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.perpendicular_directions\" title=\"dipy.reconst.dki.perpendicular_directions\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">perpendicular_directions</span></code></a>(v[,\u00a0num,\u00a0half])</p></td>\n<td><p>Computes n evenly spaced perpendicular directions relative to a given vector v</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.radial_kurtosis\" title=\"dipy.reconst.dki.radial_kurtosis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">radial_kurtosis</span></code></a>(dki_params[,\u00a0min_kurtosis,\u00a0\u2026])</p></td>\n<td><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r7cf9df14e56e-1\" id=\"id14\">[1]</a>, <a class=\"reference internal\" href=\"#r7cf9df14e56e-2\" id=\"id15\">[2]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.restore_fit_tensor\" title=\"dipy.reconst.dki.restore_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">restore_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Use the RESTORE algorithm <a class=\"reference internal\" href=\"#r60e7076f793f-1\" id=\"id16\">[1]</a> to calculate a robust tensor fit</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.sphere2cart\" title=\"dipy.reconst.dki.sphere2cart\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code></a>(r,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Spherical to Cartesian coordinates</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.split_dki_param\" title=\"dipy.reconst.dki.split_dki_param\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">split_dki_param</span></code></a>(dki_params)</p></td>\n<td><p>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.vec_val_vect\" title=\"dipy.reconst.dki.vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec_val_vect</span></code></a></p></td>\n<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.wls_fit_dki\" title=\"dipy.reconst.dki.wls_fit_dki\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_fit_dki</span></code></a>(design_matrix,\u00a0data)</p></td>\n<td><p>Computes the diffusion and kurtosis tensors using a weighted linear least squares (WLS) approach <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id17\">1</a>.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.dki_micro\">\n<span id=\"module-reconst-dki-micro\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dki_micro</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.dki_micro\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting the DKI-based microstructural model</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p>Class for fitting the Diffusion Kurtosis Model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Class for the Diffusion Kurtosis Model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructuralFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p>Class for fitting the Diffusion Kurtosis Microstructural Model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructureModel</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Class for the Diffusion Kurtosis Microstructural Model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.axial_diffusivity\" title=\"dipy.reconst.dki_micro.axial_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">axial_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Axial Diffusivity (AD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.axonal_water_fraction\" title=\"dipy.reconst.dki_micro.axonal_water_fraction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">axonal_water_fraction</span></code></a>(dki_params[,\u00a0sphere,\u00a0\u2026])</p></td>\n<td><p>Computes the axonal water fraction from DKI <a class=\"reference internal\" href=\"#r48388d37c81b-1\" id=\"id18\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.decompose_tensor\" title=\"dipy.reconst.dki_micro.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a>(tensor[,\u00a0min_diffusivity])</p></td>\n<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.diffusion_components\" title=\"dipy.reconst.dki_micro.diffusion_components\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">diffusion_components</span></code></a>(dki_params[,\u00a0sphere,\u00a0\u2026])</p></td>\n<td><p>Extracts the restricted and hindered diffusion tensors of well aligned fibers from diffusion kurtosis imaging parameters <a class=\"reference internal\" href=\"#rfba5c976a30b-1\" id=\"id19\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.directional_diffusion\" title=\"dipy.reconst.dki_micro.directional_diffusion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directional_diffusion</span></code></a>(dt,\u00a0V[,\u00a0min_diffusivity])</p></td>\n<td><p>Calculates the apparent diffusion coefficient (adc) in each direction of a sphere for a single voxel <a class=\"reference internal\" href=\"#r1dff1a553580-1\" id=\"id20\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.directional_kurtosis\" title=\"dipy.reconst.dki_micro.directional_kurtosis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directional_kurtosis</span></code></a>(dt,\u00a0md,\u00a0kt,\u00a0V[,\u00a0\u2026])</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (akc) in each direction of a sphere for a single voxel <a class=\"reference internal\" href=\"#r014624b5ce79-1\" id=\"id21\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.dkimicro_prediction\" title=\"dipy.reconst.dki_micro.dkimicro_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dkimicro_prediction</span></code></a>(params,\u00a0gtab[,\u00a0S0])</p></td>\n<td><p>Signal prediction given the DKI microstructure model parameters.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.dti_design_matrix\" title=\"dipy.reconst.dki_micro.dti_design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dti_design_matrix</span></code></a>(gtab[,\u00a0dtype])</p></td>\n<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.from_lower_triangular\" title=\"dipy.reconst.dki_micro.from_lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">from_lower_triangular</span></code></a>(D)</p></td>\n<td><p>Returns a tensor given the six unique tensor elements</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.get_sphere\" title=\"dipy.reconst.dki_micro.get_sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_sphere</span></code></a>([name])</p></td>\n<td><p>provide triangulated spheres</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.kurtosis_maximum\" title=\"dipy.reconst.dki_micro.kurtosis_maximum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kurtosis_maximum</span></code></a>(dki_params[,\u00a0sphere,\u00a0gtol,\u00a0\u2026])</p></td>\n<td><p>Computes kurtosis maximum value</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.lower_triangular\" title=\"dipy.reconst.dki_micro.lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lower_triangular</span></code></a>(tensor[,\u00a0b0])</p></td>\n<td><p>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.mean_diffusivity\" title=\"dipy.reconst.dki_micro.mean_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.ndindex\" title=\"dipy.reconst.dki_micro.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.radial_diffusivity\" title=\"dipy.reconst.dki_micro.radial_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">radial_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Radial Diffusivity (RD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.split_dki_param\" title=\"dipy.reconst.dki_micro.split_dki_param\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">split_dki_param</span></code></a>(dki_params)</p></td>\n<td><p>Extract the diffusion tensor eigenvalues, the diffusion tensor eigenvector matrix, and the 15 independent elements of the kurtosis tensor from the model parameters estimated from the DKI model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.tortuosity\" title=\"dipy.reconst.dki_micro.tortuosity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tortuosity</span></code></a>(hindered_ad,\u00a0hindered_rd)</p></td>\n<td><p>Computes the tortuosity of the hindered diffusion compartment given its axial and radial diffusivities</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.trace\" title=\"dipy.reconst.dki_micro.trace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Trace of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.vec_val_vect\" title=\"dipy.reconst.dki_micro.vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec_val_vect</span></code></a></p></td>\n<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.dsi\">\n<span id=\"module-reconst-dsi\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dsi</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.dsi\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.Cache\" title=\"dipy.reconst.dsi.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvModel</span></code></a>(gtab[,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumModel</span></code></a>(gtab[,\u00a0qgrid_size,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfFit\" title=\"dipy.reconst.dsi.OdfFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfModel\" title=\"dipy.reconst.dsi.OdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a>(gtab)</p></td>\n<td><p>An abstract class to be sub-classed by specific odf models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.LR_deconv\" title=\"dipy.reconst.dsi.LR_deconv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LR_deconv</span></code></a>(prop,\u00a0psf[,\u00a0numit,\u00a0acc_factor])</p></td>\n<td><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.create_qspace\" title=\"dipy.reconst.dsi.create_qspace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">create_qspace</span></code></a>(gtab,\u00a0origin)</p></td>\n<td><p>create the 3D grid which holds the signal values (q-space)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.create_qtable\" title=\"dipy.reconst.dsi.create_qtable\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">create_qtable</span></code></a>(gtab,\u00a0origin)</p></td>\n<td><p>create a normalized version of gradients</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.fftn\" title=\"dipy.reconst.dsi.fftn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fftn</span></code></a>(x[,\u00a0shape,\u00a0axes,\u00a0overwrite_x])</p></td>\n<td><p>Return multidimensional discrete Fourier transform.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.fftshift\" title=\"dipy.reconst.dsi.fftshift\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fftshift</span></code></a>(x[,\u00a0axes])</p></td>\n<td><p>Shift the zero-frequency component to the center of the spectrum.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.gen_PSF\" title=\"dipy.reconst.dsi.gen_PSF\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gen_PSF</span></code></a>(qgrid_sampling,\u00a0siz_x,\u00a0siz_y,\u00a0siz_z)</p></td>\n<td><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary q-space sampling mask and truncating it to keep only the center.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.half_to_full_qspace\" title=\"dipy.reconst.dsi.half_to_full_qspace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">half_to_full_qspace</span></code></a>(data,\u00a0gtab)</p></td>\n<td><p>Half to full Cartesian grid mapping</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.hanning_filter\" title=\"dipy.reconst.dsi.hanning_filter\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hanning_filter</span></code></a>(gtab,\u00a0filter_width,\u00a0origin)</p></td>\n<td><p>create a hanning window</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.ifftshift\" title=\"dipy.reconst.dsi.ifftshift\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ifftshift</span></code></a>(x[,\u00a0axes])</p></td>\n<td><p>The inverse of <cite>fftshift</cite>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.map_coordinates\" title=\"dipy.reconst.dsi.map_coordinates\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">map_coordinates</span></code></a>(input,\u00a0coordinates[,\u00a0\u2026])</p></td>\n<td><p>Map the input array to new coordinates by interpolation.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.multi_voxel_fit\" title=\"dipy.reconst.dsi.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.pdf_interp_coords\" title=\"dipy.reconst.dsi.pdf_interp_coords\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf_interp_coords</span></code></a>(sphere,\u00a0rradius,\u00a0origin)</p></td>\n<td><p>Precompute coordinates for ODF calculation from the PDF</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.pdf_odf\" title=\"dipy.reconst.dsi.pdf_odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf_odf</span></code></a>(Pr,\u00a0rradius,\u00a0interp_coords)</p></td>\n<td><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.project_hemisph_bvecs\" title=\"dipy.reconst.dsi.project_hemisph_bvecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">project_hemisph_bvecs</span></code></a>(gtab)</p></td>\n<td><p>Project any near identical bvecs to the other hemisphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.threshold_propagator\" title=\"dipy.reconst.dsi.threshold_propagator\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">threshold_propagator</span></code></a>(P[,\u00a0estimated_snr])</p></td>\n<td><p>Applies hard threshold on the propagator to remove background noise for the deconvolution.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.dti\">\n<span id=\"module-reconst-dti\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dti</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.dti\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting tensors</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.ReconstModel\" title=\"dipy.reconst.dti.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit\" title=\"dipy.reconst.dti.TensorFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a>(model,\u00a0model_params[,\u00a0model_S0])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorModel\" title=\"dipy.reconst.dti.TensorModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a>(gtab[,\u00a0fit_method,\u00a0return_S0_hat])</p></td>\n<td><p>Diffusion Tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.apparent_diffusion_coef\" title=\"dipy.reconst.dti.apparent_diffusion_coef\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">apparent_diffusion_coef</span></code></a>(q_form,\u00a0sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a sphere.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.auto_attr\" title=\"dipy.reconst.dti.auto_attr\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_attr</span></code></a>(func)</p></td>\n<td><p>Decorator to create OneTimeProperty attributes.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.axial_diffusivity\" title=\"dipy.reconst.dti.axial_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">axial_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Axial Diffusivity (AD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.color_fa\" title=\"dipy.reconst.dti.color_fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code></a>(fa,\u00a0evecs)</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.decompose_tensor\" title=\"dipy.reconst.dti.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a>(tensor[,\u00a0min_diffusivity])</p></td>\n<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.design_matrix\" title=\"dipy.reconst.dti.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a>(gtab[,\u00a0dtype])</p></td>\n<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.determinant\" title=\"dipy.reconst.dti.determinant\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">determinant</span></code></a>(q_form)</p></td>\n<td><p>The determinant of a tensor, given in quadratic form</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.deviatoric\" title=\"dipy.reconst.dti.deviatoric\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">deviatoric</span></code></a>(q_form)</p></td>\n<td><p>Calculate the deviatoric (anisotropic) part of the tensor <a class=\"reference internal\" href=\"#rfe2215338679-1\" id=\"id22\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.eig_from_lo_tri\" title=\"dipy.reconst.dti.eig_from_lo_tri\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">eig_from_lo_tri</span></code></a>(data[,\u00a0min_diffusivity])</p></td>\n<td><p>Calculates tensor eigenvalues/eigenvectors from an array containing the lower diagonal form of the six unique tensor elements.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.fractional_anisotropy\" title=\"dipy.reconst.dti.fractional_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fractional_anisotropy</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.from_lower_triangular\" title=\"dipy.reconst.dti.from_lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">from_lower_triangular</span></code></a>(D)</p></td>\n<td><p>Returns a tensor given the six unique tensor elements</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.geodesic_anisotropy\" title=\"dipy.reconst.dti.geodesic_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">geodesic_anisotropy</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Geodesic anisotropy (GA) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.get_sphere\" title=\"dipy.reconst.dti.get_sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_sphere</span></code></a>([name])</p></td>\n<td><p>provide triangulated spheres</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.gradient_table\" title=\"dipy.reconst.dti.gradient_table\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table</span></code></a>(bvals[,\u00a0bvecs,\u00a0big_delta,\u00a0\u2026])</p></td>\n<td><p>A general function for creating diffusion MR gradients.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.isotropic\" title=\"dipy.reconst.dti.isotropic\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">isotropic</span></code></a>(q_form)</p></td>\n<td><p>Calculate the isotropic part of the tensor <a class=\"reference internal\" href=\"#rd0568a744381-1\" id=\"id23\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.iter_fit_tensor\" title=\"dipy.reconst.dti.iter_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">iter_fit_tensor</span></code></a>([step])</p></td>\n<td><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.linearity\" title=\"dipy.reconst.dti.linearity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>The linearity of the tensor <a class=\"reference internal\" href=\"#r6fa152915e78-1\" id=\"id24\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.lower_triangular\" title=\"dipy.reconst.dti.lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lower_triangular</span></code></a>(tensor[,\u00a0b0])</p></td>\n<td><p>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.mean_diffusivity\" title=\"dipy.reconst.dti.mean_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.mode\" title=\"dipy.reconst.dti.mode\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code></a>(q_form)</p></td>\n<td><p>Mode (MO) of a diffusion tensor <a class=\"reference internal\" href=\"#rae241588dfcd-1\" id=\"id25\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.nlls_fit_tensor\" title=\"dipy.reconst.dti.nlls_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlls_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Fit the cumulant expansion params (e.g.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.norm\" title=\"dipy.reconst.dti.norm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">norm</span></code></a>(q_form)</p></td>\n<td><p>Calculate the Frobenius norm of a tensor quadratic form</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.ols_fit_tensor\" title=\"dipy.reconst.dti.ols_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ols_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion tensor using a linear regression model <span id=\"id26\">[Rd310240b4eed-1]</span>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.pinv\" title=\"dipy.reconst.dti.pinv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pinv</span></code></a>(a[,\u00a0rcond])</p></td>\n<td><p>Vectorized version of <cite>numpy.linalg.pinv</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.planarity\" title=\"dipy.reconst.dti.planarity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>The planarity of the tensor <a class=\"reference internal\" href=\"#re4b018c1dd86-1\" id=\"id27\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.quantize_evecs\" title=\"dipy.reconst.dti.quantize_evecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quantize_evecs</span></code></a>(evecs[,\u00a0odf_vertices])</p></td>\n<td><p>Find the closest orientation of an evenly distributed sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.radial_diffusivity\" title=\"dipy.reconst.dti.radial_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">radial_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Radial Diffusivity (RD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.restore_fit_tensor\" title=\"dipy.reconst.dti.restore_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">restore_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Use the RESTORE algorithm <a class=\"reference internal\" href=\"#r26bc1bb874b1-1\" id=\"id28\">[1]</a> to calculate a robust tensor fit</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.sphericity\" title=\"dipy.reconst.dti.sphericity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>The sphericity of the tensor <a class=\"reference internal\" href=\"#r6ba6fcb5068a-1\" id=\"id29\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.tensor_prediction\" title=\"dipy.reconst.dti.tensor_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tensor_prediction</span></code></a>(dti_params,\u00a0gtab,\u00a0S0)</p></td>\n<td><p>Predict a signal given tensor parameters.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.trace\" title=\"dipy.reconst.dti.trace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Trace of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.vec_val_vect\" title=\"dipy.reconst.dti.vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec_val_vect</span></code></a></p></td>\n<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.vector_norm\" title=\"dipy.reconst.dti.vector_norm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vector_norm</span></code></a>(vec[,\u00a0axis,\u00a0keepdims])</p></td>\n<td><p>Return vector Euclidean (L2) norm</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.wls_fit_tensor\" title=\"dipy.reconst.dti.wls_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_fit_tensor</span></code></a>(design_matrix,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model <a class=\"reference internal\" href=\"#rba397ddf7dbd-1\" id=\"id30\">[1]</a>.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.forecast\">\n<span id=\"module-reconst-forecast\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.forecast</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.forecast\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.Cache\" title=\"dipy.reconst.forecast.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit\" title=\"dipy.reconst.forecast.ForecastFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ForecastFit</span></code></a>(model,\u00a0data,\u00a0sh_coef,\u00a0d_par,\u00a0d_perp)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastModel\" title=\"dipy.reconst.forecast.ForecastModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ForecastModel</span></code></a>(gtab[,\u00a0sh_order,\u00a0lambda_lb,\u00a0\u2026])</p></td>\n<td><p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors (FORECAST) [1,2,3]_.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.LooseVersion\" title=\"dipy.reconst.forecast.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfFit\" title=\"dipy.reconst.forecast.OdfFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfModel\" title=\"dipy.reconst.forecast.OdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a>(gtab)</p></td>\n<td><p>An abstract class to be sub-classed by specific odf models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.cart2sphere\" title=\"dipy.reconst.forecast.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.csdeconv\" title=\"dipy.reconst.forecast.csdeconv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">csdeconv</span></code></a>(dwsignal,\u00a0X,\u00a0B_reg[,\u00a0tau,\u00a0\u2026])</p></td>\n<td><p>Constrained-regularized spherical deconvolution (CSD) <a class=\"reference internal\" href=\"#r89c481eb6cb9-1\" id=\"id31\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.find_signal_means\" title=\"dipy.reconst.forecast.find_signal_means\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">find_signal_means</span></code></a>(b_unique,\u00a0data_norm,\u00a0\u2026)</p></td>\n<td><p>Calculate the mean signal for each shell.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.forecast_error_func\" title=\"dipy.reconst.forecast.forecast_error_func\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">forecast_error_func</span></code></a>(x,\u00a0b_unique,\u00a0E)</p></td>\n<td><p>Calculates the difference between the mean signal calculated using the parameter vector x and the average signal E using FORECAST and SMT</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.forecast_matrix\" title=\"dipy.reconst.forecast.forecast_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">forecast_matrix</span></code></a>(sh_order,\u00a0d_par,\u00a0d_perp,\u00a0bvals)</p></td>\n<td><p>Compute the FORECAST radial matrix</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.lb_forecast\" title=\"dipy.reconst.forecast.lb_forecast\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lb_forecast</span></code></a>(sh_order)</p></td>\n<td><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.leastsq\" title=\"dipy.reconst.forecast.leastsq\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">leastsq</span></code></a>(func,\u00a0x0[,\u00a0args,\u00a0Dfun,\u00a0full_output,\u00a0\u2026])</p></td>\n<td><p>Minimize the sum of squares of a set of equations.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.multi_voxel_fit\" title=\"dipy.reconst.forecast.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.optional_package\" title=\"dipy.reconst.forecast.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.psi_l\" title=\"dipy.reconst.forecast.psi_l\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">psi_l</span></code></a>(l,\u00a0b)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.real_sph_harm\" title=\"dipy.reconst.forecast.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.rho_matrix\" title=\"dipy.reconst.forecast.rho_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rho_matrix</span></code></a>(sh_order,\u00a0vecs)</p></td>\n<td><p>Compute the SH matrix <span class=\"math notranslate nohighlight\">\\(\\rho\\)</span></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.warn\" title=\"dipy.reconst.forecast.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.fwdti\">\n<span id=\"module-reconst-fwdti\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.fwdti</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.fwdti\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting tensors without free water\ncontamination</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit\" title=\"dipy.reconst.fwdti.FreeWaterTensorFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p>Class for fitting the Free Water Tensor Model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel\" title=\"dipy.reconst.fwdti.FreeWaterTensorModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorModel</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Class for the Free Water Elimination Diffusion Tensor Model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.ReconstModel\" title=\"dipy.reconst.fwdti.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit\" title=\"dipy.reconst.fwdti.TensorFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a>(model,\u00a0model_params[,\u00a0model_S0])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.check_multi_b\" title=\"dipy.reconst.fwdti.check_multi_b\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">check_multi_b</span></code></a>(gtab,\u00a0n_bvals[,\u00a0non_zero,\u00a0bmag])</p></td>\n<td><p>Check if you have enough different b-values in your gradient table</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.cholesky_to_lower_triangular\" title=\"dipy.reconst.fwdti.cholesky_to_lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cholesky_to_lower_triangular</span></code></a>(R)</p></td>\n<td><p>Convert Cholesky decompostion elements to the diffusion tensor elements</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.decompose_tensor\" title=\"dipy.reconst.fwdti.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a>(tensor[,\u00a0min_diffusivity])</p></td>\n<td><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.design_matrix\" title=\"dipy.reconst.fwdti.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a>(gtab[,\u00a0dtype])</p></td>\n<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.from_lower_triangular\" title=\"dipy.reconst.fwdti.from_lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">from_lower_triangular</span></code></a>(D)</p></td>\n<td><p>Returns a tensor given the six unique tensor elements</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.fwdti_prediction\" title=\"dipy.reconst.fwdti.fwdti_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fwdti_prediction</span></code></a>(params,\u00a0gtab[,\u00a0S0,\u00a0Diso])</p></td>\n<td><p>Signal prediction given the free water DTI model parameters.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.lower_triangular\" title=\"dipy.reconst.fwdti.lower_triangular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lower_triangular</span></code></a>(tensor[,\u00a0b0])</p></td>\n<td><p>Returns the six lower triangular values of the tensor and a dummy variable if b0 is not None</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.lower_triangular_to_cholesky\" title=\"dipy.reconst.fwdti.lower_triangular_to_cholesky\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lower_triangular_to_cholesky</span></code></a>(tensor_elements)</p></td>\n<td><p>Performs Cholesky decomposition of the diffusion tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.multi_voxel_fit\" title=\"dipy.reconst.fwdti.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.ndindex\" title=\"dipy.reconst.fwdti.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.nls_fit_tensor\" title=\"dipy.reconst.fwdti.nls_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nls_fit_tensor</span></code></a>(gtab,\u00a0data[,\u00a0mask,\u00a0Diso,\u00a0\u2026])</p></td>\n<td><p>Fit the water elimination tensor model using the non-linear least-squares.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.nls_iter\" title=\"dipy.reconst.fwdti.nls_iter\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nls_iter</span></code></a>(design_matrix,\u00a0sig,\u00a0S0[,\u00a0Diso,\u00a0\u2026])</p></td>\n<td><p>Applies non linear least squares fit of the water free elimination model to single voxel signals.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.vec_val_vect\" title=\"dipy.reconst.fwdti.vec_val_vect\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">vec_val_vect</span></code></a></p></td>\n<td><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.wls_fit_tensor\" title=\"dipy.reconst.fwdti.wls_fit_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_fit_tensor</span></code></a>(gtab,\u00a0data[,\u00a0Diso,\u00a0mask,\u00a0\u2026])</p></td>\n<td><p>Computes weighted least squares (WLS) fit to calculate self-diffusion tensor using a linear regression model <a class=\"reference internal\" href=\"#r78c063b823b9-1\" id=\"id32\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.wls_iter\" title=\"dipy.reconst.fwdti.wls_iter\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_iter</span></code></a>(design_matrix,\u00a0sig,\u00a0S0[,\u00a0Diso,\u00a0\u2026])</p></td>\n<td><p>Applies weighted linear least squares fit of the water free elimination model to single voxel signals.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.gqi\">\n<span id=\"module-reconst-gqi\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.gqi</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.gqi\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for generalized q-sampling</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.Cache\" title=\"dipy.reconst.gqi.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit\" title=\"dipy.reconst.gqi.GeneralizedQSamplingFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel\" title=\"dipy.reconst.gqi.GeneralizedQSamplingModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingModel</span></code></a>(gtab[,\u00a0method,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfFit\" title=\"dipy.reconst.gqi.OdfFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfModel\" title=\"dipy.reconst.gqi.OdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a>(gtab)</p></td>\n<td><p>An abstract class to be sub-classed by specific odf models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.equatorial_maximum\" title=\"dipy.reconst.gqi.equatorial_maximum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">equatorial_maximum</span></code></a>(vertices,\u00a0odf,\u00a0pole,\u00a0width)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.equatorial_zone_vertices\" title=\"dipy.reconst.gqi.equatorial_zone_vertices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">equatorial_zone_vertices</span></code></a>(vertices,\u00a0pole[,\u00a0width])</p></td>\n<td><p>finds the \u2018vertices\u2019 in the equatorial zone conjugate to \u2018pole\u2019 with width half \u2018width\u2019 degrees</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.gfa\" title=\"dipy.reconst.gqi.gfa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gfa</span></code></a>(samples)</p></td>\n<td><p>The general fractional anisotropy of a function evaluated on the unit sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.local_maxima\" title=\"dipy.reconst.gqi.local_maxima\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">local_maxima</span></code></a></p></td>\n<td><p>Local maxima of a function evaluated on a discrete set of points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.multi_voxel_fit\" title=\"dipy.reconst.gqi.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.normalize_qa\" title=\"dipy.reconst.gqi.normalize_qa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_qa</span></code></a>(qa[,\u00a0max_qa])</p></td>\n<td><p>Normalize quantitative anisotropy.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.npa\" title=\"dipy.reconst.gqi.npa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">npa</span></code></a>(self,\u00a0odf[,\u00a0width])</p></td>\n<td><p>non-parametric anisotropy</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.odf_sum\" title=\"dipy.reconst.gqi.odf_sum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_sum</span></code></a>(odf)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.patch_maximum\" title=\"dipy.reconst.gqi.patch_maximum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">patch_maximum</span></code></a>(vertices,\u00a0odf,\u00a0pole,\u00a0width)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.patch_sum\" title=\"dipy.reconst.gqi.patch_sum\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">patch_sum</span></code></a>(vertices,\u00a0odf,\u00a0pole,\u00a0width)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.patch_vertices\" title=\"dipy.reconst.gqi.patch_vertices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">patch_vertices</span></code></a>(vertices,\u00a0pole,\u00a0width)</p></td>\n<td><p>find \u2018vertices\u2019 within the cone of \u2018width\u2019 degrees around \u2018pole\u2019</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.polar_zone_vertices\" title=\"dipy.reconst.gqi.polar_zone_vertices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">polar_zone_vertices</span></code></a>(vertices,\u00a0pole[,\u00a0width])</p></td>\n<td><p>finds the \u2018vertices\u2019 in the equatorial band around the \u2018pole\u2019 of radius \u2018width\u2019 degrees</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.remove_similar_vertices\" title=\"dipy.reconst.gqi.remove_similar_vertices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">remove_similar_vertices</span></code></a></p></td>\n<td><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.squared_radial_component\" title=\"dipy.reconst.gqi.squared_radial_component\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">squared_radial_component</span></code></a>(x[,\u00a0tol])</p></td>\n<td><p>Part of the GQI2 integral</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.triple_odf_maxima\" title=\"dipy.reconst.gqi.triple_odf_maxima\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">triple_odf_maxima</span></code></a>(vertices,\u00a0odf,\u00a0width)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.upper_hemi_map\" title=\"dipy.reconst.gqi.upper_hemi_map\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">upper_hemi_map</span></code></a>(v)</p></td>\n<td><p>maps a 3-vector into the z-upper hemisphere</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.ivim\">\n<span id=\"module-reconst-ivim\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.ivim</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.ivim\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting ivim model</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimFit\" title=\"dipy.reconst.ivim.IvimFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IvimFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR\" title=\"dipy.reconst.ivim.IvimModelTRR\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IvimModelTRR</span></code></a>(gtab[,\u00a0split_b_D,\u00a0split_b_S0,\u00a0\u2026])</p></td>\n<td><p>Ivim model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP\" title=\"dipy.reconst.ivim.IvimModelVP\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IvimModelVP</span></code></a>(gtab[,\u00a0bounds,\u00a0maxiter,\u00a0xtol])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.LooseVersion\" title=\"dipy.reconst.ivim.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.ReconstModel\" title=\"dipy.reconst.ivim.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModel\" title=\"dipy.reconst.ivim.IvimModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IvimModel</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Selector function to switch between the 2-stage Trust-Region Reflective based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the Variable Projections based fitting method: <cite>varpro</cite>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.differential_evolution\" title=\"dipy.reconst.ivim.differential_evolution\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">differential_evolution</span></code></a>(func,\u00a0bounds[,\u00a0args,\u00a0\u2026])</p></td>\n<td><p>Finds the global minimum of a multivariate function.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.f_D_star_error\" title=\"dipy.reconst.ivim.f_D_star_error\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">f_D_star_error</span></code></a>(params,\u00a0gtab,\u00a0signal,\u00a0S0,\u00a0D)</p></td>\n<td><p>Error function used to fit f and D_star keeping S0 and D fixed</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.f_D_star_prediction\" title=\"dipy.reconst.ivim.f_D_star_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">f_D_star_prediction</span></code></a>(params,\u00a0gtab,\u00a0S0,\u00a0D)</p></td>\n<td><p>Function used to predict IVIM signal when S0 and D are known by considering f and D_star as the unknown parameters.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.ivim_model_selector\" title=\"dipy.reconst.ivim.ivim_model_selector\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ivim_model_selector</span></code></a>(gtab[,\u00a0fit_method])</p></td>\n<td><p>Selector function to switch between the 2-stage Trust-Region Reflective based NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the Variable Projections based fitting method: <cite>varpro</cite>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.ivim_prediction\" title=\"dipy.reconst.ivim.ivim_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ivim_prediction</span></code></a>(params,\u00a0gtab)</p></td>\n<td><p>The Intravoxel incoherent motion (IVIM) model function.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.least_squares\" title=\"dipy.reconst.ivim.least_squares\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">least_squares</span></code></a>(fun,\u00a0x0[,\u00a0jac,\u00a0bounds,\u00a0\u2026])</p></td>\n<td><p>Solve a nonlinear least-squares problem with bounds on the variables.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.multi_voxel_fit\" title=\"dipy.reconst.ivim.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.optional_package\" title=\"dipy.reconst.ivim.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.mapmri\">\n<span id=\"module-reconst-mapmri\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.mapmri</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.mapmri\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Cache\" title=\"dipy.reconst.mapmri.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.LooseVersion\" title=\"dipy.reconst.mapmri.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit\" title=\"dipy.reconst.mapmri.MapmriFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MapmriFit</span></code></a>(model,\u00a0mapmri_coef,\u00a0mu,\u00a0R,\u00a0lopt[,\u00a0\u2026])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriModel\" title=\"dipy.reconst.mapmri.MapmriModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MapmriModel</span></code></a>(gtab[,\u00a0radial_order,\u00a0\u2026])</p></td>\n<td><p>Mean Apparent Propagator MRI (MAPMRI) <a class=\"reference internal\" href=\"#rb71d87403e8f-1\" id=\"id33\">[1]</a> of the diffusion signal.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Optimizer\" title=\"dipy.reconst.mapmri.Optimizer\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Optimizer</span></code></a>(fun,\u00a0x0[,\u00a0args,\u00a0method,\u00a0jac,\u00a0\u2026])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.ReconstFit\" title=\"dipy.reconst.mapmri.ReconstFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p>Abstract class which holds the fit result of ReconstModel</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.ReconstModel\" title=\"dipy.reconst.mapmri.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.b_mat\" title=\"dipy.reconst.mapmri.b_mat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">b_mat</span></code></a>(index_matrix)</p></td>\n<td><p>Calculates the B coefficients from <a class=\"reference internal\" href=\"#rcb3260c94f80-1\" id=\"id34\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.b_mat_isotropic\" title=\"dipy.reconst.mapmri.b_mat_isotropic\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">b_mat_isotropic</span></code></a>(index_matrix)</p></td>\n<td><p>Calculates the isotropic B coefficients from <a class=\"reference internal\" href=\"#r21c472b0c767-1\" id=\"id35\">[1]</a> Fig 8.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.binomialfloat\" title=\"dipy.reconst.mapmri.binomialfloat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">binomialfloat</span></code></a>(n,\u00a0k)</p></td>\n<td><p>Custom Binomial function</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.cart2sphere\" title=\"dipy.reconst.mapmri.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.create_rspace\" title=\"dipy.reconst.mapmri.create_rspace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">create_rspace</span></code></a>(gridsize,\u00a0radius_max)</p></td>\n<td><p>Create the real space table, that contains the points in which to compute the pdf.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.delta\" title=\"dipy.reconst.mapmri.delta\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">delta</span></code></a>(n,\u00a0m)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.factorial2\" title=\"dipy.reconst.mapmri.factorial2\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">factorial2</span></code></a>(n[,\u00a0exact])</p></td>\n<td><p>Double factorial.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.gcv_cost_function\" title=\"dipy.reconst.mapmri.gcv_cost_function\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gcv_cost_function</span></code></a>(weight,\u00a0args)</p></td>\n<td><p>The GCV cost function that is iterated [4].</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.generalized_crossvalidation\" title=\"dipy.reconst.mapmri.generalized_crossvalidation\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">generalized_crossvalidation</span></code></a>(data,\u00a0M,\u00a0LR[,\u00a0\u2026])</p></td>\n<td><p>Generalized Cross Validation Function <span id=\"id36\">[Rb690cd738504-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.generalized_crossvalidation_array\" title=\"dipy.reconst.mapmri.generalized_crossvalidation_array\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">generalized_crossvalidation_array</span></code></a>(data,\u00a0M,\u00a0LR)</p></td>\n<td><p>Generalized Cross Validation Function <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id37\">1</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.genlaguerre\" title=\"dipy.reconst.mapmri.genlaguerre\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">genlaguerre</span></code></a>(n,\u00a0alpha[,\u00a0monic])</p></td>\n<td><p>Generalized (associated) Laguerre polynomial.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.gradient_table\" title=\"dipy.reconst.mapmri.gradient_table\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table</span></code></a>(bvals[,\u00a0bvecs,\u00a0big_delta,\u00a0\u2026])</p></td>\n<td><p>A general function for creating diffusion MR gradients.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.hermite\" title=\"dipy.reconst.mapmri.hermite\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hermite</span></code></a>(n[,\u00a0monic])</p></td>\n<td><p>Physicist\u2019s Hermite polynomial.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.isotropic_scale_factor\" title=\"dipy.reconst.mapmri.isotropic_scale_factor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">isotropic_scale_factor</span></code></a>(mu_squared)</p></td>\n<td><p>Estimated isotropic scaling factor _[1] Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.map_laplace_s\" title=\"dipy.reconst.mapmri.map_laplace_s\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">map_laplace_s</span></code></a>(n,\u00a0m)</p></td>\n<td><p>R(m,n) static matrix for Laplacian regularization <span id=\"id38\">[R932dd40ca52e-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.map_laplace_t\" title=\"dipy.reconst.mapmri.map_laplace_t\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">map_laplace_t</span></code></a>(n,\u00a0m)</p></td>\n<td><p>L(m, n) static matrix for Laplacian regularization <span id=\"id39\">[Reb78d789d6c4-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.map_laplace_u\" title=\"dipy.reconst.mapmri.map_laplace_u\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">map_laplace_u</span></code></a>(n,\u00a0m)</p></td>\n<td><p>S(n, m) static matrix for Laplacian regularization <span id=\"id40\">[Rb93dd9dab8c9-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_STU_reg_matrices\" title=\"dipy.reconst.mapmri.mapmri_STU_reg_matrices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_STU_reg_matrices</span></code></a>(radial_order)</p></td>\n<td><p>Generate the static portions of the Laplacian regularization matrix according to <span id=\"id41\">[R1d585103467a-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_index_matrix\" title=\"dipy.reconst.mapmri.mapmri_index_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_index_matrix</span></code></a>(radial_order)</p></td>\n<td><p>Calculates the indices for the MAPMRI <a class=\"reference internal\" href=\"#rb85ba44932df-1\" id=\"id42\">[1]</a> basis in x, y and z.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent\" title=\"dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_K_mu_dependent</span></code></a>(\u2026)</p></td>\n<td><p>Computes mu dependent part of M.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent\" title=\"dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_K_mu_independent</span></code></a>(\u2026)</p></td>\n<td><p>Computes mu independent part of K.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent\" title=\"dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_M_mu_dependent</span></code></a>(\u2026)</p></td>\n<td><p>Computed the mu dependent part of the signal design matrix.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent\" title=\"dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_M_mu_independent</span></code></a>(\u2026)</p></td>\n<td><p>Computed the mu independent part of the signal design matrix.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_index_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_index_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_index_matrix</span></code></a>(radial_order)</p></td>\n<td><p>Calculates the indices for the isotropic MAPMRI basis <a class=\"reference internal\" href=\"#rc015c0dc1977-1\" id=\"id43\">[1]</a> Fig 8.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_laplacian_reg_matrix</span></code></a>(\u2026)</p></td>\n<td><p>Computes the Laplacian regularization matrix for MAP-MRI\u2019s isotropic implementation <span id=\"id44\">[R156f27ca005f-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</span></code></a>(\u2026)</p></td>\n<td><p>Computes the Laplacian regularization matrix for MAP-MRI\u2019s isotropic implementation <span id=\"id45\">[Rdcc29394f577-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_odf_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_odf_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Compute the isotropic MAPMRI ODF matrix <a class=\"reference internal\" href=\"#rf7e027186c88-1\" id=\"id46\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_odf_sh_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Compute the isotropic MAPMRI ODF matrix <a class=\"reference internal\" href=\"#r18e181ea8d0c-1\" id=\"id47\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_phi_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_phi_matrix</span></code></a>(radial_order,\u00a0mu,\u00a0q)</p></td>\n<td><p>Three dimensional isotropic MAPMRI signal basis function from <a class=\"reference internal\" href=\"#r7485962ae8ea-1\" id=\"id48\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix\" title=\"dipy.reconst.mapmri.mapmri_isotropic_psi_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_psi_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Three dimensional isotropic MAPMRI propagator basis function from <a class=\"reference internal\" href=\"#r77a51da75e29-1\" id=\"id49\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis\" title=\"dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_radial_pdf_basis</span></code></a>(j,\u00a0l,\u00a0mu,\u00a0r)</p></td>\n<td><p>Radial part of the isotropic 1D-SHORE propagator basis <a class=\"reference internal\" href=\"#r889cbb1a52b7-1\" id=\"id50\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis\" title=\"dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_isotropic_radial_signal_basis</span></code></a>(j,\u00a0l,\u00a0\u2026)</p></td>\n<td><p>Radial part of the isotropic 1D-SHORE signal basis <a class=\"reference internal\" href=\"#r87b99f9c6ca2-1\" id=\"id51\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix\" title=\"dipy.reconst.mapmri.mapmri_laplacian_reg_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_laplacian_reg_matrix</span></code></a>(ind_mat,\u00a0mu,\u00a0\u2026)</p></td>\n<td><p>Put the Laplacian regularization matrix together <span id=\"id52\">[Rc66aaccd07c1-1]</span> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_odf_matrix\" title=\"dipy.reconst.mapmri.mapmri_odf_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_odf_matrix</span></code></a>(radial_order,\u00a0mu,\u00a0s,\u00a0vertices)</p></td>\n<td><p>Compute the MAPMRI ODF matrix <a class=\"reference internal\" href=\"#re26b9b8173e7-1\" id=\"id53\">[1]</a>  Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_phi_1d\" title=\"dipy.reconst.mapmri.mapmri_phi_1d\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_phi_1d</span></code></a>(n,\u00a0q,\u00a0mu)</p></td>\n<td><p>One dimensional MAPMRI basis function from <a class=\"reference internal\" href=\"#r76e82749e6a0-1\" id=\"id54\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_phi_matrix\" title=\"dipy.reconst.mapmri.mapmri_phi_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_phi_matrix</span></code></a>(radial_order,\u00a0mu,\u00a0q_gradients)</p></td>\n<td><p>Compute the MAPMRI phi matrix for the signal <a class=\"reference internal\" href=\"#r3a5a50d36842-1\" id=\"id55\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_psi_1d\" title=\"dipy.reconst.mapmri.mapmri_psi_1d\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_psi_1d</span></code></a>(n,\u00a0x,\u00a0mu)</p></td>\n<td><p>One dimensional MAPMRI propagator basis function from <a class=\"reference internal\" href=\"#rb9b07bc1eb95-1\" id=\"id56\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mapmri_psi_matrix\" title=\"dipy.reconst.mapmri.mapmri_psi_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_psi_matrix</span></code></a>(radial_order,\u00a0mu,\u00a0rgrad)</p></td>\n<td><p>Compute the MAPMRI psi matrix for the propagator <a class=\"reference internal\" href=\"#rf11279199519-1\" id=\"id57\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.mfactorial\" title=\"dipy.reconst.mapmri.mfactorial\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mfactorial</span></code></a>(x,\u00a0/)</p></td>\n<td><p>Find x!.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.multi_voxel_fit\" title=\"dipy.reconst.mapmri.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.optional_package\" title=\"dipy.reconst.mapmri.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.real_sph_harm\" title=\"dipy.reconst.mapmri.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.sfactorial\" title=\"dipy.reconst.mapmri.sfactorial\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sfactorial</span></code></a>(n[,\u00a0exact])</p></td>\n<td><p>The factorial of a number or array of numbers.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.sph_harm_ind_list\" title=\"dipy.reconst.mapmri.sph_harm_ind_list\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sph_harm_ind_list</span></code></a>(sh_order[,\u00a0full_basis])</p></td>\n<td><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical harmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.warn\" title=\"dipy.reconst.mapmri.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.mcsd\">\n<span id=\"module-reconst-mcsd\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.mcsd</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.mcsd\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.GradientTable\" title=\"dipy.reconst.mcsd.GradientTable\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a>(gradients[,\u00a0big_delta,\u00a0\u2026])</p></td>\n<td><p>Diffusion gradient information</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.LooseVersion\" title=\"dipy.reconst.mcsd.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MSDeconvFit\" title=\"dipy.reconst.mcsd.MSDeconvFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MSDeconvFit</span></code></a>(model,\u00a0coeff,\u00a0mask)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel\" title=\"dipy.reconst.mcsd.MultiShellDeconvModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MultiShellDeconvModel</span></code></a>(gtab,\u00a0response[,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellResponse\" title=\"dipy.reconst.mcsd.MultiShellResponse\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MultiShellResponse</span></code></a>(response,\u00a0sh_order,\u00a0shells)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.QpFitter\" title=\"dipy.reconst.mcsd.QpFitter\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QpFitter</span></code></a>(X,\u00a0reg)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.TensorModel\" title=\"dipy.reconst.mcsd.TensorModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a>(gtab[,\u00a0fit_method,\u00a0return_S0_hat])</p></td>\n<td><p>Diffusion Tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.auto_response_msmt\" title=\"dipy.reconst.mcsd.auto_response_msmt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_response_msmt</span></code></a>(gtab,\u00a0data[,\u00a0tol,\u00a0\u2026])</p></td>\n<td><p>Automatic estimation of multi-shell multi-tissue (msmt) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.fractional_anisotropy\" title=\"dipy.reconst.mcsd.fractional_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fractional_anisotropy</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.get_bval_indices\" title=\"dipy.reconst.mcsd.get_bval_indices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">get_bval_indices</span></code></a>(bvals,\u00a0bval[,\u00a0tol])</p></td>\n<td><p>Get indices where the b-value is <cite>bval</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.gradient_table\" title=\"dipy.reconst.mcsd.gradient_table\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table</span></code></a>(bvals[,\u00a0bvecs,\u00a0big_delta,\u00a0\u2026])</p></td>\n<td><p>A general function for creating diffusion MR gradients.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.mask_for_response_msmt\" title=\"dipy.reconst.mcsd.mask_for_response_msmt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mask_for_response_msmt</span></code></a>(gtab,\u00a0data[,\u00a0\u2026])</p></td>\n<td><p>Computation of masks for multi-shell multi-tissue (msmt) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.mean_diffusivity\" title=\"dipy.reconst.mcsd.mean_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_diffusivity</span></code></a>(evals[,\u00a0axis])</p></td>\n<td><p>Mean Diffusivity (MD) of a diffusion tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.multi_shell_fiber_response\" title=\"dipy.reconst.mcsd.multi_shell_fiber_response\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_shell_fiber_response</span></code></a>(sh_order,\u00a0bvals,\u00a0\u2026)</p></td>\n<td><p>Fiber response function estimation for multi-shell data.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.multi_tissue_basis\" title=\"dipy.reconst.mcsd.multi_tissue_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_tissue_basis</span></code></a>(gtab,\u00a0sh_order,\u00a0iso_comp)</p></td>\n<td><p>Builds a basis for multi-shell multi-tissue CSD model.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.multi_voxel_fit\" title=\"dipy.reconst.mcsd.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.optional_package\" title=\"dipy.reconst.mcsd.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.response_from_mask_msmt\" title=\"dipy.reconst.mcsd.response_from_mask_msmt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">response_from_mask_msmt</span></code></a>(gtab,\u00a0data,\u00a0mask_wm,\u00a0\u2026)</p></td>\n<td><p>Computation of multi-shell multi-tissue (msmt) response</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.response_from_mask_ssst\" title=\"dipy.reconst.mcsd.response_from_mask_ssst\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">response_from_mask_ssst</span></code></a>(gtab,\u00a0data,\u00a0mask)</p></td>\n<td><p>Computation of single-shell single-tissue (ssst) response</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.single_tensor\" title=\"dipy.reconst.mcsd.single_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">single_tensor</span></code></a>(gtab[,\u00a0S0,\u00a0evals,\u00a0evecs,\u00a0snr])</p></td>\n<td><p>Simulate diffusion-weighted signals with a single tensor.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.solve_qp\" title=\"dipy.reconst.mcsd.solve_qp\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">solve_qp</span></code></a>(P,\u00a0Q,\u00a0G,\u00a0H)</p></td>\n<td><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.unique_bvals_tolerance\" title=\"dipy.reconst.mcsd.unique_bvals_tolerance\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">unique_bvals_tolerance</span></code></a>(bvals[,\u00a0tol])</p></td>\n<td><p>Gives the unique b-values of the data, within a tolerance gap</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.msdki\">\n<span id=\"module-reconst-msdki\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.msdki</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.msdki\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Classes and functions for fitting the mean signal diffusion kurtosis\nmodel</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisFit</span></code></a>(model,\u00a0model_params)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisModel</span></code></a>(gtab[,\u00a0bmag,\u00a0\u2026])</p></td>\n<td><p>Mean signal Diffusion Kurtosis Model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.ReconstModel\" title=\"dipy.reconst.msdki.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.auto_attr\" title=\"dipy.reconst.msdki.auto_attr\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_attr</span></code></a>(func)</p></td>\n<td><p>Decorator to create OneTimeProperty attributes.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.awf_from_msk\" title=\"dipy.reconst.msdki.awf_from_msk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">awf_from_msk</span></code></a>(msk[,\u00a0mask])</p></td>\n<td><p>Computes the axonal water fraction from the mean signal kurtosis assuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#r01d7e07fd924-1\" id=\"id58\">[1]</a>, <a class=\"reference internal\" href=\"#r01d7e07fd924-2\" id=\"id59\">[2]</a></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.check_multi_b\" title=\"dipy.reconst.msdki.check_multi_b\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">check_multi_b</span></code></a>(gtab,\u00a0n_bvals[,\u00a0non_zero,\u00a0bmag])</p></td>\n<td><p>Check if you have enough different b-values in your gradient table</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.design_matrix\" title=\"dipy.reconst.msdki.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a>(ubvals)</p></td>\n<td><p>Constructs design matrix for the mean signal diffusion kurtosis model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.mean_signal_bvalue\" title=\"dipy.reconst.msdki.mean_signal_bvalue\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_signal_bvalue</span></code></a>(data,\u00a0gtab[,\u00a0bmag])</p></td>\n<td><p>Computes the average signal across different diffusion directions for each unique b-value</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.msdki_prediction\" title=\"dipy.reconst.msdki.msdki_prediction\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msdki_prediction</span></code></a>(msdki_params,\u00a0gtab[,\u00a0S0])</p></td>\n<td><p>Predict the mean signal given the parameters of the mean signal DKI, an GradientTable object and S0 signal.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.msk_from_awf\" title=\"dipy.reconst.msdki.msk_from_awf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msk_from_awf</span></code></a>(f)</p></td>\n<td><p>Computes mean signal kurtosis from axonal water fraction estimates of the SMT2 model</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.ndindex\" title=\"dipy.reconst.msdki.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.round_bvals\" title=\"dipy.reconst.msdki.round_bvals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">round_bvals</span></code></a>(bvals[,\u00a0bmag])</p></td>\n<td><p>\u201cThis function rounds the b-values</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.unique_bvals_magnitude\" title=\"dipy.reconst.msdki.unique_bvals_magnitude\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">unique_bvals_magnitude</span></code></a>(bvals[,\u00a0bmag,\u00a0rbvals])</p></td>\n<td><p>This function gives the unique rounded b-values of the data</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.wls_fit_msdki\" title=\"dipy.reconst.msdki.wls_fit_msdki\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_fit_msdki</span></code></a>(design_matrix,\u00a0msignal,\u00a0ng[,\u00a0\u2026])</p></td>\n<td><p>Fits the mean signal diffusion kurtosis imaging based on a weighted least square solution <a class=\"reference internal\" href=\"#rc9bf1f124f2b-1\" id=\"id60\">[1]</a>.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.multi_voxel\">\n<span id=\"module-reconst-multi-voxel\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.multi_voxel</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.multi_voxel\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Tools to easily make multi voxel models</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.CallableArray\" title=\"dipy.reconst.multi_voxel.CallableArray\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">CallableArray</span></code></a></p></td>\n<td><p>An array which can be called like a function</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit\" title=\"dipy.reconst.multi_voxel.MultiVoxelFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">MultiVoxelFit</span></code></a>(model,\u00a0fit_array,\u00a0mask)</p></td>\n<td><p>Holds an array of fits and allows access to their attributes and methods</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.ReconstFit\" title=\"dipy.reconst.multi_voxel.ReconstFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p>Abstract class which holds the fit result of ReconstModel</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.as_strided\" title=\"dipy.reconst.multi_voxel.as_strided\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">as_strided</span></code></a>(x[,\u00a0shape,\u00a0strides,\u00a0subok,\u00a0writeable])</p></td>\n<td><p>Create a view into the array with the given shape and strides.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.multi_voxel_fit\" title=\"dipy.reconst.multi_voxel.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.ndindex\" title=\"dipy.reconst.multi_voxel.ndindex\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndindex</span></code></a>(shape)</p></td>\n<td><p>An N-dimensional iterator object to index arrays.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.odf\">\n<span id=\"module-reconst-odf\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.odf</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.odf\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a>(gtab)</p></td>\n<td><p>An abstract class to be sub-classed by specific odf models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.ReconstFit\" title=\"dipy.reconst.odf.ReconstFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p>Abstract class which holds the fit result of ReconstModel</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.ReconstModel\" title=\"dipy.reconst.odf.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.gfa\" title=\"dipy.reconst.odf.gfa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gfa</span></code></a>(samples)</p></td>\n<td><p>The general fractional anisotropy of a function evaluated on the unit sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.minmax_normalize\" title=\"dipy.reconst.odf.minmax_normalize\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">minmax_normalize</span></code></a>(samples[,\u00a0out])</p></td>\n<td><p>Min-max normalization of a function evaluated on the unit sphere</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.peak_direction_getter\">\n<span id=\"module-reconst-peak-direction-getter\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.peak_direction_getter</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.peak_direction_getter\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.peak_direction_getter.EuDXDirectionGetter\" title=\"dipy.reconst.peak_direction_getter.EuDXDirectionGetter\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">EuDXDirectionGetter</span></code></a>(*args,\u00a0**kwargs)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.peak_direction_getter.warn\" title=\"dipy.reconst.peak_direction_getter.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.qtdmri\">\n<span id=\"module-reconst-qtdmri\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.qtdmri</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.qtdmri\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.Cache\" title=\"dipy.reconst.qtdmri.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.LooseVersion\" title=\"dipy.reconst.qtdmri.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit\" title=\"dipy.reconst.qtdmri.QtdmriFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QtdmriFit</span></code></a>(model,\u00a0qtdmri_coef,\u00a0us,\u00a0ut,\u00a0\u2026)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriModel\" title=\"dipy.reconst.qtdmri.QtdmriModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QtdmriModel</span></code></a>(gtab[,\u00a0radial_order,\u00a0\u2026])</p></td>\n<td><p>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent the q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization q and diffusion time <span class=\"math notranslate nohighlight\">\\(\\tau\\)</span>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.GCV_cost_function\" title=\"dipy.reconst.qtdmri.GCV_cost_function\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">GCV_cost_function</span></code></a>(weight,\u00a0arguments)</p></td>\n<td><p>Generalized Cross Validation Function that is iterated [1].</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.H\" title=\"dipy.reconst.qtdmri.H\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">H</span></code></a>(value)</p></td>\n<td><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.angular_basis_EAP_opt\" title=\"dipy.reconst.qtdmri.angular_basis_EAP_opt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">angular_basis_EAP_opt</span></code></a>(j,\u00a0l,\u00a0m,\u00a0r,\u00a0theta,\u00a0phi)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.angular_basis_opt\" title=\"dipy.reconst.qtdmri.angular_basis_opt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">angular_basis_opt</span></code></a>(l,\u00a0m,\u00a0q,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Angular basis independent of spatial scaling factor us.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.cart2sphere\" title=\"dipy.reconst.qtdmri.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.create_rt_space_grid\" title=\"dipy.reconst.qtdmri.create_rt_space_grid\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">create_rt_space_grid</span></code></a>(grid_size_r,\u00a0\u2026)</p></td>\n<td><p>Generates EAP grid (for potential positivity constraint).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.design_matrix_spatial\" title=\"dipy.reconst.qtdmri.design_matrix_spatial\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix_spatial</span></code></a>(bvecs,\u00a0qvals[,\u00a0dtype])</p></td>\n<td><p>Constructs design matrix for DTI weighted least squares or least squares fitting.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.elastic_crossvalidation\" title=\"dipy.reconst.qtdmri.elastic_crossvalidation\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">elastic_crossvalidation</span></code></a>(b0s_mask,\u00a0E,\u00a0M,\u00a0L,\u00a0lopt)</p></td>\n<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization when also Laplacian regularization is used.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.factorial\" title=\"dipy.reconst.qtdmri.factorial\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">factorial</span></code></a>(n[,\u00a0exact])</p></td>\n<td><p>The factorial of a number or array of numbers.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.factorial2\" title=\"dipy.reconst.qtdmri.factorial2\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">factorial2</span></code></a>(n[,\u00a0exact])</p></td>\n<td><p>Double factorial.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.fmin_l_bfgs_b\" title=\"dipy.reconst.qtdmri.fmin_l_bfgs_b\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fmin_l_bfgs_b</span></code></a>(func,\u00a0x0[,\u00a0fprime,\u00a0args,\u00a0\u2026])</p></td>\n<td><p>Minimize a function func using the L-BFGS-B algorithm.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.generalized_crossvalidation\" title=\"dipy.reconst.qtdmri.generalized_crossvalidation\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">generalized_crossvalidation</span></code></a>(data,\u00a0M,\u00a0LR[,\u00a0\u2026])</p></td>\n<td><p>Generalized Cross Validation Function [1].</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.genlaguerre\" title=\"dipy.reconst.qtdmri.genlaguerre\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">genlaguerre</span></code></a>(n,\u00a0alpha[,\u00a0monic])</p></td>\n<td><p>Generalized (associated) Laguerre polynomial.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs\" title=\"dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table_from_gradient_strength_bvecs</span></code></a>(\u2026)</p></td>\n<td><p>A general function for creating diffusion MR gradients.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.l1_crossvalidation\" title=\"dipy.reconst.qtdmri.l1_crossvalidation\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">l1_crossvalidation</span></code></a>(b0s_mask,\u00a0E,\u00a0M[,\u00a0\u2026])</p></td>\n<td><p>cross-validation function to find the optimal weight of alpha for sparsity regularization</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.multi_voxel_fit\" title=\"dipy.reconst.qtdmri.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.optional_package\" title=\"dipy.reconst.qtdmri.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part1_reg_matrix_tau\" title=\"dipy.reconst.qtdmri.part1_reg_matrix_tau\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part1_reg_matrix_tau</span></code></a>(ind_mat,\u00a0ut)</p></td>\n<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part23_iso_reg_matrix_q\" title=\"dipy.reconst.qtdmri.part23_iso_reg_matrix_q\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part23_iso_reg_matrix_q</span></code></a>(ind_mat,\u00a0us)</p></td>\n<td><p>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part23_reg_matrix_q\" title=\"dipy.reconst.qtdmri.part23_reg_matrix_q\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part23_reg_matrix_q</span></code></a>(ind_mat,\u00a0U_mat,\u00a0T_mat,\u00a0us)</p></td>\n<td><p>Partial cartesian spatial Laplacian regularization matrix following second line of Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part23_reg_matrix_tau\" title=\"dipy.reconst.qtdmri.part23_reg_matrix_tau\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part23_reg_matrix_tau</span></code></a>(ind_mat,\u00a0ut)</p></td>\n<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part4_iso_reg_matrix_q\" title=\"dipy.reconst.qtdmri.part4_iso_reg_matrix_q\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part4_iso_reg_matrix_q</span></code></a>(ind_mat,\u00a0us)</p></td>\n<td><p>Partial spherical spatial Laplacian regularization matrix following the equation below Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part4_reg_matrix_q\" title=\"dipy.reconst.qtdmri.part4_reg_matrix_q\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part4_reg_matrix_q</span></code></a>(ind_mat,\u00a0U_mat,\u00a0us)</p></td>\n<td><p>Partial cartesian spatial Laplacian regularization matrix following equation Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.part4_reg_matrix_tau\" title=\"dipy.reconst.qtdmri.part4_reg_matrix_tau\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">part4_reg_matrix_tau</span></code></a>(ind_mat,\u00a0ut)</p></td>\n<td><p>Partial temporal Laplacian regularization matrix following Appendix B in [1].</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling\" title=\"dipy.reconst.qtdmri.qtdmri_anisotropic_scaling\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_anisotropic_scaling</span></code></a>(data,\u00a0q,\u00a0bvecs,\u00a0tau)</p></td>\n<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_eap_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_eap_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_eap_matrix</span></code></a>(radial_order,\u00a0time_order,\u00a0\u2026)</p></td>\n<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_eap_matrix_\" title=\"dipy.reconst.qtdmri.qtdmri_eap_matrix_\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_eap_matrix_</span></code></a>(radial_order,\u00a0time_order,\u00a0\u2026)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_index_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_index_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_index_matrix</span></code></a>(radial_order,\u00a0time_order)</p></td>\n<td><p>Computes the SHORE basis order indices according to [1].</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_eap_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_eap_matrix_</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_index_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Computes the SHORE basis order indices according to [1].</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_laplacian_reg_matrix</span></code></a>(\u2026[,\u00a0\u2026])</p></td>\n<td><p>Computes the spherical qt-dMRI Laplacian regularization matrix.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_scaling\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_scaling\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_scaling</span></code></a>(data,\u00a0q,\u00a0tau)</p></td>\n<td><p>Constructs design matrix for fitting an exponential to the diffusion time points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_signal_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_signal_matrix_</span></code></a>(\u2026[,\u00a0\u2026])</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_isotropic_to_mapmri_matrix</span></code></a>(\u2026)</p></td>\n<td><p>Generates the matrix that maps the spherical qtdmri coefficients to MAP-MRI coefficients.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_laplacian_reg_matrix</span></code></a>(ind_mat,\u00a0us,\u00a0ut)</p></td>\n<td><p>Computes the cartesian qt-dMRI Laplacian regularization matrix.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization\" title=\"dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_mapmri_isotropic_normalization</span></code></a>(j,\u00a0l,\u00a0u0)</p></td>\n<td><p>Normalization factor for Spherical MAP-MRI basis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_mapmri_normalization\" title=\"dipy.reconst.qtdmri.qtdmri_mapmri_normalization\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_mapmri_normalization</span></code></a>(mu)</p></td>\n<td><p>Normalization factor for Cartesian MAP-MRI basis.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_number_of_coefficients\" title=\"dipy.reconst.qtdmri.qtdmri_number_of_coefficients\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_number_of_coefficients</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Computes the total number of coefficients of the qtdmri basis given a radial and temporal order.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_signal_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_signal_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_signal_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Constructs the design matrix as a product of 3 separated radial, angular and temporal design matrices.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_signal_matrix_\" title=\"dipy.reconst.qtdmri.qtdmri_signal_matrix_\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_signal_matrix_</span></code></a>(radial_order,\u00a0\u2026[,\u00a0\u2026])</p></td>\n<td><p>Function to generate the qtdmri signal basis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_temporal_normalization\" title=\"dipy.reconst.qtdmri.qtdmri_temporal_normalization\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_temporal_normalization</span></code></a>(ut)</p></td>\n<td><p>Normalization factor for the temporal basis</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix\" title=\"dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_to_mapmri_matrix</span></code></a>(radial_order,\u00a0\u2026)</p></td>\n<td><p>Generates the matrix that maps the qtdmri coefficients to MAP-MRI coefficients.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.radial_basis_EAP_opt\" title=\"dipy.reconst.qtdmri.radial_basis_EAP_opt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">radial_basis_EAP_opt</span></code></a>(j,\u00a0l,\u00a0us,\u00a0r)</p></td>\n<td><p></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.radial_basis_opt\" title=\"dipy.reconst.qtdmri.radial_basis_opt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">radial_basis_opt</span></code></a>(j,\u00a0l,\u00a0us,\u00a0q)</p></td>\n<td><p>Spatial basis dependent on spatial scaling factor us</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.real_sph_harm\" title=\"dipy.reconst.qtdmri.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.temporal_basis\" title=\"dipy.reconst.qtdmri.temporal_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">temporal_basis</span></code></a>(o,\u00a0ut,\u00a0tau)</p></td>\n<td><p>Temporal basis dependent on temporal scaling factor ut</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow\" title=\"dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">visualise_gradient_table_G_Delta_rainbow</span></code></a>(gtab)</p></td>\n<td><p>This function visualizes a q-tau acquisition scheme as a function of gradient strength and pulse separation (big_delta).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.warn\" title=\"dipy.reconst.qtdmri.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.sfm\">\n<span id=\"module-reconst-sfm\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.sfm</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.sfm\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The Sparse Fascicle Model.</p>\n<p>This is an implementation of the sparse fascicle model described in\n<a class=\"reference internal\" href=\"#r204bb22f26e5-rokem2015\" id=\"id61\">[Rokem2015]</a>. The multi b-value version of this model is described in\n<a class=\"reference internal\" href=\"#r204bb22f26e5-rokem2014\" id=\"id62\">[Rokem2014]</a>.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r204bb22f26e5-rokem2015\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id61\">Rokem2015</a></span></dt>\n<dd><p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick\nN. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell\n(2015). Evaluating the accuracy of diffusion MRI models in white\nmatter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>\n</dd>\n<dt class=\"label\" id=\"r204bb22f26e5-rokem2014\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id62\">Rokem2014</a></span></dt>\n<dd><p>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco\nPestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion\nmodels at multiple b-values with cross-validation. ISMRM 2014.</p>\n</dd>\n</dl>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.Cache\" title=\"dipy.reconst.sfm.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit\" title=\"dipy.reconst.sfm.ExponentialIsotropicFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicFit</span></code></a>(model,\u00a0params)</p></td>\n<td><p>A fit to the ExponentialIsotropicModel object, based on data.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel\" title=\"dipy.reconst.sfm.ExponentialIsotropicModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicModel</span></code></a>(gtab)</p></td>\n<td><p>Representing the isotropic signal as a fit to an exponential decay function with b-values</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicFit\" title=\"dipy.reconst.sfm.IsotropicFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IsotropicFit</span></code></a>(model,\u00a0params)</p></td>\n<td><p>A fit object for representing the isotropic signal as the mean of the diffusion-weighted signal.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicModel\" title=\"dipy.reconst.sfm.IsotropicModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">IsotropicModel</span></code></a>(gtab)</p></td>\n<td><p>A base-class for the representation of isotropic signals.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ReconstFit\" title=\"dipy.reconst.sfm.ReconstFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p>Abstract class which holds the fit result of ReconstModel</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ReconstModel\" title=\"dipy.reconst.sfm.ReconstModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a>(gtab)</p></td>\n<td><p>Abstract class for signal reconstruction models</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleFit\" title=\"dipy.reconst.sfm.SparseFascicleFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SparseFascicleFit</span></code></a>(model,\u00a0beta,\u00a0S0,\u00a0iso)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleModel\" title=\"dipy.reconst.sfm.SparseFascicleModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SparseFascicleModel</span></code></a>(gtab[,\u00a0sphere,\u00a0\u2026])</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.auto_attr\" title=\"dipy.reconst.sfm.auto_attr\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_attr</span></code></a>(func)</p></td>\n<td><p>Decorator to create OneTimeProperty attributes.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.nanmean\" title=\"dipy.reconst.sfm.nanmean\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nanmean</span></code></a>(a[,\u00a0axis,\u00a0dtype,\u00a0out,\u00a0keepdims])</p></td>\n<td><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.optional_package\" title=\"dipy.reconst.sfm.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.sfm_design_matrix\" title=\"dipy.reconst.sfm.sfm_design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sfm_design_matrix</span></code></a>(gtab,\u00a0sphere,\u00a0response[,\u00a0mode])</p></td>\n<td><p>Construct the SFM design matrix</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.shm\">\n<span id=\"module-reconst-shm\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.shm</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.shm\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Tools for using spherical harmonic models to fit diffusion data.</p>\n<div class=\"section\" id=\"references\">\n<h3>References<a class=\"headerlink\" href=\"#references\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"simple\">\n<dt>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With Solid</dt><dd><p>Angle Consideration.</p>\n</dd>\n<dt>Descoteaux, M., et al. 2007. Regularized, fast, and robust analytical</dt><dd><p>Q-ball imaging.</p>\n</dd>\n<dt>Tristan-Vega, A., et al. 2010. A new methodology for estimation of fiber</dt><dd><p>populations in white matter of the brain with Funk-Radon transform.</p>\n</dd>\n<dt>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation probability</dt><dd><p>density functions in high angular resolution diffusion imaging.</p>\n</dd>\n</dl>\n<p>Note about the Transpose:\nIn the literature the matrix representation of these methods is often written\nas Y = Bx where B is some design matrix and Y and x are column vectors. In our\ncase the input data, a dwi stored as a nifti file for example, is stored as row\nvectors (ndarrays) of the form (x, y, z, n), where n is the number of diffusion\ndirections. We could transpose and reshape the data to be (n, x*y*z), so that\nwe could directly plug it into the above equation. However, I have chosen to\nkeep the data as is and implement the relevant equations rewritten in the\nfollowing form: Y.T = x.T B.T, or in python syntax data = np.dot(sh_coef, B.T)\nwhere data is Y.T and sh_coef is x.T.</p>\n</div>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.Cache\" title=\"dipy.reconst.shm.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.CsaOdfModel\" title=\"dipy.reconst.shm.CsaOdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">CsaOdfModel</span></code></a>(gtab,\u00a0sh_order[,\u00a0smooth,\u00a0\u2026])</p></td>\n<td><p>Implementation of Constant Solid Angle reconstruction method.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfFit\" title=\"dipy.reconst.shm.OdfFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a>(model,\u00a0data)</p></td>\n<td><p><p class=\"rubric\">Methods</p>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfModel\" title=\"dipy.reconst.shm.OdfModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a>(gtab)</p></td>\n<td><p>An abstract class to be sub-classed by specific odf models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.OpdtModel\" title=\"dipy.reconst.shm.OpdtModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">OpdtModel</span></code></a>(gtab,\u00a0sh_order[,\u00a0smooth,\u00a0\u2026])</p></td>\n<td><p>Implementation of Orientation Probability Density Transform reconstruction method.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"dipy.reconst.shm.QballBaseModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QballBaseModel</span></code></a>(gtab,\u00a0sh_order[,\u00a0smooth,\u00a0\u2026])</p></td>\n<td><p>To be subclassed by Qball type models.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.QballModel\" title=\"dipy.reconst.shm.QballModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">QballModel</span></code></a>(gtab,\u00a0sh_order[,\u00a0smooth,\u00a0\u2026])</p></td>\n<td><p>Implementation of regularized Qball reconstruction method.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.ResidualBootstrapWrapper\" title=\"dipy.reconst.shm.ResidualBootstrapWrapper\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ResidualBootstrapWrapper</span></code></a>(signal_object,\u00a0B,\u00a0\u2026)</p></td>\n<td><p>Returns a residual bootstrap sample of the signal_object when indexed</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit\" title=\"dipy.reconst.shm.SphHarmFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a>(model,\u00a0shm_coef,\u00a0mask)</p></td>\n<td><p>Diffusion data fit to a spherical harmonic model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a>(gtab)</p></td>\n<td><p>To be subclassed by all models that return a SphHarmFit when fit.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.anisotropic_power\" title=\"dipy.reconst.shm.anisotropic_power\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">anisotropic_power</span></code></a>(sh_coeffs[,\u00a0norm_factor,\u00a0\u2026])</p></td>\n<td><p>Calculate anisotropic power map with a given SH coefficient matrix.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.auto_attr\" title=\"dipy.reconst.shm.auto_attr\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">auto_attr</span></code></a>(func)</p></td>\n<td><p>Decorator to create OneTimeProperty attributes.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.bootstrap_data_array\" title=\"dipy.reconst.shm.bootstrap_data_array\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bootstrap_data_array</span></code></a>(data,\u00a0H,\u00a0R[,\u00a0permute])</p></td>\n<td><p>Applies the Residual Bootstraps to the data given H and R</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.bootstrap_data_voxel\" title=\"dipy.reconst.shm.bootstrap_data_voxel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">bootstrap_data_voxel</span></code></a>(data,\u00a0H,\u00a0R[,\u00a0permute])</p></td>\n<td><p>Like bootstrap_data_array but faster when for a single voxel</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.calculate_max_order\" title=\"dipy.reconst.shm.calculate_max_order\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">calculate_max_order</span></code></a>(n_coeffs[,\u00a0full_basis])</p></td>\n<td><p>Calculate the maximal harmonic order, given that you know the number of parameters that were estimated.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.cart2sphere\" title=\"dipy.reconst.shm.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.convert_sh_from_legacy\" title=\"dipy.reconst.shm.convert_sh_from_legacy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">convert_sh_from_legacy</span></code></a>(sh_coeffs,\u00a0sh_basis)</p></td>\n<td><p>Convert SH coefficients in legacy SH basis to SH coefficients of the new SH basis for <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> <a class=\"reference internal\" href=\"#r8020d68d5dcd-1\" id=\"id63\">[1]</a> or <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> [R8020d68d5dcd-2]_[R8020d68d5dcd-3]_ bases.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.convert_sh_to_full_basis\" title=\"dipy.reconst.shm.convert_sh_to_full_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">convert_sh_to_full_basis</span></code></a>(sh_coeffs)</p></td>\n<td><p>Given an array of SH coeffs from a symmetric basis, returns the coefficients for the full SH basis by filling odd order SH coefficients with zeros</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.convert_sh_to_legacy\" title=\"dipy.reconst.shm.convert_sh_to_legacy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">convert_sh_to_legacy</span></code></a>(sh_coeffs,\u00a0sh_basis[,\u00a0\u2026])</p></td>\n<td><p>Convert SH coefficients in new SH basis to SH coefficients for the legacy SH basis for <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> <a class=\"reference internal\" href=\"#r2032a14b59d6-1\" id=\"id64\">[1]</a> or <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> [R2032a14b59d6-2]_[R2032a14b59d6-3]_ bases.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.deprecate_with_version\" title=\"dipy.reconst.shm.deprecate_with_version\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">deprecate_with_version</span></code></a>(message[,\u00a0since,\u00a0\u2026])</p></td>\n<td><p>Return decorator function function for deprecation warning / error.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.forward_sdeconv_mat\" title=\"dipy.reconst.shm.forward_sdeconv_mat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">forward_sdeconv_mat</span></code></a>(r_rh,\u00a0n)</p></td>\n<td><p>Build forward spherical deconvolution matrix</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.gen_dirac\" title=\"dipy.reconst.shm.gen_dirac\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gen_dirac</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi[,\u00a0legacy])</p></td>\n<td><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.hat\" title=\"dipy.reconst.shm.hat\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hat</span></code></a>(B)</p></td>\n<td><p>Returns the hat matrix for the design matrix B</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.lazy_index\" title=\"dipy.reconst.shm.lazy_index\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lazy_index</span></code></a>(index)</p></td>\n<td><p>Produces a lazy index</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.lcr_matrix\" title=\"dipy.reconst.shm.lcr_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">lcr_matrix</span></code></a>(H)</p></td>\n<td><p>Returns a matrix for computing leveraged, centered residuals from data</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.normalize_data\" title=\"dipy.reconst.shm.normalize_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_data</span></code></a>(data,\u00a0where_b0[,\u00a0min_signal,\u00a0out])</p></td>\n<td><p>Normalizes the data with respect to the mean b0</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.order_from_ncoef\" title=\"dipy.reconst.shm.order_from_ncoef\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">order_from_ncoef</span></code></a>(ncoef[,\u00a0full_basis])</p></td>\n<td><p>Given a number <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> of coefficients, calculate back the <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.randint\" title=\"dipy.reconst.shm.randint\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">randint</span></code></a>(low[,\u00a0high,\u00a0size,\u00a0dtype])</p></td>\n<td><p>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sh_descoteaux\" title=\"dipy.reconst.shm.real_sh_descoteaux\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sh_descoteaux</span></code></a>(sh_order,\u00a0theta,\u00a0phi[,\u00a0\u2026])</p></td>\n<td><p>Compute real spherical harmonics as in Descoteaux et al.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sh_descoteaux_from_index\" title=\"dipy.reconst.shm.real_sh_descoteaux_from_index\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sh_descoteaux_from_index</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics as in Descoteaux et al.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sh_tournier\" title=\"dipy.reconst.shm.real_sh_tournier\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sh_tournier</span></code></a>(sh_order,\u00a0theta,\u00a0phi[,\u00a0\u2026])</p></td>\n<td><p>Compute real spherical harmonics as initially defined in Tournier 2007 <a class=\"reference internal\" href=\"#rcffec8eb7314-1\" id=\"id65\">[1]</a> then updated in MRtrix3 <a class=\"reference internal\" href=\"#rcffec8eb7314-2\" id=\"id66\">[2]</a>, where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sh_tournier_from_index\" title=\"dipy.reconst.shm.real_sh_tournier_from_index\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sh_tournier_from_index</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics as initially defined in Tournier 2007 <a class=\"reference internal\" href=\"#r3f87c5e3a9f2-1\" id=\"id67\">[1]</a> then updated in MRtrix3 <a class=\"reference internal\" href=\"#r3f87c5e3a9f2-2\" id=\"id68\">[2]</a>, where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sph_harm\" title=\"dipy.reconst.shm.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sym_sh_basis\" title=\"dipy.reconst.shm.real_sym_sh_basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sym_sh_basis</span></code></a>(sh_order,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sym_sh_mrtrix\" title=\"dipy.reconst.shm.real_sym_sh_mrtrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sym_sh_mrtrix</span></code></a>(sh_order,\u00a0theta,\u00a0phi)</p></td>\n<td><p>dipy.reconst.shm.real_sym_sh_mrtix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.sf_to_sh\" title=\"dipy.reconst.shm.sf_to_sh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sf_to_sh</span></code></a>(sf,\u00a0sphere[,\u00a0sh_order,\u00a0basis_type,\u00a0\u2026])</p></td>\n<td><p>Spherical function to spherical harmonics (SH).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.sh_to_rh\" title=\"dipy.reconst.shm.sh_to_rh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sh_to_rh</span></code></a>(r_sh,\u00a0m,\u00a0n)</p></td>\n<td><p>Spherical harmonics (SH) to rotational harmonics (RH)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.sh_to_sf\" title=\"dipy.reconst.shm.sh_to_sf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sh_to_sf</span></code></a>(sh,\u00a0sphere[,\u00a0sh_order,\u00a0basis_type,\u00a0\u2026])</p></td>\n<td><p>Spherical harmonics (SH) to spherical function (SF).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.sh_to_sf_matrix\" title=\"dipy.reconst.shm.sh_to_sf_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sh_to_sf_matrix</span></code></a>(sphere[,\u00a0sh_order,\u00a0\u2026])</p></td>\n<td><p>Matrix that transforms Spherical harmonics (SH) to spherical function (SF).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.smooth_pinv\" title=\"dipy.reconst.shm.smooth_pinv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">smooth_pinv</span></code></a>(B,\u00a0L)</p></td>\n<td><p>Regularized pseudo-inverse</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.sph_harm_ind_list\" title=\"dipy.reconst.shm.sph_harm_ind_list\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sph_harm_ind_list</span></code></a>(sh_order[,\u00a0full_basis])</p></td>\n<td><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical harmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.spherical_harmonics\" title=\"dipy.reconst.shm.spherical_harmonics\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">spherical_harmonics</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi[,\u00a0\u2026])</p></td>\n<td><p>Compute spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.warn\" title=\"dipy.reconst.shm.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.shore\">\n<span id=\"module-reconst-shore\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.shore</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.shore\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.Cache\" title=\"dipy.reconst.shore.Cache\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></p></td>\n<td><p>Cache values based on a key object (such as a sphere or gradient table).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.LooseVersion\" title=\"dipy.reconst.shore.LooseVersion\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a>([vstring])</p></td>\n<td><p>Version numbering for anarchists and software realists.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit\" title=\"dipy.reconst.shore.ShoreFit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ShoreFit</span></code></a>(model,\u00a0shore_coef)</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreModel\" title=\"dipy.reconst.shore.ShoreModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ShoreModel</span></code></a>(gtab[,\u00a0radial_order,\u00a0zeta,\u00a0\u2026])</p></td>\n<td><p>Simple Harmonic Oscillator based Reconstruction and Estimation (SHORE) <a class=\"reference internal\" href=\"#rd47fc6332129-1\" id=\"id69\">[1]</a> of the diffusion signal.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.cart2sphere\" title=\"dipy.reconst.shore.cart2sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cart2sphere</span></code></a>(x,\u00a0y,\u00a0z)</p></td>\n<td><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.create_rspace\" title=\"dipy.reconst.shore.create_rspace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">create_rspace</span></code></a>(gridsize,\u00a0radius_max)</p></td>\n<td><p>Create the real space table, that contains the points in which</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.factorial\" title=\"dipy.reconst.shore.factorial\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">factorial</span></code></a>(x,\u00a0/)</p></td>\n<td><p>Find x!.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.genlaguerre\" title=\"dipy.reconst.shore.genlaguerre\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">genlaguerre</span></code></a>(n,\u00a0alpha[,\u00a0monic])</p></td>\n<td><p>Generalized (associated) Laguerre polynomial.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.l_shore\" title=\"dipy.reconst.shore.l_shore\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">l_shore</span></code></a>(radial_order)</p></td>\n<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.multi_voxel_fit\" title=\"dipy.reconst.shore.multi_voxel_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">multi_voxel_fit</span></code></a>(single_voxel_fit)</p></td>\n<td><p>Method decorator to turn a single voxel model fit definition into a multi voxel model fit definition</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.n_shore\" title=\"dipy.reconst.shore.n_shore\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">n_shore</span></code></a>(radial_order)</p></td>\n<td><p>Returns the angular regularisation matrix for SHORE basis</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.optional_package\" title=\"dipy.reconst.shore.optional_package\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">optional_package</span></code></a>(name[,\u00a0trip_msg])</p></td>\n<td><p>Return package-like thing and module setup for package <cite>name</cite></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.real_sph_harm\" title=\"dipy.reconst.shore.real_sph_harm\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real_sph_harm</span></code></a>(m,\u00a0n,\u00a0theta,\u00a0phi)</p></td>\n<td><p>Compute real spherical harmonics.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.shore_indices\" title=\"dipy.reconst.shore.shore_indices\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_indices</span></code></a>(radial_order,\u00a0index)</p></td>\n<td><p>Given the basis order and the index, return the shore indices n, l, m for modified Merlet\u2019s 3D-SHORE ..math::         :nowrap:             begin{equation}                 textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}                                         sum_{n=l}^{(N_{max}+l)/2}                                         sum_{m=-l}^l c_{nlm}                                         phi_{nlm}(qtextbf{u})             end{equation}</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.shore_matrix\" title=\"dipy.reconst.shore.shore_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_matrix</span></code></a>(radial_order,\u00a0zeta,\u00a0gtab[,\u00a0tau])</p></td>\n<td><p>Compute the SHORE matrix for modified Merlet\u2019s 3D-SHORE <a class=\"reference internal\" href=\"#r0425af01b43f-1\" id=\"id70\">[1]</a></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.shore_matrix_odf\" title=\"dipy.reconst.shore.shore_matrix_odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_matrix_odf</span></code></a>(radial_order,\u00a0zeta,\u00a0\u2026)</p></td>\n<td><p>Compute the SHORE ODF matrix <a class=\"reference internal\" href=\"#r0934fd177e35-1\" id=\"id71\">[1]</a>\u201d</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.shore_matrix_pdf\" title=\"dipy.reconst.shore.shore_matrix_pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_matrix_pdf</span></code></a>(radial_order,\u00a0zeta,\u00a0rtab)</p></td>\n<td><p>Compute the SHORE propagator matrix <a class=\"reference internal\" href=\"#r5470c7e1e272-1\" id=\"id72\">[1]</a>\u201d</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.shore_order\" title=\"dipy.reconst.shore.shore_order\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_order</span></code></a>(n,\u00a0l,\u00a0m)</p></td>\n<td><p>Given the indices (n,l,m) of the basis, return the minimum order for those indices and their index for modified Merlet\u2019s 3D-SHORE.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.warn\" title=\"dipy.reconst.shore.warn\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">warn</span></code></a>(/,\u00a0message[,\u00a0category,\u00a0stacklevel,\u00a0source])</p></td>\n<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"section\" id=\"module-dipy.reconst.utils\">\n<span id=\"module-reconst-utils\"></span><h2>Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.utils</span></code><a class=\"headerlink\" href=\"#module-dipy.reconst.utils\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.utils.dki_design_matrix\" title=\"dipy.reconst.utils.dki_design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dki_design_matrix</span></code></a>(gtab)</p></td>\n<td><p>Construct B design matrix for DKI.</p></td>\n</tr>\n</tbody>\n</table>\n<div class=\"section\" id=\"bench\">\n<h3>bench<a class=\"headerlink\" href=\"#bench\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.bench\">\n<code class=\"sig-prename descclassname\">dipy.reconst.</code><code class=\"sig-name descname\">bench</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">label='fast'</em>, <em class=\"sig-param\">verbose=1</em>, <em class=\"sig-param\">extra_argv=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.bench\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run benchmarks for module using nose.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>label</strong><span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt><dd><p>Identifies the benchmarks to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:</p>\n<ul class=\"simple\">\n<li><p>\u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code>\noption of \u2018not slow\u2019.</p></li>\n<li><p>\u2018full\u2019 - fast (as above) and slow benchmarks as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</p></li>\n<li><p>None or \u2018\u2019 - run all tests.</p></li>\n<li><p>attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p></li>\n</ul>\n</dd>\n<dt><strong>verbose</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong><span class=\"classifier\">list, optional</span></dt><dd><p>List with any extra arguments to pass to nosetests.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>success</strong><span class=\"classifier\">bool</span></dt><dd><p>Returns True if running the benchmarks works, False if an error\noccurred.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Benchmarks are like tests, but have names starting with \u201cbench\u201d instead\nof \u201ctest\u201d, and can be found under the \u201cbenchmarks\u201d sub-directory of the\nmodule.</p>\n<p>Each NumPy module exposes <cite>bench</cite> in its namespace to run all benchmarks\nfor it.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">bench</span><span class=\"p\">()</span> \n<span class=\"go\">Running benchmarks for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">using 562341 items:</span>\n<span class=\"go\">unique:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">unique1d:</span>\n<span class=\"go\">0.11</span>\n<span class=\"go\">ratio: 1.0</span>\n<span class=\"go\">nUnique: 56230 == 56230</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">OK</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">success</span> \n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"test\">\n<h3>test<a class=\"headerlink\" href=\"#test\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.test\">\n<code class=\"sig-prename descclassname\">dipy.reconst.</code><code class=\"sig-name descname\">test</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">label='fast'</em>, <em class=\"sig-param\">verbose=1</em>, <em class=\"sig-param\">extra_argv=None</em>, <em class=\"sig-param\">doctests=False</em>, <em class=\"sig-param\">coverage=False</em>, <em class=\"sig-param\">raise_warnings=None</em>, <em class=\"sig-param\">timer=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.test\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Run tests for module using nose.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>label</strong><span class=\"classifier\">{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional</span></dt><dd><p>Identifies the tests to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:</p>\n<ul class=\"simple\">\n<li><p>\u2018fast\u2019 - the default - which corresponds to the <code class=\"docutils literal notranslate\"><span class=\"pre\">nosetests</span> <span class=\"pre\">-A</span></code>\noption of \u2018not slow\u2019.</p></li>\n<li><p>\u2018full\u2019 - fast (as above) and slow tests as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.</p></li>\n<li><p>None or \u2018\u2019 - run all tests.</p></li>\n<li><p>attribute_identifier - string passed directly to nosetests as \u2018-A\u2019.</p></li>\n</ul>\n</dd>\n<dt><strong>verbose</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Verbosity value for test outputs, in the range 1-10. Default is 1.</p>\n</dd>\n<dt><strong>extra_argv</strong><span class=\"classifier\">list, optional</span></dt><dd><p>List with any extra arguments to pass to nosetests.</p>\n</dd>\n<dt><strong>doctests</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, run doctests in module. Default is False.</p>\n</dd>\n<dt><strong>coverage</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, report coverage of NumPy code. Default is False.\n(This requires the\n<a class=\"reference external\" href=\"https://nedbatchelder.com/code/modules/coveragehtml\">coverage module</a>).</p>\n</dd>\n<dt><strong>raise_warnings</strong><span class=\"classifier\">None, str or sequence of warnings, optional</span></dt><dd><p>This specifies which warnings to configure as \u2018raise\u2019 instead\nof being shown once during the test execution. Valid strings are:</p>\n<ul class=\"simple\">\n<li><p>\u201cdevelop\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">(Warning,)</span></code></p></li>\n<li><p>\u201crelease\u201d : equals <code class=\"docutils literal notranslate\"><span class=\"pre\">()</span></code>, do not raise on any warnings.</p></li>\n</ul>\n</dd>\n<dt><strong>timer</strong><span class=\"classifier\">bool or int, optional</span></dt><dd><p>Timing of individual tests with <code class=\"docutils literal notranslate\"><span class=\"pre\">nose-timer</span></code> (which needs to be\ninstalled).  If True, time tests and report on all of them.\nIf an integer (say <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code>), report timing results for <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> slowest\ntests.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">object</span></dt><dd><p>Returns the result of running the tests as a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">nose.result.TextTestResult</span></code> object.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Each NumPy module exposes <cite>test</cite> in its namespace to run all tests for it.\nFor example, to run all tests for numpy.lib:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n</pre></div>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">test</span><span class=\"p\">()</span> \n<span class=\"go\">Running unit tests for numpy.lib</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">Ran 976 tests in 3.933s</span>\n</pre></div>\n</div>\n<p>OK</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">errors</span> \n<span class=\"go\">[]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">knownfail</span> \n<span class=\"go\">[]</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"reconstfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a><a class=\"headerlink\" href=\"#reconstfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.base.ReconstFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.base.</code><code class=\"sig-name descname\">ReconstFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.base.ReconstFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class which holds the fit result of ReconstModel</p>\n<p>For example that could be holding FA or GFA etc.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.base.ReconstFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.base.ReconstFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"reconstmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#reconstmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.base.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.base.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.base.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.base.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.base.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.base.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.base.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bench-bounding-box\">\n<h3>bench_bounding_box<a class=\"headerlink\" href=\"#bench-bounding-box\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_bounding_box.</code><code class=\"sig-name descname\">bench_bounding_box</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.bench_bounding_box\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"bounding-box\">\n<h3>bounding_box<a class=\"headerlink\" href=\"#bounding-box\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_bounding_box.bounding_box\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_bounding_box.</code><code class=\"sig-name descname\">bounding_box</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vol</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.bounding_box\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the bounding box of nonzero intensity voxels in the volume.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vol</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Volume to compute bounding box on.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>npmins</strong><span class=\"classifier\">list</span></dt><dd><p>Array containg minimum index of each dimension</p>\n</dd>\n<dt><strong>npmaxs</strong><span class=\"classifier\">list</span></dt><dd><p>Array containg maximum index of each dimension</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"measure\">\n<h3>measure<a class=\"headerlink\" href=\"#measure\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_bounding_box.measure\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_bounding_box.</code><code class=\"sig-name descname\">measure</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">code_str</em>, <em class=\"sig-param\">times=1</em>, <em class=\"sig-param\">label=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_bounding_box.measure\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>\n<p>The supplied code string is compiled with the Python builtin <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>.\nThe precision of the timing is 10 milli-seconds. If the code will execute\nfast on this timescale, it can be executed many times to get reasonable\ntiming accuracy.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>code_str</strong><span class=\"classifier\">str</span></dt><dd><p>The code to be timed.</p>\n</dd>\n<dt><strong>times</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The number of times the code is executed. Default is 1. The code is\nonly compiled once.</p>\n</dd>\n<dt><strong>label</strong><span class=\"classifier\">str, optional</span></dt><dd><p>A label to identify <cite>code_str</cite> with. This is passed into <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>\nas the second argument (for run-time error messages).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>elapsed</strong><span class=\"classifier\">float</span></dt><dd><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">etime</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">testing</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"p\">(</span><span class=\"s1\">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class=\"p\">,</span> <span class=\"n\">times</span><span class=\"o\">=</span><span class=\"n\">times</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Time for a single execution : &quot;</span><span class=\"p\">,</span> <span class=\"n\">etime</span> <span class=\"o\">/</span> <span class=\"n\">times</span><span class=\"p\">,</span> <span class=\"s2\">&quot;s&quot;</span><span class=\"p\">)</span>  \n<span class=\"go\">Time for a single execution :  0.005 s</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"constrainedsphericaldeconvmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\" title=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a><a class=\"headerlink\" href=\"#constrainedsphericaldeconvmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">ConstrainedSphericalDeconvModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit\" title=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict\" title=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(sh_coeff[,\u00a0gtab,\u00a0S0])</p></td>\n<td><p>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constrained Spherical Deconvolution (CSD) <a class=\"reference internal\" href=\"#r82c564debcff-1\" id=\"id73\">[1]</a>.</p>\n<p>Spherical deconvolution computes a fiber orientation distribution\n(FOD), also called fiber ODF (fODF) <a class=\"reference internal\" href=\"#r82c564debcff-2\" id=\"id74\">[2]</a>, as opposed to a diffusion ODF\nas the QballModel or the CsaOdfModel. This results in a sharper angular\nprofile with better angular resolution that is the best object to be\nused for later deterministic and probabilistic tractography <a class=\"reference internal\" href=\"#r82c564debcff-3\" id=\"id75\">[3]</a>.</p>\n<p>A sharp fODF is obtained because a single fiber <em>response</em> function is\ninjected as <em>a priori</em> knowledge. The response function is often\ndata-driven and is thus provided as input to the\nConstrainedSphericalDeconvModel. It will be used as deconvolution\nkernel, as described in <a class=\"reference internal\" href=\"#r82c564debcff-1\" id=\"id76\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>response</strong><span class=\"classifier\">tuple or AxSymShResponse object</span></dt><dd><p>A tuple with two elements. The first is the eigen-values as an (3,)\nndarray and the second is the signal value for the response\nfunction without diffusion weighting (i.e. S0).  This is to be able\nto generate a single fiber synthetic signal. The response function\nwill be used as deconvolution kernel (<a class=\"reference internal\" href=\"#r82c564debcff-1\" id=\"id77\">[1]</a>).</p>\n</dd>\n<dt><strong>reg_sphere</strong><span class=\"classifier\">Sphere (optional)</span></dt><dd><p>sphere used to build the regularization B matrix.\nDefault: \u2018symmetric362\u2019.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int (optional)</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>\n</dd>\n<dt><strong>lambda_</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>weight given to the constrained-positivity regularization part of\nthe deconvolution equation (see <a class=\"reference internal\" href=\"#r82c564debcff-1\" id=\"id78\">[1]</a>). Default: 1</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>threshold controlling the amplitude below which the corresponding\nfODF is assumed to be zero.  Ideally, tau should be set to\nzero. However, to improve the stability of the algorithm, tau is\nset to tau*100 % of the mean fODF amplitude (here, 10% by default)\n(see <a class=\"reference internal\" href=\"#r82c564debcff-1\" id=\"id79\">[1]</a>). Default: 0.1</p>\n</dd>\n<dt><strong>convergence</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to\nconverge.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r82c564debcff-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id73\">1</a>,<a href=\"#id76\">2</a>,<a href=\"#id77\">3</a>,<a href=\"#id78\">4</a>,<a href=\"#id79\">5</a>)</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of\nthe fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical\ndeconvolution</p>\n</dd>\n<dt class=\"label\" id=\"r82c564debcff-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id74\">2</a></span></dt>\n<dd><p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and\nProbabilistic Tractography Based on Complex Fibre Orientation\nDistributions</p>\n</dd>\n<dt class=\"label\" id=\"r82c564debcff-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id75\">3</a></span></dt>\n<dd><p>C\u00f4t\u00e9, M-A., et al. Medical Image Analysis 2013. Tractometer:\nTowards validation of tractography pipelines</p>\n</dd>\n<dt class=\"label\" id=\"r82c564debcff-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>Tournier, J.D, et al. Imaging Systems and Technology\n2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeff</em>, <em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.ConstrainedSphericalDeconvModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute a signal prediction given spherical harmonic coefficients\nfor the provided GradientTable class instance.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeff</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make\nthe signal prediction.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Use the\nmodel\u2019s gradient table by default.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>pred_sig</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The predicted signal.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gradienttable\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable\" title=\"dipy.reconst.benchmarks.bench_csd.GradientTable\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a><a class=\"headerlink\" href=\"#gradienttable\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">GradientTable</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gradients</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Diffusion gradient information</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">array_like (N, 3)</span></dt><dd><p>Diffusion gradients. The direction of each of these vectors corresponds\nto the b-vector, and the length corresponds to the b-value.</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>The GradientTable object is immutable. Do NOT assign attributes.\nIf you have your gradient table in a bval &amp; bvec format, we recommend\nusing the factory function gradient_table</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">(N,3) ndarray</span></dt><dd><p>diffusion gradients</p>\n</dd>\n<dt><strong>bvals</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>The b-value, or magnitude, of each gradient direction.</p>\n</dd>\n<dt><strong>qvals: (N,) ndarray</strong></dt><dd><p>The q-value for each gradient direction. Needs big and small\ndelta.</p>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">(N,3) ndarray</span></dt><dd><p>The direction, represented as a unit vector, of each gradient.</p>\n</dd>\n<dt><strong>b0s_mask</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>Boolean array indicating which gradients have no diffusion\nweighting, ie b-value is close to 0.</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are\nconsidered to not have diffusion weighting.</p>\n</dd>\n<dt><strong>btens</strong><span class=\"classifier\">(N,3,3) ndarray</span></dt><dd><p>The b-tensor of each gradient direction.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 68%\" />\n<col style=\"width: 32%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>b0s_mask</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>bvals</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-odd\"><td><p><strong>bvecs</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>gradient_strength</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-odd\"><td><p><strong>qvals</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>tau</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gradients</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructor for GradientTable class</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask\">\n<code class=\"sig-name descname\">b0s_mask</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.b0s_mask\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.bvals\">\n<code class=\"sig-name descname\">bvals</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.bvals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs\">\n<code class=\"sig-name descname\">bvecs</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.bvecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.gradient_strength\">\n<code class=\"sig-name descname\">gradient_strength</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.gradient_strength\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.info\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">info</code><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.info\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.qvals\">\n<code class=\"sig-name descname\">qvals</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.qvals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.GradientTable.tau\">\n<code class=\"sig-name descname\">tau</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.GradientTable.tau\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bench-csdeconv\">\n<h3>bench_csdeconv<a class=\"headerlink\" href=\"#bench-csdeconv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.bench_csdeconv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">bench_csdeconv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">center=(50</em>, <em class=\"sig-param\">40</em>, <em class=\"sig-param\">40)</em>, <em class=\"sig-param\">width=12</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.bench_csdeconv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"load-nifti-data\">\n<h3>load_nifti_data<a class=\"headerlink\" href=\"#load-nifti-data\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.load_nifti_data\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">load_nifti_data</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fname</em>, <em class=\"sig-param\">as_ndarray=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.load_nifti_data\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Load only the data array from a nifti file.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fname</strong><span class=\"classifier\">str</span></dt><dd><p>Full path to the file.</p>\n</dd>\n<dt><strong>as_ndarray: bool, optional</strong></dt><dd><p>convert nibabel ArrayProxy to a numpy.ndarray.\nIf you want to save memory and delay this casting, just turn this\noption to False (default: True)</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>data: np.ndarray or nib.ArrayProxy</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">load_nifti</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"num-grad\">\n<h3>num_grad<a class=\"headerlink\" href=\"#num-grad\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.num_grad\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">num_grad</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.num_grad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"read-stanford-labels\">\n<h3>read_stanford_labels<a class=\"headerlink\" href=\"#read-stanford-labels\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_csd.read_stanford_labels\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_csd.</code><code class=\"sig-name descname\">read_stanford_labels</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_csd.read_stanford_labels\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Read stanford hardi data and label map.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bench-local-maxima\">\n<h3>bench_local_maxima<a class=\"headerlink\" href=\"#bench-local-maxima\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_peaks.bench_local_maxima\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_peaks.</code><code class=\"sig-name descname\">bench_local_maxima</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_peaks.bench_local_maxima\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"local-maxima\">\n<h3>local_maxima<a class=\"headerlink\" href=\"#local-maxima\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_peaks.local_maxima\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_peaks.</code><code class=\"sig-name descname\">local_maxima</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_peaks.local_maxima\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>\n<p>If a function is evaluated on some set of points where each pair of\nneighboring points is an edge in edges, find the local maxima.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">array, 1d, dtype=double</span></dt><dd><p>The function evaluated on a set of discrete points.</p>\n</dd>\n<dt><strong>edges</strong><span class=\"classifier\">array (N, 2)</span></dt><dd><p>The set of neighbor relations between the points. Every edge, ie\n<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>peak_values</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Value of odf at a maximum point. Peak values is sorted in descending\norder.</p>\n</dd>\n<dt><strong>peak_indices</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so\n<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"../dipy.core/#module-dipy.core.sphere\" title=\"dipy.core.sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dipy.core.sphere</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>A point is a local maximum if it is &gt; at least one neighbor and &gt;= all\nneighbors. If no points meet the above criteria, 1 maximum is returned such\nthat <cite>odf[maximum] == max(odf)</cite>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id84\">\n<h3>measure<a class=\"headerlink\" href=\"#id84\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_peaks.measure\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_peaks.</code><code class=\"sig-name descname\">measure</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">code_str</em>, <em class=\"sig-param\">times=1</em>, <em class=\"sig-param\">label=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_peaks.measure\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>\n<p>The supplied code string is compiled with the Python builtin <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>.\nThe precision of the timing is 10 milli-seconds. If the code will execute\nfast on this timescale, it can be executed many times to get reasonable\ntiming accuracy.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>code_str</strong><span class=\"classifier\">str</span></dt><dd><p>The code to be timed.</p>\n</dd>\n<dt><strong>times</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The number of times the code is executed. Default is 1. The code is\nonly compiled once.</p>\n</dd>\n<dt><strong>label</strong><span class=\"classifier\">str, optional</span></dt><dd><p>A label to identify <cite>code_str</cite> with. This is passed into <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>\nas the second argument (for run-time error messages).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>elapsed</strong><span class=\"classifier\">float</span></dt><dd><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">etime</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">testing</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"p\">(</span><span class=\"s1\">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class=\"p\">,</span> <span class=\"n\">times</span><span class=\"o\">=</span><span class=\"n\">times</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Time for a single execution : &quot;</span><span class=\"p\">,</span> <span class=\"n\">etime</span> <span class=\"o\">/</span> <span class=\"n\">times</span><span class=\"p\">,</span> <span class=\"s2\">&quot;s&quot;</span><span class=\"p\">)</span>  \n<span class=\"go\">Time for a single execution :  0.005 s</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"unique-edges\">\n<h3>unique_edges<a class=\"headerlink\" href=\"#unique-edges\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_peaks.unique_edges\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_peaks.</code><code class=\"sig-name descname\">unique_edges</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">faces</em>, <em class=\"sig-param\">return_mapping=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_peaks.unique_edges\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Extract all unique edges from given triangular faces.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>faces</strong><span class=\"classifier\">(N, 3) ndarray</span></dt><dd><p>Vertex indices forming triangular faces.</p>\n</dd>\n<dt><strong>return_mapping</strong><span class=\"classifier\">bool</span></dt><dd><p>If true, a mapping to the edges of each face is returned.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>edges</strong><span class=\"classifier\">(N, 2) ndarray</span></dt><dd><p>Unique edges.</p>\n</dd>\n<dt><strong>mapping</strong><span class=\"classifier\">(N, 3)</span></dt><dd><p>For each face, [x, y, z], a mapping to it\u2019s edges [a, b, c].</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>   y\n   /               /               a/    \b\n/                  /                   /__________          x      c     z\n</pre></div>\n</div>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bench-quick-squash\">\n<h3>bench_quick_squash<a class=\"headerlink\" href=\"#bench-quick-squash\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.bench_quick_squash\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">bench_quick_squash</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.bench_quick_squash\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"id85\">\n<h3>measure<a class=\"headerlink\" href=\"#id85\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.measure\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">measure</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">code_str</em>, <em class=\"sig-param\">times=1</em>, <em class=\"sig-param\">label=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.measure\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>\n<p>The supplied code string is compiled with the Python builtin <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>.\nThe precision of the timing is 10 milli-seconds. If the code will execute\nfast on this timescale, it can be executed many times to get reasonable\ntiming accuracy.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>code_str</strong><span class=\"classifier\">str</span></dt><dd><p>The code to be timed.</p>\n</dd>\n<dt><strong>times</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The number of times the code is executed. Default is 1. The code is\nonly compiled once.</p>\n</dd>\n<dt><strong>label</strong><span class=\"classifier\">str, optional</span></dt><dd><p>A label to identify <cite>code_str</cite> with. This is passed into <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>\nas the second argument (for run-time error messages).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>elapsed</strong><span class=\"classifier\">float</span></dt><dd><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">etime</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">testing</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"p\">(</span><span class=\"s1\">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class=\"p\">,</span> <span class=\"n\">times</span><span class=\"o\">=</span><span class=\"n\">times</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Time for a single execution : &quot;</span><span class=\"p\">,</span> <span class=\"n\">etime</span> <span class=\"o\">/</span> <span class=\"n\">times</span><span class=\"p\">,</span> <span class=\"s2\">&quot;s&quot;</span><span class=\"p\">)</span>  \n<span class=\"go\">Time for a single execution :  0.005 s</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ndindex\">\n<h3>ndindex<a class=\"headerlink\" href=\"#ndindex\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"old-squash\">\n<h3>old_squash<a class=\"headerlink\" href=\"#old-squash\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.old_squash\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">old_squash</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">arr</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">fill=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.old_squash\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Try and make a standard array from an object array</p>\n<p>This function takes an object array and attempts to convert it to a more\nuseful dtype. If array can be converted to a better dtype, Nones are\nreplaced by <cite>fill</cite>. To make the behaviour of this function more clear, here\nare the most common cases:</p>\n<ol class=\"arabic simple\">\n<li><p><cite>arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like\n<cite>arr.astype(T)</cite></p></li>\n<li><p><cite>arr</cite> is an array of arrays. All items in <cite>arr</cite> have the same shape\n<cite>S</cite>. Returns an array with shape <cite>arr.shape + S</cite>.</p></li>\n<li><p><cite>arr</cite> is an array of arrays of different shapes. Returns <cite>arr</cite>.</p></li>\n<li><p>Items in <cite>arr</cite> are not ndarrys or scalars. Returns <cite>arr</cite>.</p></li>\n</ol>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>arr</strong><span class=\"classifier\">array, dtype=object</span></dt><dd><p>The array to be converted.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, dtype=bool, optional</span></dt><dd><p>Where arr has Nones.</p>\n</dd>\n<dt><strong>fill</strong><span class=\"classifier\">number, optional</span></dt><dd><p>Nones are replaced by fill.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">array</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">old_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"go\">array([2, 2, 2])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">old_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"go\">array([0, 2, 2])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">old_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">dtype</span>\n<span class=\"go\">dtype(&#39;float64&#39;)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"quick-squash\">\n<h3>quick_squash<a class=\"headerlink\" href=\"#quick-squash\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.quick_squash\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">quick_squash</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.quick_squash\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Try and make a standard array from an object array</p>\n<p>This function takes an object array and attempts to convert it to a more\nuseful dtype. If array can be converted to a better dtype, Nones are\nreplaced by <cite>fill</cite>. To make the behaviour of this function more clear, here\nare the most common cases:</p>\n<ol class=\"arabic simple\">\n<li><p><cite>obj_arr</cite> is an array of scalars of type <cite>T</cite>. Returns an array like\n<cite>obj_arr.astype(T)</cite></p></li>\n<li><p><cite>obj_arr</cite> is an array of arrays. All items in <cite>obj_arr</cite> have the same\nshape <code class=\"docutils literal notranslate\"><span class=\"pre\">S</span></code>. Returns an array with shape <code class=\"docutils literal notranslate\"><span class=\"pre\">obj_arr.shape</span> <span class=\"pre\">+</span> <span class=\"pre\">S</span></code></p></li>\n<li><p><cite>obj_arr</cite> is an array of arrays of different shapes. Returns <cite>obj_arr</cite>.</p></li>\n<li><p>Items in <cite>obj_arr</cite> are not ndarrays or scalars. Returns <cite>obj_arr</cite>.</p></li>\n</ol>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>obj_arr</strong><span class=\"classifier\">array, dtype=object</span></dt><dd><p>The array to be converted.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, dtype=bool, optional</span></dt><dd><p>mask is nonzero where <cite>obj_arr</cite> has Nones.</p>\n</dd>\n<dt><strong>fill</strong><span class=\"classifier\">number, optional</span></dt><dd><p>Nones are replaced by <cite>fill</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>result</strong><span class=\"classifier\">array</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"nb\">object</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">quick_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"go\">array([2, 2, 2])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">quick_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"go\">array([0, 2, 2])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">quick_squash</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">(3, 2)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">dtype</span>\n<span class=\"go\">dtype(&#39;float64&#39;)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"reduce\">\n<h3>reduce<a class=\"headerlink\" href=\"#reduce\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_squash.reduce\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_squash.</code><code class=\"sig-name descname\">reduce</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">function</em>, <em class=\"sig-param\">sequence</em><span class=\"optional\">[</span>, <em class=\"sig-param\">initial</em><span class=\"optional\">]</span><span class=\"sig-paren\">)</span> &#x2192; value<a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_squash.reduce\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Apply a function of two arguments cumulatively to the items of a sequence,\nfrom left to right, so as to reduce the sequence to a single value.\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\nof the sequence in the calculation, and serves as a default when the\nsequence is empty.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bench-vec-val-vect\">\n<h3>bench_vec_val_vect<a class=\"headerlink\" href=\"#bench-vec-val-vect\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class=\"sig-name descname\">bench_vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.bench_vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"id86\">\n<h3>measure<a class=\"headerlink\" href=\"#id86\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_vec_val_sum.measure\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class=\"sig-name descname\">measure</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">code_str</em>, <em class=\"sig-param\">times=1</em>, <em class=\"sig-param\">label=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.measure\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return elapsed time for executing code in the namespace of the caller.</p>\n<p>The supplied code string is compiled with the Python builtin <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>.\nThe precision of the timing is 10 milli-seconds. If the code will execute\nfast on this timescale, it can be executed many times to get reasonable\ntiming accuracy.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>code_str</strong><span class=\"classifier\">str</span></dt><dd><p>The code to be timed.</p>\n</dd>\n<dt><strong>times</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The number of times the code is executed. Default is 1. The code is\nonly compiled once.</p>\n</dd>\n<dt><strong>label</strong><span class=\"classifier\">str, optional</span></dt><dd><p>A label to identify <cite>code_str</cite> with. This is passed into <code class=\"docutils literal notranslate\"><span class=\"pre\">compile</span></code>\nas the second argument (for run-time error messages).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>elapsed</strong><span class=\"classifier\">float</span></dt><dd><p>Total elapsed time in seconds for executing <cite>code_str</cite> <cite>times</cite> times.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">etime</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">testing</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"p\">(</span><span class=\"s1\">&#39;for i in range(1000): np.sqrt(i**2)&#39;</span><span class=\"p\">,</span> <span class=\"n\">times</span><span class=\"o\">=</span><span class=\"n\">times</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;Time for a single execution : &quot;</span><span class=\"p\">,</span> <span class=\"n\">etime</span> <span class=\"o\">/</span> <span class=\"n\">times</span><span class=\"p\">,</span> <span class=\"s2\">&quot;s&quot;</span><span class=\"p\">)</span>  \n<span class=\"go\">Time for a single execution :  0.005 s</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"randn\">\n<h3>randn<a class=\"headerlink\" href=\"#randn\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_vec_val_sum.randn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class=\"sig-name descname\">randn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">d0</em>, <em class=\"sig-param\">d1</em>, <em class=\"sig-param\">...</em>, <em class=\"sig-param\">dn</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.randn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return a sample (or samples) from the \u201cstandard normal\u201d distribution.</p>\n<div class=\"admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>This is a convenience function for users porting code from Matlab,\nand wraps <cite>standard_normal</cite>. That function takes a\ntuple to specify the size of the output, which is consistent with\nother NumPy functions like <cite>numpy.zeros</cite> and <cite>numpy.ones</cite>.</p>\n</div>\n<div class=\"admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>New code should use the <code class=\"docutils literal notranslate\"><span class=\"pre\">standard_normal</span></code> method of a <code class=\"docutils literal notranslate\"><span class=\"pre\">default_rng()</span></code>\ninstance instead; see <cite>random-quick-start</cite>.</p>\n</div>\n<p>If positive int_like arguments are provided, <cite>randn</cite> generates an array\nof shape <code class=\"docutils literal notranslate\"><span class=\"pre\">(d0,</span> <span class=\"pre\">d1,</span> <span class=\"pre\">...,</span> <span class=\"pre\">dn)</span></code>, filled\nwith random floats sampled from a univariate \u201cnormal\u201d (Gaussian)\ndistribution of mean 0 and variance 1. A single float randomly sampled\nfrom the distribution is returned if no argument is provided.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>d0, d1, \u2026, dn</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The dimensions of the returned array, must be non-negative.\nIf no argument is given a single Python float is returned.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>Z</strong><span class=\"classifier\">ndarray or float</span></dt><dd><p>A <code class=\"docutils literal notranslate\"><span class=\"pre\">(d0,</span> <span class=\"pre\">d1,</span> <span class=\"pre\">...,</span> <span class=\"pre\">dn)</span></code>-shaped array of floating-point samples from\nthe standard normal distribution, or a single such float if\nno parameters were supplied.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">standard_normal</span></code></dt><dd><p>Similar, but takes a tuple as its argument.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normal</span></code></dt><dd><p>Also accepts mu and sigma arguments.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Generator.standard_normal</span></code></dt><dd><p>which should be used for new code.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>For random samples from <span class=\"math notranslate nohighlight\">\\(N(\\mu, \\sigma^2)\\)</span>, use:</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">sigma</span> <span class=\"pre\">*</span> <span class=\"pre\">np.random.randn(...)</span> <span class=\"pre\">+</span> <span class=\"pre\">mu</span></code></p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">()</span>\n<span class=\"go\">2.1923875335537315  # random</span>\n</pre></div>\n</div>\n<p>Two-by-four array of samples from N(3, 6.25):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"mf\">2.5</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"go\">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random</span>\n<span class=\"go\">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"vec-val-vect\">\n<h3>vec_val_vect<a class=\"headerlink\" href=\"#vec-val-vect\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.benchmarks.bench_vec_val_sum.</code><code class=\"sig-name descname\">vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.benchmarks.bench_vec_val_sum.vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">shape (\u2026, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>\n</dd>\n<dt><strong>vals</strong><span class=\"classifier\">shape (\u2026, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> shape above must\nmatch that for <cite>vecs</cite></p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">shape (\u2026, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code>, loops to get (M, N) <code class=\"docutils literal notranslate\"><span class=\"pre\">vec</span></code>\nmatrix, and (N,) <code class=\"docutils literal notranslate\"><span class=\"pre\">vals</span></code> vector, and calculates\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Make a 3D array where the first dimension is only 1</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec_val_vect</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">vals</span><span class=\"p\">)</span>\n<span class=\"go\">array([[[   9.,   24.,   39.],</span>\n<span class=\"go\">        [  24.,   66.,  108.],</span>\n<span class=\"go\">        [  39.,  108.,  177.]]])</span>\n</pre></div>\n</div>\n<p>That\u2019s the same as the 2D case (apart from the float casting):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">),</span> <span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n<span class=\"go\">array([[  9,  24,  39],</span>\n<span class=\"go\">       [ 24,  66, 108],</span>\n<span class=\"go\">       [ 39, 108, 177]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"cache\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#cache\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.cache.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.cache.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.cache.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache.cache_clear\" title=\"dipy.reconst.cache.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache.cache_get\" title=\"dipy.reconst.cache.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache.cache_set\" title=\"dipy.reconst.cache.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.cache.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cache.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.cache.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cache.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.cache.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cache.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.cache.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cache.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"auto-attr\">\n<h3>auto_attr<a class=\"headerlink\" href=\"#auto-attr\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.cache.auto_attr\">\n<code class=\"sig-prename descclassname\">dipy.reconst.cache.</code><code class=\"sig-name descname\">auto_attr</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cache.auto_attr\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Decorator to create OneTimeProperty attributes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">method</span></dt><dd><p>The method that will be called the first time to compute a value.\nAfterwards, the method\u2019s name will be a standard attribute holding the\nvalue of this computation.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">MagicProp</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nd\">@auto_attr</span>\n<span class=\"gp\">... </span>    <span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>        <span class=\"k\">return</span> <span class=\"mi\">99</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">MagicProp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"go\">99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"coeff-of-determination\">\n<h3>coeff_of_determination<a class=\"headerlink\" href=\"#coeff-of-determination\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.cross_validation.coeff_of_determination\">\n<code class=\"sig-prename descclassname\">dipy.reconst.cross_validation.</code><code class=\"sig-name descname\">coeff_of_determination</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">model</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cross_validation.coeff_of_determination\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Calculate the coefficient of determination for a model prediction,</dt><dd><p>relative to data.</p>\n</dd>\n</dl>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><blockquote>\n<div><p>The data</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>model<span class=\"classifier\">ndarray</span></dt><dd><p>The predictions of a model for this data. Same shape as the data.</p>\n</dd>\n<dt>axis: int, optional</dt><dd><p>The axis along which different samples are laid out (default: -1).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>COD</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The coefficient of determination. This has shape <cite>data.shape[:-1]</cite></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>rac{SSE}{SSD})</p>\n<blockquote>\n<div><p>where SSE is the sum of the squared error between the model and the data\n(sum of the squared residuals) and SSD is the sum of the squares of the\ndeviations of the data from the mean of the data (variance * N).</p>\n</div></blockquote>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"kfold-xval\">\n<h3>kfold_xval<a class=\"headerlink\" href=\"#kfold-xval\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.cross_validation.kfold_xval\">\n<code class=\"sig-prename descclassname\">dipy.reconst.cross_validation.</code><code class=\"sig-name descname\">kfold_xval</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">folds</em>, <em class=\"sig-param\">*model_args</em>, <em class=\"sig-param\">**model_kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.cross_validation.kfold_xval\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Perform k-fold cross-validation.</p>\n<p>It generate out-of-sample predictions for each measurement.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">Model class instance</span></dt><dd><p>The type of the model to use for prediction. The corresponding Fit\nobject must have a <cite>predict</cite> function implementd One of the following:\n<cite>reconst.dti.TensorModel</cite> or\n<cite>reconst.csdeconv.ConstrainedSphericalDeconvModel</cite>.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Diffusion MRI data acquired with the GradientTable of the model. Shape\nwill typically be <cite>(x, y, z, b)</cite> where <cite>xyz</cite> are spatial dimensions and\nb is the number of bvals/bvecs in the GradientTable.</p>\n</dd>\n<dt><strong>folds</strong><span class=\"classifier\">int</span></dt><dd><p>The number of divisions to apply to the data</p>\n</dd>\n<dt><strong>model_args</strong><span class=\"classifier\">list</span></dt><dd><p>Additional arguments to the model initialization</p>\n</dd>\n<dt><strong>model_kwargs</strong><span class=\"classifier\">dict</span></dt><dd><p>Additional key-word arguments to the model initialization. If contains\nthe kwarg <cite>mask</cite>, this will be used as a key-word argument to the <cite>fit</cite>\nmethod of the model object, rather than being used in the\ninitialization of the model object</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This function assumes that a prediction API is implemented in the Model\nclass for which prediction is conducted. That is, the Fit object that gets\ngenerated upon fitting the model needs to have a <cite>predict</cite> method, which\nreceives a GradientTable class instance as input and produces a predicted\nsignal as output.</p>\n<p>It also assumes that the model object has <cite>bval</cite> and <cite>bvec</cite> attributes\nholding b-values and corresponding unit vectors.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra6e888b05b47-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Rokem, A., Chan, K.L. Yeatman, J.D., Pestilli, F., Mezer, A.,\nWandell, B.A., 2014. Evaluating the accuracy of diffusion models at\nmultiple b-values with cross-validation. ISMRM 2014.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"axsymshresponse\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.AxSymShResponse\" title=\"dipy.reconst.csdeconv.AxSymShResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AxSymShResponse</span></code></a><a class=\"headerlink\" href=\"#axsymshresponse\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.AxSymShResponse\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">AxSymShResponse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">S0</em>, <em class=\"sig-param\">dwi_response</em>, <em class=\"sig-param\">bvalue=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.AxSymShResponse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>A simple wrapper for response functions represented using only axially\nsymmetric, even spherical harmonic functions (ie, m == 0 and n even).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>Signal with no diffusion weighting.</p>\n</dd>\n<dt><strong>dwi_response</strong><span class=\"classifier\">array</span></dt><dd><p>Response function signal as coefficients to axially symmetric, even\nspherical harmonic.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.AxSymShResponse.basis\" title=\"dipy.reconst.csdeconv.AxSymShResponse.basis\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">basis</span></code></a>(sphere)</p></td>\n<td><p>A basis that maps the response coefficients onto a sphere.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.AxSymShResponse.on_sphere\" title=\"dipy.reconst.csdeconv.AxSymShResponse.on_sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">on_sphere</span></code></a>(sphere)</p></td>\n<td><p>Evaluates the response function on sphere.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.AxSymShResponse.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">S0</em>, <em class=\"sig-param\">dwi_response</em>, <em class=\"sig-param\">bvalue=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.AxSymShResponse.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.AxSymShResponse.basis\">\n<code class=\"sig-name descname\">basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.AxSymShResponse.basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A basis that maps the response coefficients onto a sphere.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.AxSymShResponse.on_sphere\">\n<code class=\"sig-name descname\">on_sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.AxSymShResponse.on_sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Evaluates the response function on sphere.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"constrainedsdtmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel\" title=\"dipy.reconst.csdeconv.ConstrainedSDTModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSDTModel</span></code></a><a class=\"headerlink\" href=\"#constrainedsdtmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSDTModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">ConstrainedSDTModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">ratio</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1.0</em>, <em class=\"sig-param\">tau=0.1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel.fit\" title=\"dipy.reconst.csdeconv.ConstrainedSDTModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSDTModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">ratio</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1.0</em>, <em class=\"sig-param\">tau=0.1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical Deconvolution Transform (SDT) <a class=\"reference internal\" href=\"#ra758a02951fe-1\" id=\"id88\">[1]</a>.</p>\n<p>The SDT computes a fiber orientation distribution (FOD) as opposed to a\ndiffusion ODF as the QballModel or the CsaOdfModel. This results in a\nsharper angular profile with better angular resolution. The Constrained\nSDTModel is similar to the Constrained CSDModel but mathematically it\ndeconvolves the q-ball ODF as oppposed to the HARDI signal (see <a class=\"reference internal\" href=\"#ra758a02951fe-1\" id=\"id89\">[1]</a>\nfor a comparison and a through discussion).</p>\n<p>A sharp fODF is obtained because a single fiber <em>response</em> function is\ninjected as <em>a priori</em> knowledge. In the SDTModel, this response is a\nsingle fiber q-ball ODF as opposed to a single fiber signal function\nfor the CSDModel. The response function will be used as deconvolution\nkernel.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>ratio of the smallest vs the largest eigenvalue of the single\nprolate tensor response function</p>\n</dd>\n<dt><strong>reg_sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>sphere used to build the regularization B matrix</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>maximal spherical harmonics order</p>\n</dd>\n<dt><strong>lambda_</strong><span class=\"classifier\">float</span></dt><dd><p>weight given to the constrained-positivity regularization part of\nthe deconvolution equation</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>threshold (tau <a href=\"#id90\"><span class=\"problematic\" id=\"id91\">*</span></a>mean(fODF)) controlling the amplitude below\nwhich the corresponding fODF is assumed to be zero.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra758a02951fe-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id88\">1</a>,<a href=\"#id89\">2</a>)</span></dt>\n<dd><p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and\nProbabilistic Tractography Based on Complex Fibre Orientation\nDistributions.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSDTModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSDTModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id93\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\" title=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a><a class=\"headerlink\" href=\"#id93\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">ConstrainedSphericalDeconvModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit\" title=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict\" title=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(sh_coeff[,\u00a0gtab,\u00a0S0])</p></td>\n<td><p>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constrained Spherical Deconvolution (CSD) <a class=\"reference internal\" href=\"#r2b09b06a1a8d-1\" id=\"id94\">[1]</a>.</p>\n<p>Spherical deconvolution computes a fiber orientation distribution\n(FOD), also called fiber ODF (fODF) <a class=\"reference internal\" href=\"#r2b09b06a1a8d-2\" id=\"id95\">[2]</a>, as opposed to a diffusion ODF\nas the QballModel or the CsaOdfModel. This results in a sharper angular\nprofile with better angular resolution that is the best object to be\nused for later deterministic and probabilistic tractography <a class=\"reference internal\" href=\"#r2b09b06a1a8d-3\" id=\"id96\">[3]</a>.</p>\n<p>A sharp fODF is obtained because a single fiber <em>response</em> function is\ninjected as <em>a priori</em> knowledge. The response function is often\ndata-driven and is thus provided as input to the\nConstrainedSphericalDeconvModel. It will be used as deconvolution\nkernel, as described in <a class=\"reference internal\" href=\"#r2b09b06a1a8d-1\" id=\"id97\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>response</strong><span class=\"classifier\">tuple or AxSymShResponse object</span></dt><dd><p>A tuple with two elements. The first is the eigen-values as an (3,)\nndarray and the second is the signal value for the response\nfunction without diffusion weighting (i.e. S0).  This is to be able\nto generate a single fiber synthetic signal. The response function\nwill be used as deconvolution kernel (<a class=\"reference internal\" href=\"#r2b09b06a1a8d-1\" id=\"id98\">[1]</a>).</p>\n</dd>\n<dt><strong>reg_sphere</strong><span class=\"classifier\">Sphere (optional)</span></dt><dd><p>sphere used to build the regularization B matrix.\nDefault: \u2018symmetric362\u2019.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int (optional)</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>\n</dd>\n<dt><strong>lambda_</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>weight given to the constrained-positivity regularization part of\nthe deconvolution equation (see <a class=\"reference internal\" href=\"#r2b09b06a1a8d-1\" id=\"id99\">[1]</a>). Default: 1</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>threshold controlling the amplitude below which the corresponding\nfODF is assumed to be zero.  Ideally, tau should be set to\nzero. However, to improve the stability of the algorithm, tau is\nset to tau*100 % of the mean fODF amplitude (here, 10% by default)\n(see <a class=\"reference internal\" href=\"#r2b09b06a1a8d-1\" id=\"id100\">[1]</a>). Default: 0.1</p>\n</dd>\n<dt><strong>convergence</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to\nconverge.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2b09b06a1a8d-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id94\">1</a>,<a href=\"#id97\">2</a>,<a href=\"#id98\">3</a>,<a href=\"#id99\">4</a>,<a href=\"#id100\">5</a>)</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of\nthe fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical\ndeconvolution</p>\n</dd>\n<dt class=\"label\" id=\"r2b09b06a1a8d-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id95\">2</a></span></dt>\n<dd><p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and\nProbabilistic Tractography Based on Complex Fibre Orientation\nDistributions</p>\n</dd>\n<dt class=\"label\" id=\"r2b09b06a1a8d-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id96\">3</a></span></dt>\n<dd><p>C\u00f4t\u00e9, M-A., et al. Medical Image Analysis 2013. Tractometer:\nTowards validation of tractography pipelines</p>\n</dd>\n<dt class=\"label\" id=\"r2b09b06a1a8d-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>Tournier, J.D, et al. Imaging Systems and Technology\n2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeff</em>, <em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ConstrainedSphericalDeconvModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute a signal prediction given spherical harmonic coefficients\nfor the provided GradientTable class instance.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeff</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make\nthe signal prediction.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Use the\nmodel\u2019s gradient table by default.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>pred_sig</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The predicted signal.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sphharmfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmFit\" title=\"dipy.reconst.csdeconv.SphHarmFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a><a class=\"headerlink\" href=\"#sphharmfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">SphHarmFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shm_coef</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfFit</span></code></a></p>\n<p>Diffusion data fit to a spherical harmonic model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmFit.shm_coeff\" title=\"dipy.reconst.csdeconv.SphHarmFit.shm_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm_coeff</span></code></a></dt><dd><p>The spherical harmonic coefficients of the odf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmFit.odf\" title=\"dipy.reconst.csdeconv.SphHarmFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>Samples the odf function on the points of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmFit.predict\" title=\"dipy.reconst.csdeconv.SphHarmFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab,\u00a0S0])</p></td>\n<td><p>Predict the diffusion signal from the model coefficients.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>gfa</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shm_coef</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.gfa\">\n<code class=\"sig-name descname\">gfa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.gfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Samples the odf function on the points of a sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points on which to sample the odf.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>values</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the diffusion signal from the model coefficients.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The directions and bvalues on which prediction is desired</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion-weighted signal in each voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmFit.shm_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shm_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmFit.shm_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The spherical harmonic coefficients of the odf</p>\n<p>Make this a property for now, if there is a usecase for modifying\nthe coefficients we can add a setter or expose the coefficients more\ndirectly</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sphharmmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmModel\" title=\"dipy.reconst.csdeconv.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a><a class=\"headerlink\" href=\"#sphharmmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">SphHarmModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>To be subclassed by all models that return a SphHarmFit when fit.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix\" title=\"dipy.reconst.csdeconv.SphHarmModel.sampling_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code></a>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.SphHarmModel.sampling_matrix\">\n<code class=\"sig-name descname\">sampling_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.SphHarmModel.sampling_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>Points used to sample ODF.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sampling_matrix</strong><span class=\"classifier\">array</span></dt><dd><p>The size of the matrix will be (N, M) where N is the number of\nvertices on sphere and M is the number of coefficients needed by\nthe model.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"tensormodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.TensorModel\" title=\"dipy.reconst.csdeconv.TensorModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a><a class=\"headerlink\" href=\"#tensormodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.csdeconv.TensorModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">TensorModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.TensorModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Diffusion Tensor</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.TensorModel.fit\" title=\"dipy.reconst.csdeconv.TensorModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the DTI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.csdeconv.TensorModel.predict\" title=\"dipy.reconst.csdeconv.TensorModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(dti_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.TensorModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.TensorModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A Diffusion Tensor Model <a class=\"reference internal\" href=\"#rd9db3d4c080e-1\" id=\"id105\">[1]</a>, <a class=\"reference internal\" href=\"#rd9db3d4c080e-2\" id=\"id106\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:</p>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 for weighted least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.wls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018LS\u2019 or \u2018OLS\u2019 for ordinary least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.ols_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018NLLS\u2019 for non-linear least-squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.nlls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018RT\u2019 or \u2018restore\u2019 or \u2018RESTORE\u2019 for RESTORE robust tensor</dt><dd><p>fitting <a class=\"reference internal\" href=\"#rd9db3d4c080e-3\" id=\"id107\">[3]</a>\n<code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.restore_fit_tensor()</span></code></p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id108\"><span class=\"problematic\" id=\"id109\">*</span></a>args, <a href=\"#id110\"><span class=\"problematic\" id=\"id111\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: minimal signal in the data provided to <cite>fit</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. Many fit_methods use the \u2018step\u2019\nparameter to set the number of voxels that will be fit at once in each\niteration. This is the chunk size as a number of voxels. A larger step\nvalue should speed things up, but it will also take up more memory. It\nis advisable to keep an eye on memory consumption as this value is\nincreased.</p>\n<p>E.g., in <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter_fit_tensor()</span></code> we have a default step value of\n1e4</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd9db3d4c080e-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id105\">1</a></span></dt>\n<dd><p>Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of\nthe effective self-diffusion tensor from the NMR spin echo. J Magn\nReson B 103, 247-254.</p>\n</dd>\n<dt class=\"label\" id=\"rd9db3d4c080e-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id106\">2</a></span></dt>\n<dd><p>Basser, P., Pierpaoli, C., 1996. Microstructural and\nphysiological features of tissues elucidated by quantitative\ndiffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</p>\n</dd>\n<dt class=\"label\" id=\"rd9db3d4c080e-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id107\">3</a></span></dt>\n<dd><p>Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust\nestimation of tensors by outlier rejection. MRM 53: 1088-1095</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.TensorModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.TensorModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the DTI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal from one voxel.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.csdeconv.TensorModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dti_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.TensorModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dti_params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The last dimension should have 12 tensor parameters: 3\neigenvalues, followed by the 3 eigenvectors</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"auto-response\">\n<h3>auto_response<a class=\"headerlink\" href=\"#auto-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.auto_response\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">auto_response</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">roi_center=None</em>, <em class=\"sig-param\">roi_radius=10</em>, <em class=\"sig-param\">fa_thr=0.7</em>, <em class=\"sig-param\">fa_callable=None</em>, <em class=\"sig-param\">return_number_of_voxels=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.auto_response\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Automatic estimation of ssst response function using FA.</p>\n<p>dipy.reconst.csdeconv.auto_response is deprecated, Please use dipy.reconst.csdeconv.auto_response_ssst instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.2</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 1.4</p></li>\n</ul>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>roi_center</strong><span class=\"classifier\">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is\nthe center of the volume with shape <cite>data.shape[:3]</cite>.</p>\n</dd>\n<dt><strong>roi_radius</strong><span class=\"classifier\">int</span></dt><dd><p>radius of cubic ROI</p>\n</dd>\n<dt><strong>fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold</p>\n</dd>\n<dt><strong>fa_callable</strong><span class=\"classifier\">callable</span></dt><dd><p>A callable that defines an operation that compares FA with the fa_thr.\nThe operator should have two positional arguments\n(e.g., <cite>fa_operator(FA, fa_thr)</cite>) and it should return a bool array.</p>\n</dd>\n<dt><strong>return_number_of_voxels</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, returns the number of voxels used for estimating the response\nfunction</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. We get this information from\ncsdeconv.mask_for_response_ssst(), which returns a mask of selected voxels\n(more details are available in the description of the function).</p>\n<p>With the mask, we compute the response function by using\ncsdeconv.response_from_mask_ssst(), which returns the <cite>response</cite> and the\n<cite>ratio</cite> (more details are available in the description of the function).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"auto-response-ssst\">\n<h3>auto_response_ssst<a class=\"headerlink\" href=\"#auto-response-ssst\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.auto_response_ssst\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">auto_response_ssst</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">roi_center=None</em>, <em class=\"sig-param\">roi_radii=10</em>, <em class=\"sig-param\">fa_thr=0.7</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.auto_response_ssst\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Automatic estimation of single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>roi_center</strong><span class=\"classifier\">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is\nthe center of the volume with shape <cite>data.shape[:3]</cite>.</p>\n</dd>\n<dt><strong>roi_radii</strong><span class=\"classifier\">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>\n</dd>\n<dt><strong>fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. We get this information from\ncsdeconv.mask_for_response_ssst(), which returns a mask of selected voxels\n(more details are available in the description of the function).</p>\n<p>With the mask, we compute the response function by using\ncsdeconv.response_from_mask_ssst(), which returns the <cite>response</cite> and the\n<cite>ratio</cite> (more details are available in the description of the function).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"cart2sphere\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#cart2sphere\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"csdeconv\">\n<h3>csdeconv<a class=\"headerlink\" href=\"#csdeconv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.csdeconv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">csdeconv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dwsignal</em>, <em class=\"sig-param\">X</em>, <em class=\"sig-param\">B_reg</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em>, <em class=\"sig-param\">P=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.csdeconv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constrained-regularized spherical deconvolution (CSD) <a class=\"reference internal\" href=\"#r537fd66f8bb4-1\" id=\"id115\">[1]</a></p>\n<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in\nrotational harmonics coefficients from the diffusion weighted signal in\n<cite>dwsignal</cite>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dwsignal</strong><span class=\"classifier\">array</span></dt><dd><p>Diffusion weighted signals to be deconvolved.</p>\n</dd>\n<dt><strong>X</strong><span class=\"classifier\">array</span></dt><dd><p>Prediction matrix which estimates diffusion weighted signals from FOD\ncoefficients.</p>\n</dd>\n<dt><strong>B_reg</strong><span class=\"classifier\">array (N, B)</span></dt><dd><p>SH basis matrix which maps FOD coefficients to FOD values on the\nsurface of the sphere. B_reg should be scaled to account for lambda.</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>Threshold controlling the amplitude below which the corresponding fODF\nis assumed to be zero.  Ideally, tau should be set to zero. However, to\nimprove the stability of the algorithm, tau is set to tau*100 % of the\nmax fODF amplitude (here, 10% by default). This is similar to peak\ndetection where peaks below 0.1 amplitude are usually considered noise\npeaks. Because SDT is based on a q-ball ODF deconvolution, and not\nsignal deconvolution, using the max instead of mean (as in CSD), is\nmore stable.</p>\n</dd>\n<dt><strong>convergence</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to converge.</p>\n</dd>\n<dt><strong>P</strong><span class=\"classifier\">ndarray</span></dt><dd><p>This is an optimization to avoid computing <code class=\"docutils literal notranslate\"><span class=\"pre\">dot(X.T,</span> <span class=\"pre\">X)</span></code> many times.\nIf the same <code class=\"docutils literal notranslate\"><span class=\"pre\">X</span></code> is used many times, <code class=\"docutils literal notranslate\"><span class=\"pre\">P</span></code> can be precomputed and\npassed to this function.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>fodf_sh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>Spherical harmonics coefficients of the constrained-regularized fiber\nODF.</p>\n</dd>\n<dt><strong>num_it</strong><span class=\"classifier\">int</span></dt><dd><p>Number of iterations in the constrained-regularization used for\nconvergence.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This section describes how the fitting of the SH coefficients is done.\nProblem is to minimise per iteration:</p>\n<p><span class=\"math notranslate nohighlight\">\\(F(f_n) = ||Xf_n - S||^2 + \\lambda^2 ||H_{n-1} f_n||^2\\)</span></p>\n<p>Where <span class=\"math notranslate nohighlight\">\\(X\\)</span> maps current FOD SH coefficients <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to DW signals <span class=\"math notranslate nohighlight\">\\(s\\)</span> and\n<span class=\"math notranslate nohighlight\">\\(H_{n-1}\\)</span> maps FOD SH coefficients <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to amplitudes along set of\nnegative directions identified in previous iteration, i.e. the matrix\nformed by the rows of <span class=\"math notranslate nohighlight\">\\(B_{reg}\\)</span> for which <span class=\"math notranslate nohighlight\">\\(Hf_{n-1}&lt;0\\)</span> where <span class=\"math notranslate nohighlight\">\\(B_{reg}\\)</span>\nmaps <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to FOD amplitude on a sphere.</p>\n<p>Solve by differentiating and setting to zero:</p>\n<p><span class=\"math notranslate nohighlight\">\\(\\Rightarrow \\frac{\\delta F}{\\delta f_n} = 2X^T(Xf_n - S) + 2 \\lambda^2\nH_{n-1}^TH_{n-1}f_n=0\\)</span></p>\n<p>Or:</p>\n<p><span class=\"math notranslate nohighlight\">\\((X^TX + \\lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\\)</span></p>\n<p>Define <span class=\"math notranslate nohighlight\">\\(Q = X^TX + \\lambda^2 H_{n-1}^TH_{n-1}\\)</span> , which by construction is a\nsquare positive definite symmetric matrix of size <span class=\"math notranslate nohighlight\">\\(n_{SH} by n_{SH}\\)</span>. If\nneeded, positive definiteness can be enforced with a small minimum norm\nregulariser (helps a lot with poorly conditioned direction sets and/or\nsuperresolution):</p>\n<p><span class=\"math notranslate nohighlight\">\\(Q = X^TX + (\\lambda H_{n-1}^T) (\\lambda H_{n-1}) + \\mu I\\)</span></p>\n<p>Solve <span class=\"math notranslate nohighlight\">\\(Qf_n = X^Ts\\)</span> using Cholesky decomposition:</p>\n<p><span class=\"math notranslate nohighlight\">\\(Q = LL^T\\)</span></p>\n<p>where <span class=\"math notranslate nohighlight\">\\(L\\)</span> is lower triangular. Then problem can be solved by\nback-substitution:</p>\n<p><span class=\"math notranslate nohighlight\">\\(L_y = X^Ts\\)</span></p>\n<p><span class=\"math notranslate nohighlight\">\\(L^Tf_n = y\\)</span></p>\n<p>To speeds things up further, form <span class=\"math notranslate nohighlight\">\\(P = X^TX + \\mu I\\)</span>, and update to form\n<span class=\"math notranslate nohighlight\">\\(Q\\)</span> by rankn update with <span class=\"math notranslate nohighlight\">\\(H_{n-1}\\)</span>. The dipy implementation looks like:</p>\n<blockquote>\n<div><p>form initially <span class=\"math notranslate nohighlight\">\\(P = X^T X + \\mu I\\)</span> and <span class=\"math notranslate nohighlight\">\\(\\lambda B_{reg}\\)</span></p>\n<p>for each voxel: form <span class=\"math notranslate nohighlight\">\\(z = X^Ts\\)</span></p>\n<blockquote>\n<div><p>estimate <span class=\"math notranslate nohighlight\">\\(f_0\\)</span> by solving <span class=\"math notranslate nohighlight\">\\(Pf_0=z\\)</span>. We use a simplified <span class=\"math notranslate nohighlight\">\\(l_{max}=4\\)</span>\nsolution here, but it might not make a big difference.</p>\n<p>Then iterate until no change in rows of <span class=\"math notranslate nohighlight\">\\(H\\)</span> used in <span class=\"math notranslate nohighlight\">\\(H_n\\)</span></p>\n<blockquote>\n<div><p>form <span class=\"math notranslate nohighlight\">\\(H_{n}\\)</span> given <span class=\"math notranslate nohighlight\">\\(f_{n-1}\\)</span></p>\n<p>form <span class=\"math notranslate nohighlight\">\\(Q = P + (\\lambda H_{n-1}^T) (\\lambda H_{n-1}\\)</span>) (this can\nbe done by rankn update, but we currently do not use rankn\nupdate).</p>\n<p>solve <span class=\"math notranslate nohighlight\">\\(Qf_n = z\\)</span> using Cholesky decomposition</p>\n</div></blockquote>\n</div></blockquote>\n</div></blockquote>\n<p>We\u2019d like to thanks Donald Tournier for his help with describing and\nimplementing this algorithm.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r537fd66f8bb4-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id1\">1</a>,<a href=\"#id115\">2</a>)</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the\nfibre orientation distribution in diffusion MRI: Non-negativity\nconstrained super-resolved spherical deconvolution.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"deprecate-with-version\">\n<h3>deprecate_with_version<a class=\"headerlink\" href=\"#deprecate-with-version\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.deprecate_with_version\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">deprecate_with_version</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">message</em>, <em class=\"sig-param\">since=''</em>, <em class=\"sig-param\">until=''</em>, <em class=\"sig-param\">version_comparator=&lt;function cmp_pkg_version&gt;</em>, <em class=\"sig-param\">warn_class=&lt;class 'DeprecationWarning'&gt;</em>, <em class=\"sig-param\">error_class=&lt;class 'dipy.utils.deprecator.ExpiredDeprecationError'&gt;</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.deprecate_with_version\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return decorator function function for deprecation warning / error.</p>\n<p>The decorated function / method will:</p>\n<ul class=\"simple\">\n<li><p>Raise the given <cite>warning_class</cite> warning when the function / method gets\ncalled, up to (and including) version <cite>until</cite> (if specified);</p></li>\n<li><p>Raise the given <cite>error_class</cite> error when the function / method gets\ncalled, when the package version is greater than version <cite>until</cite> (if\nspecified).</p></li>\n</ul>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>message</strong><span class=\"classifier\">str</span></dt><dd><p>Message explaining deprecation, giving possible alternatives.</p>\n</dd>\n<dt><strong>since</strong><span class=\"classifier\">str, optional</span></dt><dd><p>Released version at which object was first deprecated.</p>\n</dd>\n<dt><strong>until</strong><span class=\"classifier\">str, optional</span></dt><dd><p>Last released version at which this function will still raise a\ndeprecation warning.  Versions higher than this will raise an\nerror.</p>\n</dd>\n<dt><strong>version_comparator</strong><span class=\"classifier\">callable</span></dt><dd><p>Callable accepting string as argument, and return 1 if string\nrepresents a higher version than encoded in the <cite>version_comparator</cite>, 0\nif the version is equal, and -1 if the version is lower.  For example,\nthe <cite>version_comparator</cite> may compare the input version string to the\ncurrent package version string.</p>\n</dd>\n<dt><strong>warn_class</strong><span class=\"classifier\">class, optional</span></dt><dd><p>Class of warning to generate for deprecation.</p>\n</dd>\n<dt><strong>error_class</strong><span class=\"classifier\">class, optional</span></dt><dd><p>Class of error to generate when <cite>version_comparator</cite> returns 1 for a\ngiven argument of <code class=\"docutils literal notranslate\"><span class=\"pre\">until</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>deprecator</strong><span class=\"classifier\">func</span></dt><dd><p>Function returning a decorator.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"estimate-response\">\n<h3>estimate_response<a class=\"headerlink\" href=\"#estimate-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.estimate_response\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">estimate_response</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">evals</em>, <em class=\"sig-param\">S0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.estimate_response\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Estimate single fiber response function</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>evals</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>non diffusion weighted</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">estimated signal</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fa-trace-to-lambdas\">\n<h3>fa_trace_to_lambdas<a class=\"headerlink\" href=\"#fa-trace-to-lambdas\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.fa_trace_to_lambdas\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">fa_trace_to_lambdas</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fa=0.08</em>, <em class=\"sig-param\">trace=0.0021</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.fa_trace_to_lambdas\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"forward-sdeconv-mat\">\n<h3>forward_sdeconv_mat<a class=\"headerlink\" href=\"#forward-sdeconv-mat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.forward_sdeconv_mat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">forward_sdeconv_mat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_rh</em>, <em class=\"sig-param\">n</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.forward_sdeconv_mat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Build forward spherical deconvolution matrix</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r_rh</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Rotational harmonics coefficients for the single fiber response\nfunction. Each element <code class=\"docutils literal notranslate\"><span class=\"pre\">rh[i]</span></code> is associated with spherical harmonics\nof degree <code class=\"docutils literal notranslate\"><span class=\"pre\">2*i</span></code>.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The order of spherical harmonic function associated with each row of\nthe deconvolution matrix. Only even orders are allowed</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>R</strong><span class=\"classifier\">ndarray (N, N)</span></dt><dd><p>Deconvolution matrix with shape (N, N)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"forward-sdt-deconv-mat\">\n<h3>forward_sdt_deconv_mat<a class=\"headerlink\" href=\"#forward-sdt-deconv-mat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.forward_sdt_deconv_mat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">forward_sdt_deconv_mat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ratio</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">r2_term=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.forward_sdt_deconv_mat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Build forward sharpening deconvolution transform (SDT) matrix</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>ratio = <span class=\"math notranslate nohighlight\">\\(\\frac{\\lambda_2}{\\lambda_1}\\)</span> of the single fiber response\nfunction</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The degree of spherical harmonic function associated with each row of\nthe deconvolution matrix. Only even degrees are allowed.</p>\n</dd>\n<dt><strong>r2_term</strong><span class=\"classifier\">bool</span></dt><dd><p>True if ODF comes from an ODF computed from a model using the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span>\nterm in the integral. For example, DSI, GQI, SHORE, CSA, Tensor,\nMulti-tensor ODFs. This results in using the proper analytical response\nfunction solution solving from the single-fiber ODF with the r^2 term.\nThis derivation is not published anywhere but is very similar to <a class=\"reference internal\" href=\"#rf897e7c36096-1\" id=\"id117\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>R</strong><span class=\"classifier\">ndarray (N, N)</span></dt><dd><p>SDT deconvolution matrix</p>\n</dd>\n<dt><strong>P</strong><span class=\"classifier\">ndarray (N, N)</span></dt><dd><p>Funk-Radon Transform (FRT) matrix</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf897e7c36096-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id117\">1</a></span></dt>\n<dd><p>Descoteaux, M. PhD Thesis. INRIA Sophia-Antipolis. 2008.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fractional-anisotropy\">\n<h3>fractional_anisotropy<a class=\"headerlink\" href=\"#fractional-anisotropy\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.fractional_anisotropy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">fractional_anisotropy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.fractional_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fa</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>FA is calculated using the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[FA = \\sqrt{\\frac{1}{2}\\frac{(\\lambda_1-\\lambda_2)^2+(\\lambda_1-\n            \\lambda_3)^2+(\\lambda_2-\\lambda_3)^2}{\\lambda_1^2+\n            \\lambda_2^2+\\lambda_3^2}}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"get-sphere\">\n<h3>get_sphere<a class=\"headerlink\" href=\"#get-sphere\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.get_sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">get_sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name='symmetric362'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.get_sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>provide triangulated spheres</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>which sphere - one of:\n* \u2018symmetric362\u2019\n* \u2018symmetric642\u2019\n* \u2018symmetric724\u2019\n* \u2018repulsion724\u2019\n* \u2018repulsion100\u2019\n* \u2018repulsion200\u2019</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">a dipy.core.sphere.Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;symmetric362&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">faces</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">362</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">faces</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">720</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;not a sphere name&#39;</span><span class=\"p\">)</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">DataError</span>: <span class=\"n\">No sphere called &quot;not a sphere name&quot;</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lazy-index\">\n<h3>lazy_index<a class=\"headerlink\" href=\"#lazy-index\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.lazy_index\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">lazy_index</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">index</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.lazy_index\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Produces a lazy index</p>\n<p>Returns a slice that can be used for indexing an array, if no slice can be\nmade index is returned as is.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lpn\">\n<h3>lpn<a class=\"headerlink\" href=\"#lpn\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.lpn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">lpn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.lpn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Legendre function of the first kind.</p>\n<p>Compute sequence of Legendre functions of the first kind (polynomials),\nPn(z) and derivatives for all degrees from 0 to n (inclusive).</p>\n<p>See also special.legendre for polynomial class.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r631d63c165ca-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Zhang, Shanjie and Jin, Jianming. \u201cComputation of Special\nFunctions\u201d, John Wiley and Sons, 1996.\n<a class=\"reference external\" href=\"https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\">https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mask-for-response-ssst\">\n<h3>mask_for_response_ssst<a class=\"headerlink\" href=\"#mask-for-response-ssst\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.mask_for_response_ssst\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">mask_for_response_ssst</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">roi_center=None</em>, <em class=\"sig-param\">roi_radii=10</em>, <em class=\"sig-param\">fa_thr=0.7</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.mask_for_response_ssst\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of mask for single-shell single-tissue (ssst) response</dt><dd><p>function using FA.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data (4D)</p>\n</dd>\n<dt><strong>roi_center</strong><span class=\"classifier\">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is\nthe center of the volume with shape <cite>data.shape[:3]</cite>.</p>\n</dd>\n<dt><strong>roi_radii</strong><span class=\"classifier\">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>\n</dd>\n<dt><strong>fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. This function aims to accomplish that by\nreturning a mask of voxels within a ROI, that have a FA value above a\ngiven threshold. For example we can use a ROI (20x20x20) at\nthe center of the volume and store the signal values for the voxels with\nFA values higher than 0.7 (see <a class=\"reference internal\" href=\"#r05e2ff9e19d5-1\" id=\"id120\">[1]</a>).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r05e2ff9e19d5-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id120\">1</a></span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>\n</dd>\n</dl>\n<p>fiber orientation density function from diffusion-weighted MRI\ndata using spherical deconvolution</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multi-voxel-fit\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#multi-voxel-fit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id122\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id122\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"odf-deconv\">\n<h3>odf_deconv<a class=\"headerlink\" href=\"#odf-deconv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.odf_deconv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">odf_deconv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">odf_sh</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">B_reg</em>, <em class=\"sig-param\">lambda_=1.0</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">r2_term=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.odf_deconv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>ODF constrained-regularized spherical deconvolution using\nthe Sharpening Deconvolution Transform (SDT) <a class=\"reference internal\" href=\"#ra707a2933099-1\" id=\"id123\">[1]</a>, <a class=\"reference internal\" href=\"#ra707a2933099-2\" id=\"id124\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>odf_sh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>ndarray of SH coefficients for the ODF spherical function to be\ndeconvolved</p>\n</dd>\n<dt><strong>R</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>)\nSDT matrix in SH basis</p>\n</dd>\n<dt><strong>B_reg</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>)\nSH basis matrix used for deconvolution</p>\n</dd>\n<dt><strong>lambda_</strong><span class=\"classifier\">float</span></dt><dd><p>lambda parameter in minimization equation (default 1.0)</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>threshold (tau <a href=\"#id125\"><span class=\"problematic\" id=\"id126\">*</span></a>max(fODF)) controlling the amplitude below\nwhich the corresponding fODF is assumed to be zero.</p>\n</dd>\n<dt><strong>r2_term</strong><span class=\"classifier\">bool</span></dt><dd><p>True if ODF is computed from model that uses the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the\nintegral.  Recall that Tuch\u2019s ODF (used in Q-ball Imaging <a class=\"reference internal\" href=\"#ra707a2933099-1\" id=\"id127\">[1]</a>) and\nthe true normalized ODF definition differ from a <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the ODF\nintegral. The original Sharpening Deconvolution Transform (SDT)\ntechnique <a class=\"reference internal\" href=\"#ra707a2933099-2\" id=\"id128\">[2]</a> is expecting Tuch\u2019s ODF without the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> (see <a class=\"reference internal\" href=\"#ra707a2933099-3\" id=\"id129\">[3]</a> for\nthe mathematical details).  Now, this function supports ODF that have\nbeen computed using the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term because the proper analytical\nresponse function has be derived.  For example, models such as DSI,\nGQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved\nwith the r2_term=True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>fodf_sh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>Spherical harmonics coefficients of the constrained-regularized fiber\nODF</p>\n</dd>\n<dt><strong>num_it</strong><span class=\"classifier\">int</span></dt><dd><p>Number of iterations in the constrained-regularization used for\nconvergence</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra707a2933099-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id2\">1</a>,<a href=\"#id123\">2</a>,<a href=\"#id127\">3</a>)</span></dt>\n<dd><p>Tuch, D. MRM 2004. Q-Ball Imaging.</p>\n</dd>\n<dt class=\"label\" id=\"ra707a2933099-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id3\">1</a>,<a href=\"#id124\">2</a>,<a href=\"#id128\">3</a>)</span></dt>\n<dd><p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and\nProbabilistic Tractography Based on Complex Fibre Orientation\nDistributions</p>\n</dd>\n<dt class=\"label\" id=\"ra707a2933099-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id129\">3</a></span></dt>\n<dd><p>Descoteaux, M, PhD thesis, INRIA Sophia-Antipolis, 2008.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"odf-sh-to-sharp\">\n<h3>odf_sh_to_sharp<a class=\"headerlink\" href=\"#odf-sh-to-sharp\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.odf_sh_to_sharp\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">odf_sh_to_sharp</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">odfs_sh</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">basis=None</em>, <em class=\"sig-param\">ratio=0.2</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_=1.0</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">r2_term=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.odf_sh_to_sharp\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Sharpen odfs using the sharpening deconvolution transform <a class=\"reference internal\" href=\"#rc713c9e45b9d-2\" id=\"id133\">[2]</a></p>\n<p>This function can be used to sharpen any smooth ODF spherical function. In\ntheory, this should only be used to sharpen QballModel ODFs, but in\npractice, one can play with the deconvolution ratio and sharpen almost any\nODF-like spherical function. The constrained-regularization is stable and\nwill not only sharpen the ODF peaks but also regularize the noisy peaks.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>odfs_sh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>, )</span></dt><dd><p>array of odfs expressed as spherical harmonics coefficients</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>sphere used to build the regularization matrix</p>\n</dd>\n<dt><strong>basis</strong><span class=\"classifier\">{None, \u2018tournier07\u2019, \u2018descoteaux07\u2019}</span></dt><dd><p>different spherical harmonic basis:\n<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the default DIPY basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 <a class=\"reference internal\" href=\"#rc713c9e45b9d-4\" id=\"id134\">[4]</a> basis, and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#rc713c9e45b9d-3\" id=\"id135\">[3]</a> basis\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>).</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float,</span></dt><dd><p>ratio of the smallest vs the largest eigenvalue of the single prolate\ntensor response function (<span class=\"math notranslate nohighlight\">\\(\\frac{\\lambda_2}{\\lambda_1}\\)</span>)</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>maximal SH order of the SH representation</p>\n</dd>\n<dt><strong>lambda_</strong><span class=\"classifier\">float</span></dt><dd><p>lambda parameter (see odfdeconv) (default 1.0)</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>tau parameter in the L matrix construction (see odfdeconv)\n(default 0.1)</p>\n</dd>\n<dt><strong>r2_term</strong><span class=\"classifier\">bool</span></dt><dd><p>True if ODF is computed from model that uses the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the\nintegral.  Recall that Tuch\u2019s ODF (used in Q-ball Imaging <a class=\"reference internal\" href=\"#rc713c9e45b9d-1\" id=\"id136\">[1]</a>) and\nthe true normalized ODF definition differ from a <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the ODF\nintegral. The original Sharpening Deconvolution Transform (SDT)\ntechnique <a class=\"reference internal\" href=\"#rc713c9e45b9d-2\" id=\"id137\">[2]</a> is expecting Tuch\u2019s ODF without the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> (see <a class=\"reference internal\" href=\"#rc713c9e45b9d-3\" id=\"id138\">[3]</a> for\nthe mathematical details).  Now, this function supports ODF that have\nbeen computed using the <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term because the proper analytical\nresponse function has be derived.  For example, models such as DSI,\nGQI, SHORE, CSA, Tensor, Multi-tensor ODFs, should now be deconvolved\nwith the r2_term=True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fodf_sh</strong><span class=\"classifier\">ndarray</span></dt><dd><p>sharpened odf expressed as spherical harmonics coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc713c9e45b9d-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id136\">1</a></span></dt>\n<dd><p>Tuch, D. MRM 2004. Q-Ball Imaging.</p>\n</dd>\n<dt class=\"label\" id=\"rc713c9e45b9d-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id4\">1</a>,<a href=\"#id133\">2</a>,<a href=\"#id137\">3</a>)</span></dt>\n<dd><p>Descoteaux, M., et al. IEEE TMI 2009. Deterministic and\nProbabilistic Tractography Based on Complex Fibre Orientation\nDistributions</p>\n</dd>\n<dt class=\"label\" id=\"rc713c9e45b9d-3\"><span class=\"brackets\">3</span><span class=\"fn-backref\">(<a href=\"#id135\">1</a>,<a href=\"#id138\">2</a>)</span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"rc713c9e45b9d-4\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id134\">4</a></span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"peaks-from-model\">\n<h3>peaks_from_model<a class=\"headerlink\" href=\"#peaks-from-model\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.peaks_from_model\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">peaks_from_model</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">relative_peak_threshold</em>, <em class=\"sig-param\">min_separation_angle</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">return_odf=False</em>, <em class=\"sig-param\">return_sh=True</em>, <em class=\"sig-param\">gfa_thr=0</em>, <em class=\"sig-param\">normalize_peaks=False</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">sh_basis_type=None</em>, <em class=\"sig-param\">npeaks=5</em>, <em class=\"sig-param\">B=None</em>, <em class=\"sig-param\">invB=None</em>, <em class=\"sig-param\">parallel=False</em>, <em class=\"sig-param\">nbr_processes=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.peaks_from_model\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit the model to data and computes peaks and metrics</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">a model instance</span></dt><dd><p><cite>model</cite> will be used to fit the data.</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The Sphere providing discrete directions for evaluation.</p>\n</dd>\n<dt><strong>relative_peak_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>Only return peaks greater than <code class=\"docutils literal notranslate\"><span class=\"pre\">relative_peak_threshold</span> <span class=\"pre\">*</span> <span class=\"pre\">m</span></code> where m\nis the largest peak.</p>\n</dd>\n<dt><strong>min_separation_angle</strong><span class=\"classifier\">float in [0, 90] The minimum distance between</span></dt><dd><p>directions. If two peaks are too close only the larger of the two is\nreturned.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, optional</span></dt><dd><p>If <cite>mask</cite> is provided, voxels that are False in <cite>mask</cite> are skipped and\nno peaks are returned.</p>\n</dd>\n<dt><strong>return_odf</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, the odfs are returned.</p>\n</dd>\n<dt><strong>return_sh</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, the odf as spherical harmonics coefficients is returned</p>\n</dd>\n<dt><strong>gfa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>Voxels with gfa less than <cite>gfa_thr</cite> are skipped, no peaks are returned.</p>\n</dd>\n<dt><strong>normalize_peaks</strong><span class=\"classifier\">bool</span></dt><dd><p>If true, all peak values are calculated relative to <cite>max(odf)</cite>.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <cite>sh_order</cite>, there will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)</span> <span class=\"pre\">/</span> <span class=\"pre\">2</span></code> SH coefficients (default 8).</p>\n</dd>\n<dt><strong>sh_basis_type</strong><span class=\"classifier\">{None, \u2018tournier07\u2019, \u2018descoteaux07\u2019}</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the default DIPY basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 <a class=\"reference internal\" href=\"#r50d34e03da10-2\" id=\"id143\">[2]</a> basis, and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#r50d34e03da10-1\" id=\"id144\">[1]</a> basis\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>).</p>\n</dd>\n<dt><strong>sh_smooth</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit (default 0.0).</p>\n</dd>\n<dt><strong>npeaks</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of peaks found (default 5 peaks).</p>\n</dd>\n<dt><strong>B</strong><span class=\"classifier\">ndarray, optional</span></dt><dd><p>Matrix that transforms spherical harmonics to spherical function\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sf</span> <span class=\"pre\">=</span> <span class=\"pre\">np.dot(sh,</span> <span class=\"pre\">B)</span></code>.</p>\n</dd>\n<dt><strong>invB</strong><span class=\"classifier\">ndarray, optional</span></dt><dd><p>Inverse of B.</p>\n</dd>\n<dt><strong>parallel: bool</strong></dt><dd><p>If True, use multiprocessing to compute peaks and metric\n(default False). Temporary files are saved in the default temporary\ndirectory of the system. It can be changed using <code class=\"docutils literal notranslate\"><span class=\"pre\">import</span> <span class=\"pre\">tempfile</span></code>\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">tempfile.tempdir</span> <span class=\"pre\">=</span> <span class=\"pre\">'/path/to/tempdir'</span></code>.</p>\n</dd>\n<dt><strong>nbr_processes: int</strong></dt><dd><p>If <cite>parallel</cite> is True, the number of subprocesses to use\n(default multiprocessing.cpu_count()).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>pam</strong><span class=\"classifier\">PeaksAndMetrics</span></dt><dd><p>An object with <code class=\"docutils literal notranslate\"><span class=\"pre\">gfa</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">peak_directions</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">peak_values</span></code>,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">peak_indices</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">odf</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">shm_coeffs</span></code> as attributes</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r50d34e03da10-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id144\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"r50d34e03da10-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id143\">2</a></span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"quad\">\n<h3>quad<a class=\"headerlink\" href=\"#quad\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.quad\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">quad</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em>, <em class=\"sig-param\">a</em>, <em class=\"sig-param\">b</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">full_output=0</em>, <em class=\"sig-param\">epsabs=1.49e-08</em>, <em class=\"sig-param\">epsrel=1.49e-08</em>, <em class=\"sig-param\">limit=50</em>, <em class=\"sig-param\">points=None</em>, <em class=\"sig-param\">weight=None</em>, <em class=\"sig-param\">wvar=None</em>, <em class=\"sig-param\">wopts=None</em>, <em class=\"sig-param\">maxp1=50</em>, <em class=\"sig-param\">limlst=50</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.quad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute a definite integral.</p>\n<p>Integrate func from <cite>a</cite> to <cite>b</cite> (possibly infinite interval) using a\ntechnique from the Fortran library QUADPACK.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>func</strong><span class=\"classifier\">{function, scipy.LowLevelCallable}</span></dt><dd><p>A Python function or method to integrate. If <cite>func</cite> takes many\narguments, it is integrated along the axis corresponding to the\nfirst argument.</p>\n<p>If the user desires improved integration performance, then <cite>f</cite> may\nbe a <cite>scipy.LowLevelCallable</cite> with one of the signatures:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">double</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">double</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">double</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">double</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">user_data</span><span class=\"p\">)</span>\n<span class=\"n\">double</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"nb\">int</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">double</span> <span class=\"o\">*</span><span class=\"n\">xx</span><span class=\"p\">)</span>\n<span class=\"n\">double</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"nb\">int</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">double</span> <span class=\"o\">*</span><span class=\"n\">xx</span><span class=\"p\">,</span> <span class=\"n\">void</span> <span class=\"o\">*</span><span class=\"n\">user_data</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>The <code class=\"docutils literal notranslate\"><span class=\"pre\">user_data</span></code> is the data contained in the <cite>scipy.LowLevelCallable</cite>.\nIn the call forms with <code class=\"docutils literal notranslate\"><span class=\"pre\">xx</span></code>,  <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> is the length of the <code class=\"docutils literal notranslate\"><span class=\"pre\">xx</span></code>\narray which contains <code class=\"docutils literal notranslate\"><span class=\"pre\">xx[0]</span> <span class=\"pre\">==</span> <span class=\"pre\">x</span></code> and the rest of the items are\nnumbers contained in the <code class=\"docutils literal notranslate\"><span class=\"pre\">args</span></code> argument of quad.</p>\n<p>In addition, certain ctypes call signatures are supported for\nbackward compatibility, but those should not be used in new code.</p>\n</dd>\n<dt><strong>a</strong><span class=\"classifier\">float</span></dt><dd><p>Lower limit of integration (use -numpy.inf for -infinity).</p>\n</dd>\n<dt><strong>b</strong><span class=\"classifier\">float</span></dt><dd><p>Upper limit of integration (use numpy.inf for +infinity).</p>\n</dd>\n<dt><strong>args</strong><span class=\"classifier\">tuple, optional</span></dt><dd><p>Extra arguments to pass to <cite>func</cite>.</p>\n</dd>\n<dt><strong>full_output</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Non-zero to return a dictionary of integration information.\nIf non-zero, warning messages are also suppressed and the\nmessage is appended to the output tuple.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y</strong><span class=\"classifier\">float</span></dt><dd><p>The integral of func from <cite>a</cite> to <cite>b</cite>.</p>\n</dd>\n<dt><strong>abserr</strong><span class=\"classifier\">float</span></dt><dd><p>An estimate of the absolute error in the result.</p>\n</dd>\n<dt><strong>infodict</strong><span class=\"classifier\">dict</span></dt><dd><p>A dictionary containing additional information.\nRun scipy.integrate.quad_explain() for more information.</p>\n</dd>\n<dt>message</dt><dd><p>A convergence message.</p>\n</dd>\n<dt>explain</dt><dd><p>Appended only with \u2018cos\u2019 or \u2018sin\u2019 weighting and infinite\nintegration limits, it contains an explanation of the codes in\ninfodict[\u2018ierlst\u2019]</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Other Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>epsabs</strong><span class=\"classifier\">float or int, optional</span></dt><dd><p>Absolute error tolerance. Default is 1.49e-8. <cite>quad</cite> tries to obtain\nan accuracy of <code class=\"docutils literal notranslate\"><span class=\"pre\">abs(i-result)</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">max(epsabs,</span> <span class=\"pre\">epsrel*abs(i))</span></code>\nwhere <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> = integral of <cite>func</cite> from <cite>a</cite> to <cite>b</cite>, and <code class=\"docutils literal notranslate\"><span class=\"pre\">result</span></code> is the\nnumerical approximation. See <cite>epsrel</cite> below.</p>\n</dd>\n<dt><strong>epsrel</strong><span class=\"classifier\">float or int, optional</span></dt><dd><p>Relative error tolerance. Default is 1.49e-8.\nIf <code class=\"docutils literal notranslate\"><span class=\"pre\">epsabs</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">0</span></code>, <cite>epsrel</cite> must be greater than both 5e-29\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">50</span> <span class=\"pre\">*</span> <span class=\"pre\">(machine</span> <span class=\"pre\">epsilon)</span></code>. See <cite>epsabs</cite> above.</p>\n</dd>\n<dt><strong>limit</strong><span class=\"classifier\">float or int, optional</span></dt><dd><p>An upper bound on the number of subintervals used in the adaptive\nalgorithm.</p>\n</dd>\n<dt><strong>points</strong><span class=\"classifier\">(sequence of floats,ints), optional</span></dt><dd><p>A sequence of break points in the bounded integration interval\nwhere local difficulties of the integrand may occur (e.g.,\nsingularities, discontinuities). The sequence does not have\nto be sorted. Note that this option cannot be used in conjunction\nwith <code class=\"docutils literal notranslate\"><span class=\"pre\">weight</span></code>.</p>\n</dd>\n<dt><strong>weight</strong><span class=\"classifier\">float or int, optional</span></dt><dd><p>String indicating weighting function. Full explanation for this\nand the remaining arguments can be found below.</p>\n</dd>\n<dt><strong>wvar</strong><span class=\"classifier\">optional</span></dt><dd><p>Variables for use with weighting functions.</p>\n</dd>\n<dt><strong>wopts</strong><span class=\"classifier\">optional</span></dt><dd><p>Optional input for reusing Chebyshev moments.</p>\n</dd>\n<dt><strong>maxp1</strong><span class=\"classifier\">float or int, optional</span></dt><dd><p>An upper bound on the number of Chebyshev moments.</p>\n</dd>\n<dt><strong>limlst</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Upper bound on the number of cycles (&gt;=3) for use with a sinusoidal\nweighting and an infinite end-point.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dblquad</span></code></dt><dd><p>double integral</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tplquad</span></code></dt><dd><p>triple integral</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nquad</span></code></dt><dd><p>n-dimensional integrals (uses <cite>quad</cite> recursively)</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fixed_quad</span></code></dt><dd><p>fixed-order Gaussian quadrature</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadrature</span></code></dt><dd><p>adaptive Gaussian quadrature</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odeint</span></code></dt><dd><p>ODE integrator</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ode</span></code></dt><dd><p>ODE integrator</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">simps</span></code></dt><dd><p>integrator for sampled data</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">romb</span></code></dt><dd><p>integrator for sampled data</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special</span></code></dt><dd><p>for coefficients and roots of orthogonal polynomials</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p><strong>Extra information for quad() inputs and outputs</strong></p>\n<p>If full_output is non-zero, then the third output argument\n(infodict) is a dictionary with entries as tabulated below. For\ninfinite limits, the range is transformed to (0,1) and the\noptional outputs are given with respect to this transformed range.\nLet M be the input argument limit and let K be infodict[\u2018last\u2019].\nThe entries are:</p>\n<dl class=\"simple\">\n<dt>\u2018neval\u2019</dt><dd><p>The number of function evaluations.</p>\n</dd>\n<dt>\u2018last\u2019</dt><dd><p>The number, K, of subintervals produced in the subdivision process.</p>\n</dd>\n<dt>\u2018alist\u2019</dt><dd><p>A rank-1 array of length M, the first K elements of which are the\nleft end points of the subintervals in the partition of the\nintegration range.</p>\n</dd>\n<dt>\u2018blist\u2019</dt><dd><p>A rank-1 array of length M, the first K elements of which are the\nright end points of the subintervals.</p>\n</dd>\n<dt>\u2018rlist\u2019</dt><dd><p>A rank-1 array of length M, the first K elements of which are the\nintegral approximations on the subintervals.</p>\n</dd>\n<dt>\u2018elist\u2019</dt><dd><p>A rank-1 array of length M, the first K elements of which are the\nmoduli of the absolute error estimates on the subintervals.</p>\n</dd>\n<dt>\u2018iord\u2019</dt><dd><p>A rank-1 integer array of length M, the first L elements of\nwhich are pointers to the error estimates over the subintervals\nwith <code class=\"docutils literal notranslate\"><span class=\"pre\">L=K</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">K&lt;=M/2+2</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">L=M+1-K</span></code> otherwise. Let I be the\nsequence <code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['iord']</span></code> and let E be the sequence\n<code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['elist']</span></code>.  Then <code class=\"docutils literal notranslate\"><span class=\"pre\">E[I[1]],</span> <span class=\"pre\">...,</span> <span class=\"pre\">E[I[L]]</span></code> forms a\ndecreasing sequence.</p>\n</dd>\n</dl>\n<p>If the input argument points is provided (i.e., it is not None),\nthe following additional outputs are placed in the output\ndictionary. Assume the points sequence is of length P.</p>\n<dl class=\"simple\">\n<dt>\u2018pts\u2019</dt><dd><p>A rank-1 array of length P+2 containing the integration limits\nand the break points of the intervals in ascending order.\nThis is an array giving the subintervals over which integration\nwill occur.</p>\n</dd>\n<dt>\u2018level\u2019</dt><dd><p>A rank-1 integer array of length M (=limit), containing the\nsubdivision levels of the subintervals, i.e., if (aa,bb) is a\nsubinterval of <code class=\"docutils literal notranslate\"><span class=\"pre\">(pts[1],</span> <span class=\"pre\">pts[2])</span></code> where <code class=\"docutils literal notranslate\"><span class=\"pre\">pts[0]</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">pts[2]</span></code>\nare adjacent elements of <code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['pts']</span></code>, then (aa,bb) has level l\nif <code class=\"docutils literal notranslate\"><span class=\"pre\">|bb-aa|</span> <span class=\"pre\">=</span> <span class=\"pre\">|pts[2]-pts[1]|</span> <span class=\"pre\">*</span> <span class=\"pre\">2**(-l)</span></code>.</p>\n</dd>\n<dt>\u2018ndin\u2019</dt><dd><p>A rank-1 integer array of length P+2. After the first integration\nover the intervals (pts[1], pts[2]), the error estimates over some\nof the intervals may have been increased artificially in order to\nput their subdivision forward. This array has ones in slots\ncorresponding to the subintervals for which this happens.</p>\n</dd>\n</dl>\n<p><strong>Weighting the integrand</strong></p>\n<p>The input variables, <em>weight</em> and <em>wvar</em>, are used to weight the\nintegrand by a select list of functions. Different integration\nmethods are used to compute the integral with these weighting\nfunctions, and these do not support specifying break points. The\npossible values of weight and the corresponding weighting functions are.</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 15%\" />\n<col style=\"width: 53%\" />\n<col style=\"width: 32%\" />\n</colgroup>\n<thead>\n<tr class=\"row-odd\"><th class=\"head\"><p><code class=\"docutils literal notranslate\"><span class=\"pre\">weight</span></code></p></th>\n<th class=\"head\"><p>Weight function used</p></th>\n<th class=\"head\"><p><code class=\"docutils literal notranslate\"><span class=\"pre\">wvar</span></code></p></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"row-even\"><td><p>\u2018cos\u2019</p></td>\n<td><p>cos(w*x)</p></td>\n<td><p>wvar = w</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p>\u2018sin\u2019</p></td>\n<td><p>sin(w*x)</p></td>\n<td><p>wvar = w</p></td>\n</tr>\n<tr class=\"row-even\"><td><p>\u2018alg\u2019</p></td>\n<td><p>g(x) = ((x-a)**alpha)*((b-x)**beta)</p></td>\n<td><p>wvar = (alpha, beta)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p>\u2018alg-loga\u2019</p></td>\n<td><p>g(x)*log(x-a)</p></td>\n<td><p>wvar = (alpha, beta)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p>\u2018alg-logb\u2019</p></td>\n<td><p>g(x)*log(b-x)</p></td>\n<td><p>wvar = (alpha, beta)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p>\u2018alg-log\u2019</p></td>\n<td><p>g(x)*log(x-a)*log(b-x)</p></td>\n<td><p>wvar = (alpha, beta)</p></td>\n</tr>\n<tr class=\"row-even\"><td><p>\u2018cauchy\u2019</p></td>\n<td><p>1/(x-c)</p></td>\n<td><p>wvar = c</p></td>\n</tr>\n</tbody>\n</table>\n<p>wvar holds the parameter w, (alpha, beta), or c depending on the weight\nselected. In these expressions, a and b are the integration limits.</p>\n<p>For the \u2018cos\u2019 and \u2018sin\u2019 weighting, additional inputs and outputs are\navailable.</p>\n<p>For finite integration limits, the integration is performed using a\nClenshaw-Curtis method which uses Chebyshev moments. For repeated\ncalculations, these moments are saved in the output dictionary:</p>\n<dl class=\"simple\">\n<dt>\u2018momcom\u2019</dt><dd><p>The maximum level of Chebyshev moments that have been computed,\ni.e., if <code class=\"docutils literal notranslate\"><span class=\"pre\">M_c</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['momcom']</span></code> then the moments have been\ncomputed for intervals of length <code class=\"docutils literal notranslate\"><span class=\"pre\">|b-a|</span> <span class=\"pre\">*</span> <span class=\"pre\">2**(-l)</span></code>,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">l=0,1,...,M_c</span></code>.</p>\n</dd>\n<dt>\u2018nnlog\u2019</dt><dd><p>A rank-1 integer array of length M(=limit), containing the\nsubdivision levels of the subintervals, i.e., an element of this\narray is equal to l if the corresponding subinterval is\n<code class=\"docutils literal notranslate\"><span class=\"pre\">|b-a|*</span> <span class=\"pre\">2**(-l)</span></code>.</p>\n</dd>\n<dt>\u2018chebmo\u2019</dt><dd><p>A rank-2 array of shape (25, maxp1) containing the computed\nChebyshev moments. These can be passed on to an integration\nover the same interval by passing this array as the second\nelement of the sequence wopts and passing infodict[\u2018momcom\u2019] as\nthe first element.</p>\n</dd>\n</dl>\n<p>If one of the integration limits is infinite, then a Fourier integral is\ncomputed (assuming w neq 0). If full_output is 1 and a numerical error\nis encountered, besides the error message attached to the output tuple,\na dictionary is also appended to the output tuple which translates the\nerror codes in the array <code class=\"docutils literal notranslate\"><span class=\"pre\">info['ierlst']</span></code> to English messages. The\noutput information dictionary contains the following entries instead of\n\u2018last\u2019, \u2018alist\u2019, \u2018blist\u2019, \u2018rlist\u2019, and \u2018elist\u2019:</p>\n<dl class=\"simple\">\n<dt>\u2018lst\u2019</dt><dd><p>The number of subintervals needed for the integration (call it <code class=\"docutils literal notranslate\"><span class=\"pre\">K_f</span></code>).</p>\n</dd>\n<dt>\u2018rslst\u2019</dt><dd><p>A rank-1 array of length M_f=limlst, whose first <code class=\"docutils literal notranslate\"><span class=\"pre\">K_f</span></code> elements\ncontain the integral contribution over the interval\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(a+(k-1)c,</span> <span class=\"pre\">a+kc)</span></code> where <code class=\"docutils literal notranslate\"><span class=\"pre\">c</span> <span class=\"pre\">=</span> <span class=\"pre\">(2*floor(|w|)</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">pi</span> <span class=\"pre\">/</span> <span class=\"pre\">|w|</span></code>\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">k=1,2,...,K_f</span></code>.</p>\n</dd>\n<dt>\u2018erlst\u2019</dt><dd><p>A rank-1 array of length <code class=\"docutils literal notranslate\"><span class=\"pre\">M_f</span></code> containing the error estimate\ncorresponding to the interval in the same position in\n<code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['rslist']</span></code>.</p>\n</dd>\n<dt>\u2018ierlst\u2019</dt><dd><p>A rank-1 integer array of length <code class=\"docutils literal notranslate\"><span class=\"pre\">M_f</span></code> containing an error flag\ncorresponding to the interval in the same position in\n<code class=\"docutils literal notranslate\"><span class=\"pre\">infodict['rslist']</span></code>.  See the explanation dictionary (last entry\nin the output tuple) for the meaning of the codes.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Calculate <span class=\"math notranslate nohighlight\">\\(\\int^4_0 x^2 dx\\)</span> and compare with an analytic result</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">integrate</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"go\">(21.333333333333332, 2.3684757858670003e-13)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">**</span><span class=\"mi\">3</span> <span class=\"o\">/</span> <span class=\"mf\">3.</span><span class=\"p\">)</span>  <span class=\"c1\"># analytical result</span>\n<span class=\"go\">21.3333333333</span>\n</pre></div>\n</div>\n<p>Calculate <span class=\"math notranslate nohighlight\">\\(\\int^\\infty_0 e^{-x} dx\\)</span></p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">invexp</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">invexp</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inf</span><span class=\"p\">)</span>\n<span class=\"go\">(1.0, 5.842605999138044e-11)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">a</span> <span class=\"p\">:</span> <span class=\"n\">a</span><span class=\"o\">*</span><span class=\"n\">x</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span>\n<span class=\"go\">0.5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span>\n<span class=\"go\">1.5</span>\n</pre></div>\n</div>\n<p>Calculate <span class=\"math notranslate nohighlight\">\\(\\int^1_0 x^2 + y^2 dx\\)</span> with ctypes, holding\ny parameter as 1:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">testlib</span><span class=\"o\">.</span><span class=\"n\">c</span> <span class=\"o\">=&gt;</span>\n    <span class=\"n\">double</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"nb\">int</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">double</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">]){</span>\n        <span class=\"k\">return</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];}</span>\n<span class=\"nb\">compile</span> <span class=\"n\">to</span> <span class=\"n\">library</span> <span class=\"n\">testlib</span><span class=\"o\">.*</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">integrate</span>\n<span class=\"kn\">import</span> <span class=\"nn\">ctypes</span>\n<span class=\"n\">lib</span> <span class=\"o\">=</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">CDLL</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/.../testlib.*&#39;</span><span class=\"p\">)</span> <span class=\"c1\">#use absolute path</span>\n<span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"o\">.</span><span class=\"n\">restype</span> <span class=\"o\">=</span> <span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_double</span>\n<span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"o\">.</span><span class=\"n\">argtypes</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_int</span><span class=\"p\">,</span><span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_double</span><span class=\"p\">)</span>\n<span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">lib</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"c1\">#(1.3333333333333333, 1.4802973661668752e-14)</span>\n<span class=\"nb\">print</span><span class=\"p\">((</span><span class=\"mf\">1.0</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"o\">/</span><span class=\"mf\">3.0</span> <span class=\"o\">+</span> <span class=\"mf\">1.0</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"o\">**</span><span class=\"mi\">3</span><span class=\"o\">/</span><span class=\"mf\">3.0</span> <span class=\"o\">+</span> <span class=\"mf\">0.0</span><span class=\"p\">))</span> <span class=\"c1\">#Analytic result</span>\n<span class=\"c1\"># 1.3333333333333333</span>\n</pre></div>\n</div>\n<p>Be aware that pulse shapes and other sharp features as compared to the\nsize of the integration interval may not be integrated correctly using\nthis method. A simplified example of this limitation is integrating a\ny-axis reflected step function with many zero values within the integrals\nbounds.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">x</span><span class=\"o\">&lt;=</span><span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">(1.0, 1.1102230246251565e-14)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"go\">(1.0000000002199108, 1.0189464580163188e-08)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">integrate</span><span class=\"o\">.</span><span class=\"n\">quad</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10000</span><span class=\"p\">)</span>\n<span class=\"go\">(0.0, 0.0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sph-harm\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#real-sph-harm\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sym-sh-basis\">\n<h3>real_sym_sh_basis<a class=\"headerlink\" href=\"#real-sym-sh-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.real_sym_sh_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">real_sym_sh_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.real_sym_sh_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>\n<p>dipy.reconst.shm.real_sym_sh_basis is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere\ngiven by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same\nway as in Descoteaux et al. 2007 <a class=\"reference internal\" href=\"#r434b25cab165-1\" id=\"id147\">[1]</a> where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is\ndefined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>even int &gt; 0, max spherical harmonic order</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code></p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">array</span></dt><dd><p>The degree of the harmonics.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">array</span></dt><dd><p>The order of the harmonics.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r434b25cab165-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id147\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"recursive-response\">\n<h3>recursive_response<a class=\"headerlink\" href=\"#recursive-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.recursive_response\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">recursive_response</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">peak_thr=0.01</em>, <em class=\"sig-param\">init_fa=0.08</em>, <em class=\"sig-param\">init_trace=0.0021</em>, <em class=\"sig-param\">iter=8</em>, <em class=\"sig-param\">convergence=0.001</em>, <em class=\"sig-param\">parallel=True</em>, <em class=\"sig-param\">nbr_processes=None</em>, <em class=\"sig-param\">sphere=&lt;dipy.core.sphere.HemiSphere object&gt;</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.recursive_response\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Recursive calibration of response function using peak threshold</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray, optional</span></dt><dd><p>mask for recursive calibration, for example a white matter mask. It has\nshape <cite>data.shape[0:3]</cite> and dtype=bool. Default: use the entire data\narray.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>\n</dd>\n<dt><strong>peak_thr</strong><span class=\"classifier\">float, optional</span></dt><dd><p>peak threshold, how large the second peak can be relative to the first\npeak in order to call it a single fiber population [1]. Default: 0.01</p>\n</dd>\n<dt><strong>init_fa</strong><span class=\"classifier\">float, optional</span></dt><dd><p>FA of the initial \u2018fat\u2019 response function (tensor). Default: 0.08</p>\n</dd>\n<dt><strong>init_trace</strong><span class=\"classifier\">float, optional</span></dt><dd><p>trace of the initial \u2018fat\u2019 response function (tensor). Default: 0.0021</p>\n</dd>\n<dt><strong>iter</strong><span class=\"classifier\">int, optional</span></dt><dd><p>maximum number of iterations for calibration. Default: 8.</p>\n</dd>\n<dt><strong>convergence</strong><span class=\"classifier\">float, optional</span></dt><dd><p>convergence criterion, maximum relative change of SH\ncoefficients. Default: 0.001.</p>\n</dd>\n<dt><strong>parallel</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to use parallelization in peak-finding during the calibration\nprocedure. Default: True</p>\n</dd>\n<dt><strong>nbr_processes: int</strong></dt><dd><p>If <cite>parallel</cite> is True, the number of subprocesses to use\n(default multiprocessing.cpu_count()).</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere, optional.</span></dt><dd><p>The sphere used for peak finding. Default: default_sphere.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">ndarray</span></dt><dd><p>response function in SH coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. Using an FA threshold is not a very robust method.\nIt is dependent on the dataset (non-informed used subjectivity), and still\ndepends on the diffusion tensor (FA and first eigenvector),\nwhich has low accuracy at high b-value. This function recursively\ncalibrates the response function, for more information see [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rbeb1f12bf5b3-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tax, C.M.W., et al. NeuroImage 2014. Recursive calibration of\nthe fiber response function for spherical deconvolution of\ndiffusion MRI data.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"response-from-mask\">\n<h3>response_from_mask<a class=\"headerlink\" href=\"#response-from-mask\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.response_from_mask\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">response_from_mask</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.response_from_mask\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>\n</dd>\n</dl>\n<p>dipy.reconst.csdeconv.response_from_mask is deprecated, Please use dipy.reconst.csdeconv.response_from_mask_ssst instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.2</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 1.4</p></li>\n</ul>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the response function</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. This information can be obtained by using\ncsdeconv.mask_for_response_ssst() through a mask of selected voxels\n(see[R64bc28ca561d-1]_). The present function uses such a mask to compute the ssst\nresponse function.</p>\n<p>For the response we also need to find the average S0 in the ROI. This is\npossible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which\ncorrespond to b-values equal 0) in the dataset.</p>\n<p>The <cite>response</cite> consists always of a prolate tensor created by averaging\nthe highest and second highest eigenvalues in the ROI with FA higher than\nthreshold. We also include the average S0s.</p>\n<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r64bc28ca561d-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>\n</dd>\n</dl>\n<p>fiber orientation density function from diffusion-weighted MRI\ndata using spherical deconvolution</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"response-from-mask-ssst\">\n<h3>response_from_mask_ssst<a class=\"headerlink\" href=\"#response-from-mask-ssst\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.response_from_mask_ssst\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">response_from_mask_ssst</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.response_from_mask_ssst\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the response function</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. This information can be obtained by using\ncsdeconv.mask_for_response_ssst() through a mask of selected voxels\n(see[Rb280cc58c30e-1]_). The present function uses such a mask to compute the ssst\nresponse function.</p>\n<p>For the response we also need to find the average S0 in the ROI. This is\npossible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which\ncorrespond to b-values equal 0) in the dataset.</p>\n<p>The <cite>response</cite> consists always of a prolate tensor created by averaging\nthe highest and second highest eigenvalues in the ROI with FA higher than\nthreshold. We also include the average S0s.</p>\n<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb280cc58c30e-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>\n</dd>\n</dl>\n<p>fiber orientation density function from diffusion-weighted MRI\ndata using spherical deconvolution</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sh-to-rh\">\n<h3>sh_to_rh<a class=\"headerlink\" href=\"#sh-to-rh\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.sh_to_rh\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">sh_to_rh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_sh</em>, <em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.sh_to_rh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>\n<p>Calculate the rotational harmonic decomposition up to\nharmonic order <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>, degree <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code> for an axially and antipodally\nsymmetric function. Note that all <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span> <span class=\"pre\">!=</span> <span class=\"pre\">0</span></code> coefficients\nwill be ignored as axial symmetry is assumed. Hence, there\nwill be <code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order/2</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span></code> non-zero coefficients.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r_sh</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>ndarray of SH coefficients for the single fiber response function.\nThese coefficients must correspond to the real spherical harmonic\nfunctions produced by <cite>shm.real_sph_harm</cite>.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The degree of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The order of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>r_rh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sph_harm</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sym_sh_basis</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rfcfdfef87aa2-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the\nfibre orientation distribution in diffusion MRI: Non-negativity\nconstrained super-resolved spherical deconvolution</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"single-tensor\">\n<h3>single_tensor<a class=\"headerlink\" href=\"#single-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.single_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">single_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1</em>, <em class=\"sig-param\">evals=None</em>, <em class=\"sig-param\">evecs=None</em>, <em class=\"sig-param\">snr=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.single_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Simulate diffusion-weighted signals with a single tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Table with information of b-values and gradient directions g.\nNote that if gtab has a btens attribute, simulations will be performed\naccording to the given b-tensor B information.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">double,</span></dt><dd><p>Strength of signal in the presence of no diffusion gradient (also\ncalled the <code class=\"docutils literal notranslate\"><span class=\"pre\">b=0</span></code> value).</p>\n</dd>\n<dt><strong>evals</strong><span class=\"classifier\">(3,) ndarray</span></dt><dd><p>Eigenvalues of the diffusion tensor.  By default, values typical for\nprolate white matter are used.</p>\n</dd>\n<dt><strong>evecs</strong><span class=\"classifier\">(3, 3) ndarray</span></dt><dd><p>Eigenvectors of the tensor.  You can also think of this as a rotation\nmatrix that transforms the direction of the tensor. The eigenvectors\nneed to be column wise.</p>\n</dd>\n<dt><strong>snr</strong><span class=\"classifier\">float</span></dt><dd><p>Signal to noise ratio, assuming Rician noise.  None implies no noise.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><dl class=\"simple\">\n<dt>Simulated signal:</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">S(b,</span> <span class=\"pre\">g)</span> <span class=\"pre\">=</span> <span class=\"pre\">S_0</span> <span class=\"pre\">e^(-b</span> <span class=\"pre\">g^T</span> <span class=\"pre\">R</span> <span class=\"pre\">D</span> <span class=\"pre\">R.T</span> <span class=\"pre\">g)</span></code>, if gtab.tens=None\n<code class=\"docutils literal notranslate\"><span class=\"pre\">S(B)</span> <span class=\"pre\">=</span> <span class=\"pre\">S_0</span> <span class=\"pre\">e^(-B:D)</span></code>, if gtab.tens information is given</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re8d2d5c91ad1-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>M. Descoteaux, \u201cHigh Angular Resolution Diffusion MRI: from Local\nEstimation to Segmentation and Tractography\u201d, PhD thesis,\nUniversity of Nice-Sophia Antipolis, p. 42, 2008.</p>\n</dd>\n<dt class=\"label\" id=\"re8d2d5c91ad1-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>E. Stejskal and J. Tanner, \u201cSpin diffusion measurements: spin echos\nin the presence of a time-dependent field gradient\u201d, Journal of\nChemical Physics, nr. 42, pp. 288\u2013292, 1965.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sph-harm-ind-list\">\n<h3>sph_harm_ind_list<a class=\"headerlink\" href=\"#sph-harm-ind-list\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.sph_harm_ind_list\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">sph_harm_ind_list</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.sph_harm_ind_list\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical\nharmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>. The results,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">m_list</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">n_list</span></code> are kx1 arrays, where k depends on <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.\nThey can be passed to <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">real_sh_descoteaux_from_index()</span></code> and\n:func:<code class=\"docutils literal notranslate\"><span class=\"pre\">real_sh_tournier_from_index</span></code>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>even int &gt; 0, max order to return</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for SH basis with even and odd order terms</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>m_list</strong><span class=\"classifier\">array</span></dt><dd><p>degrees of even spherical harmonics</p>\n</dd>\n<dt><strong>n_list</strong><span class=\"classifier\">array</span></dt><dd><p>orders of even spherical harmonics</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_descoteaux_from_index</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_tournier_from_index</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"vec2vec-rotmat\">\n<h3>vec2vec_rotmat<a class=\"headerlink\" href=\"#vec2vec-rotmat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.csdeconv.vec2vec_rotmat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.csdeconv.</code><code class=\"sig-name descname\">vec2vec_rotmat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">u</em>, <em class=\"sig-param\">v</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.csdeconv.vec2vec_rotmat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>rotation matrix from 2 unit vectors</p>\n<p>u, v being unit 3d vectors return a 3x3 rotation matrix R than aligns u to\nv.</p>\n<p>In general there are many rotations that will map u to v. If S is any\nrotation using v as an axis then R.S will also map u to v since (S.R)u =\nS(Ru) = Sv = v.  The rotation R returned by vec2vec_rotmat leaves fixed the\nperpendicular to the plane spanned by u and v.</p>\n<p>The transpose of R will align v to u.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>u</strong><span class=\"classifier\">array, shape(3,)</span></dt><dd></dd>\n<dt><strong>v</strong><span class=\"classifier\">array, shape(3,)</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>R</strong><span class=\"classifier\">array, shape(3,3)</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.geometry</span> <span class=\"k\">import</span> <span class=\"n\">vec2vec_rotmat</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">u</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">v</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">R</span><span class=\"o\">=</span><span class=\"n\">vec2vec_rotmat</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 0.,  1.,  0.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 1.,  0.,  0.])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionkurtosisfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit\" title=\"dipy.reconst.dki.DiffusionKurtosisFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a><a class=\"headerlink\" href=\"#diffusionkurtosisfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">DiffusionKurtosisFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit\" title=\"dipy.reconst.dti.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dti.TensorFit</span></code></a></p>\n<p>Class for fitting the Diffusion Kurtosis Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kfa\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.kfa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kfa</span></code></a></dt><dd><p>Returns the kurtosis tensor (KFA) <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id155\">1</a>.</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kt\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.kt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kt</span></code></a></dt><dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.ak\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.ak\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ak</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r9df403773432-1\" id=\"id156\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.akc\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.akc\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">akc</span></code></a>(sphere)</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kmax\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.kmax\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kmax</span></code></a>([sphere,\u00a0gtol,\u00a0mask])</p></td>\n<td><p>Computes the maximum value of a single voxel kurtosis tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.mk\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.mk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mk</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.mkt\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.mkt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mkt</span></code></a>([min_kurtosis,\u00a0max_kurtosis])</p></td>\n<td><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#ra282416a9af8-1\" id=\"id157\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.predict\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a DKI model fit, predict the signal on the vertices of a gradient table</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.rk\" title=\"dipy.reconst.dki.DiffusionKurtosisFit.rk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rk</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r1ebb108e90df-1\" id=\"id158\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a DiffusionKurtosisFit class instance.</p>\n<p>Since DKI is an extension of DTI, class instance is defined as subclass\nof the TensorFit from dti.py</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>model</strong><span class=\"classifier\">DiffusionKurtosisModel Class instance</span></dt><dd><p>Class instance containing the Diffusion Kurtosis Model for the fit</p>\n</dd>\n<dt><strong>model_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.ak\">\n<code class=\"sig-name descname\">ak</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.ak\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r9df403773432-1\" id=\"id159\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r9df403773432-2\" id=\"id160\">[2]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,\notherwise it will be computed from the apparent diffusion kurtosis\nvalues along the principal axis of the diffusion tensor\n(see notes). Default is set to True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ak</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated AK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>AK is defined as the directional kurtosis parallel to the fiber\u2019s main\ndirection e1 <a class=\"reference internal\" href=\"#r9df403773432-1\" id=\"id161\">[1]</a>, <a class=\"reference internal\" href=\"#r9df403773432-2\" id=\"id162\">[2]</a>. You can compute AK using to approaches:</p>\n<ol class=\"arabic simple\">\n<li><p>AK is calculated from rotated diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r9df403773432-2\" id=\"id163\">[2]</a>, i.e.:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = \\hat{W}_{1111}\n\\frac{(\\lambda_{1}+\\lambda_{2}+\\lambda_{3})^2}{(9 \\lambda_{1}^2)}\\]</div>\n<ol class=\"arabic simple\" start=\"2\">\n<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = K(\\mathbf{\\mathbf{e}_1)\\]</div>\n<p>Although both approaches leads to an exact calculation of AK, the\nfirst approach will be referred to as the analytical method while the\nsecond approach will be referred to as the numerical method based on\ntheir analogy to the estimation strategies for MK and RK.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9df403773432-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id156\">1</a>,<a href=\"#id159\">2</a>,<a href=\"#id161\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r9df403773432-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id160\">1</a>,<a href=\"#id162\">2</a>,<a href=\"#id163\">3</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r9df403773432-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.akc\">\n<code class=\"sig-name descname\">akc</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.akc\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each\ndirection on the sphere for each voxel in the data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>akc</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The estimates of the apparent kurtosis coefficient in every\ndirection on the input sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For each sphere direction with coordinates <span class=\"math notranslate nohighlight\">\\((n_{1}, n_{2}, n_{3})\\)</span>, the\ncalculation of AKC is done using formula:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AKC(n)=\\frac{MD^{2}}{ADC(n)^{2}}\\sum_{i=1}^{3}\\sum_{j=1}^{3}\n\\sum_{k=1}^{3}\\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W_{ijkl}\\)</span> are the elements of the kurtosis tensor, MD the mean\ndiffusivity and ADC the apparent diffusion coefficent computed as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[ADC(n)=\\sum_{i=1}^{3}\\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(D_{ij}\\)</span> are the elements of the diffusion tensor.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.kfa\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">kfa</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the kurtosis tensor (KFA) <a class=\"reference internal\" href=\"#rb07585803425-1\" id=\"id167\">[1]</a>.</p>\n<p class=\"rubric\">Notes</p>\n<p>The KFA is defined as <a class=\"reference internal\" href=\"#rb07585803425-1\" id=\"id168\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[KFA \\equiv\n\\frac{||\\mathbf{W} - MKT \\mathbf{I}^{(4)}||_F}{||\\mathbf{W}||_F}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W\\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class=\"math notranslate nohighlight\">\\(I^(4)\\)</span>\nis the fully symmetric rank 2 isotropic tensor and <span class=\"math notranslate nohighlight\">\\(||...||_F\\)</span> is the\ntensor\u2019s Frobenius norm <a class=\"reference internal\" href=\"#rb07585803425-1\" id=\"id169\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb07585803425-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id167\">1</a>,<a href=\"#id168\">2</a>,<a href=\"#id169\">3</a>)</span></dt>\n<dd><p>Glenn, G. R., Helpern, J. A., Tabesh, A., and Jensen, J. H.\n(2015). Quantitative assessment of diffusional kurtosis\nanisotropy. NMR in Biomedicine 28, 448\u2013459. doi:10.1002/nbm.3271</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.kmax\">\n<code class=\"sig-name descname\">kmax</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=1e-05</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kmax\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the maximum value of a single voxel kurtosis tensor</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of\nthe maximum value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the\ndirections sampled on the sphere class instance. The gradient of\nthe convergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken\nfrom the initial sampled directions of the given sphere object</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>max_value</strong><span class=\"classifier\">float</span></dt><dd><p>kurtosis tensor maximum value</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.kt\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">kt</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.kt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.mk\">\n<code class=\"sig-name descname\">mk</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.mk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r1a4c5980fd18-4\" id=\"id171\">[4]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, MK is calculated using its analytical solution, otherwise\nan exact numerical estimator is used (see Notes). Default is set to\nTrue.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MK is defined as the average of directional kurtosis coefficients\nacross all spatial directions, which can be formulated by the following\nsurface integral[R1a4c5980fd18-1]_:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MK \\equiv \\frac{1}{4\\pi} \\int d\\Omega_\\mathbf{n} K(\\mathbf{n})\\]</div>\n<p>This integral can be numerically solved by averaging directional\nkurtosis values sampled for directions of a spherical t-design <a class=\"reference internal\" href=\"#r1a4c5980fd18-2\" id=\"id172\">[2]</a>.</p>\n<p>Alternatively, MK can be solved from the analytical solution derived by\nTabesh et al. <a class=\"reference internal\" href=\"#r1a4c5980fd18-3\" id=\"id173\">[3]</a>. This solution is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\begin{split}MK=F_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{1111}+\n   F_1(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{2222}+\n   F_1(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{3333}+ \\\\\n   F_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}+\n   F_2(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{1133}+\n   F_2(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{1122}\\end{split}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{W}_{ijkl}\\)</span> are the components of the <span class=\"math notranslate nohighlight\">\\(W\\)</span> tensor in the\ncoordinates system defined by the eigenvectors of the diffusion tensor\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{D}\\)</span> and</p>\n<div class=\"math notranslate nohighlight\">\n\\[ \\begin{align}\\begin{aligned}\\begin{split}F_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{18(\\lambda_1-\\lambda_2)(\\lambda_1-\\lambda_3)}\n[\\frac{\\sqrt{\\lambda_2\\lambda_3}}{\\lambda_1}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{3\\lambda_1^2-\\lambda_1\\lambda_2-\\lambda_2\\lambda_3-\n\\lambda_1\\lambda_3}\n{3\\lambda_1 \\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-1 ]\\end{split}\\\\\\begin{split}F_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{3(\\lambda_2-\\lambda_3)^2}\n[\\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{2\\lambda_1-\\lambda_2-\\lambda_3}{3\\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-2]\\end{split}\\end{aligned}\\end{align} \\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(R_f\\)</span> and <span class=\"math notranslate nohighlight\">\\(R_d\\)</span> are the Carlson\u2019s elliptic integrals.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1a4c5980fd18-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r1a4c5980fd18-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id172\">2</a></span></dt>\n<dd><p>Hardin, R.H., Sloane, N.J.A., 1996. McLaren\u2019s Improved Snub Cube\nand Other New Spherical Designs in Three Dimensions. Discrete\nand Computational Geometry 15, 429-441.</p>\n</dd>\n<dt class=\"label\" id=\"r1a4c5980fd18-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id173\">3</a></span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r1a4c5980fd18-4\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id171\">4</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.mkt\">\n<code class=\"sig-name descname\">mkt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.mkt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#ra282416a9af8-1\" id=\"id178\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#ra282416a9af8-2\" id=\"id179\">[2]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mkt</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MKT is defined as <a class=\"reference internal\" href=\"#ra282416a9af8-1\" id=\"id180\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MKT \\equiv \\frac{1}{4\\pi} \\int d\n\\Omega_{\\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\\]</div>\n<p>which can be directly computed from the trace of the kurtosis tensor:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}\n(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra282416a9af8-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id157\">1</a>,<a href=\"#id178\">2</a>,<a href=\"#id180\">3</a>)</span></dt>\n<dd><p>Hansen, B., Lund, T. E., Sangill, R., and Jespersen, S. N. 2013.\nExperimentally and computationally fast method for estimation\nof a mean kurtosis. Magnetic Resonance in Medicine69, 1754\u20131760.\n388. doi:10.1002/mrm.24743</p>\n</dd>\n<dt class=\"label\" id=\"ra282416a9af8-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id179\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a DKI model fit, predict the signal on the vertices of a\ngradient table</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[S(n,b)=S_{0}e^{-bD(n)+\\frac{1}{6}b^{2}D(n)^{2}K(n)}\\]</div>\n<p><span class=\"math notranslate nohighlight\">\\(\\mathbf{D(n)}\\)</span> and <span class=\"math notranslate nohighlight\">\\(\\mathbf{K(n)}\\)</span> can be computed from the DT and KT\nusing the following equations:</p>\n<div class=\"math notranslate nohighlight\">\n\\[D(n)=\\sum_{i=1}^{3}\\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\\]</div>\n<p>and</p>\n<div class=\"math notranslate nohighlight\">\n\\[K(n)=\\frac{MD^{2}}{D(n)^{2}}\\sum_{i=1}^{3}\\sum_{j=1}^{3}\n\\sum_{k=1}^{3}\\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(D_{ij}\\)</span> and <span class=\"math notranslate nohighlight\">\\(W_{ijkl}\\)</span> are the elements of the second-order DT\nand the fourth-order KT tensors, respectively, and <span class=\"math notranslate nohighlight\">\\(MD\\)</span> is the mean\ndiffusivity.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisFit.rk\">\n<code class=\"sig-name descname\">rk</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit.rk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r1ebb108e90df-1\" id=\"id183\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,\nradial kurtosis values that are smaller than <cite>min_kurtosis</cite> are\nreplaced with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis\nlimit for regions that consist of water confined to spherical pores\n<a class=\"reference internal\" href=\"#r1ebb108e90df-3\" id=\"id184\">[3]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,\nradial kurtosis values that are larger than <cite>max_kurtosis</cite> are\nreplaced with <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise\nan exact numerical estimator is used (see Notes). Default is set to\nTrue</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated RK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RK is defined as the average of the directional kurtosis perpendicular\nto the fiber\u2019s main direction e1 <a class=\"reference internal\" href=\"#r1ebb108e90df-1\" id=\"id185\">[1]</a>, <a class=\"reference internal\" href=\"#r1ebb108e90df-2\" id=\"id186\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<dl class=\"simple\">\n<dt>RK equiv frac{1}{2pi} int dOmega _mathbf{theta}</dt><dd><p>K(mathbf{theta}) delta (mathbf{theta}cdot mathbf{e}_1)</p>\n</dd>\n</dl>\n<p>This equation can be numerically computed by averaging apparent\ndirectional kurtosis samples for directions perpendicular to e1.</p>\n<p>Otherwise, RK can be calculated from its analytical solution <a class=\"reference internal\" href=\"#r1ebb108e90df-2\" id=\"id187\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[K_{\\bot} = G_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2222} +\n           G_1(\\lambda_1,\\lambda_3,\\lambda_2)\\hat{W}_{3333} +\n           G_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}\\]</div>\n<p>where:</p>\n<div class=\"math notranslate nohighlight\">\n\\[G_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{18\\lambda_2(\\lambda_2-\n\\lambda_3)} \\left (2\\lambda_2 +\n\\frac{\\lambda_3^2-3\\lambda_2\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\n\\right)\\]</div>\n<p>and</p>\n<div class=\"math notranslate nohighlight\">\n\\[ G_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{(\\lambda_2-\\lambda_3)^2}\n\\left ( \\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}-\n2\\right )\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1ebb108e90df-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id158\">1</a>,<a href=\"#id183\">2</a>,<a href=\"#id185\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r1ebb108e90df-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id186\">1</a>,<a href=\"#id187\">2</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r1ebb108e90df-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id184\">3</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionkurtosismodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel\" title=\"dipy.reconst.dki.DiffusionKurtosisModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a><a class=\"headerlink\" href=\"#diffusionkurtosismodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">DiffusionKurtosisModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Class for the Diffusion Kurtosis Model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel.fit\" title=\"dipy.reconst.dki.DiffusionKurtosisModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the DKI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel.predict\" title=\"dipy.reconst.dki.DiffusionKurtosisModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(dki_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this DKI model class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion Kurtosis Tensor Model [1]</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:\n\u2018OLS\u2019 or \u2018ULLS\u2019 for ordinary least squares</p>\n<blockquote>\n<div><p>dki.ols_fit_dki</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 or \u2018UWLLS\u2019 for weighted ordinary least squares</dt><dd><p>dki.wls_fit_dki</p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id191\"><span class=\"problematic\" id=\"id192\">*</span></a>args, <a href=\"#id193\"><span class=\"problematic\" id=\"id194\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0d8411329c32-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.</p>\n</dd>\n</dl>\n<p>Estimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the DKI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal from one voxel.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.DiffusionKurtosisModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this DKI model class instance given\nparameters.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id196\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki.ReconstModel\" title=\"dipy.reconst.dki.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id196\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"tensorfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit\" title=\"dipy.reconst.dki.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a><a class=\"headerlink\" href=\"#tensorfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki.TensorFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">TensorFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.directions\" title=\"dipy.reconst.dki.TensorFit.directions\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></a></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.evals\" title=\"dipy.reconst.dki.TensorFit.evals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></a></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.evecs\" title=\"dipy.reconst.dki.TensorFit.evecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></a></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.quadratic_form\" title=\"dipy.reconst.dki.TensorFit.quadratic_form\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></a></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.ad\" title=\"dipy.reconst.dki.TensorFit.ad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code></a>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.adc\" title=\"dipy.reconst.dki.TensorFit.adc\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code></a>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.color_fa\" title=\"dipy.reconst.dki.TensorFit.color_fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code></a>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.fa\" title=\"dipy.reconst.dki.TensorFit.fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code></a>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.ga\" title=\"dipy.reconst.dki.TensorFit.ga\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code></a>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.linearity\" title=\"dipy.reconst.dki.TensorFit.linearity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.md\" title=\"dipy.reconst.dki.TensorFit.md\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code></a>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.mode\" title=\"dipy.reconst.dki.TensorFit.mode\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code></a>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.odf\" title=\"dipy.reconst.dki.TensorFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.planarity\" title=\"dipy.reconst.dki.TensorFit.planarity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.predict\" title=\"dipy.reconst.dki.TensorFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0,\u00a0step])</p></td>\n<td><p>Given a model fit, predict the signal on the vertices of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.rd\" title=\"dipy.reconst.dki.TensorFit.rd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code></a>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.sphericity\" title=\"dipy.reconst.dki.TensorFit.sphericity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki.TensorFit.trace\" title=\"dipy.reconst.dki.TensorFit.trace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code></a>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a TensorFit class instance.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.S0_hat\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">S0_hat</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.S0_hat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.ad\">\n<code class=\"sig-name descname\">ad</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.ad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ad</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated AD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AD = \\lambda_1\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.adc\">\n<code class=\"sig-name descname\">adc</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.adc\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><blockquote>\n<div><p>Calculate the apparent diffusion coefficient (ADC) in each direction on\nthe sphere for each voxel in the data</p>\n</div></blockquote>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adc</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The estimates of the apparent diffusion coefficient in every\ndirection on the input sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>ec{b} Q \nec{b}^T</p>\n<blockquote>\n<div><p>Where Q is the quadratic form of the tensor.</p>\n</div></blockquote>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.color_fa\">\n<code class=\"sig-name descname\">color_fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.color_fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Color fractional anisotropy of diffusion tensor</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.directions\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">directions</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.directions\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>For tracking - return the primary direction in each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.evals\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evals</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.evals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.evecs\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evecs</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.evecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.fa\">\n<code class=\"sig-name descname\">fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.ga\">\n<code class=\"sig-name descname\">ga</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.ga\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.linearity\">\n<code class=\"sig-name descname\">linearity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.linearity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>linearity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated linearity of the diffusion tensor <a class=\"reference internal\" href=\"#r63fc02bd3afb-1\" id=\"id197\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Linearity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Linearity =\n\\frac{\\lambda_1-\\lambda_2}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r63fc02bd3afb-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id197\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.lower_triangular\">\n<code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.md\">\n<code class=\"sig-name descname\">md</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.md\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1+\\lambda_2+\\lambda_3}{3}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.mode\">\n<code class=\"sig-name descname\">mode</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.mode\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Tensor mode calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The diffusion orientation distribution function (dODF). This is an\nestimate of the diffusion distance in each direction</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance.</span></dt><dd><p>The dODF is calculated in the vertices of this input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The diffusion distance in every direction of the sphere in every\nvoxel in the input data.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This is based on equation 3 in <a class=\"reference internal\" href=\"#rdedbfce4601d-1\" id=\"id199\">[1]</a>. To re-derive it from\nscratch, follow steps in <a class=\"reference internal\" href=\"#rdedbfce4601d-2\" id=\"id200\">[2]</a>, Section 7.9 Equation\n7.24 but with an <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the integral.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rdedbfce4601d-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id199\">1</a></span></dt>\n<dd><p>Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,\nK., &amp; Harel, N. (2010). Reconstruction of the orientation\ndistribution function in single- and multiple-shell q-ball imaging\nwithin constant solid angle. Magnetic Resonance in Medicine, 64(2),\n554-566. doi:DOI: 10.1002/mrm.22365</p>\n</dd>\n<dt class=\"label\" id=\"rdedbfce4601d-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id200\">2</a></span></dt>\n<dd><p>Descoteaux, M. (2008). PhD Thesis: High Angular\nResolution Diffusion MRI: from Local Estimation to Segmentation and\nTractography.\n<a class=\"reference external\" href=\"ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf\">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.planarity\">\n<code class=\"sig-name descname\">planarity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.planarity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#r2dfe917edb81-1\" id=\"id203\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity =\n\\frac{2 (\\lambda_2 - \\lambda_3)}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2dfe917edb81-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id203\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=None</em>, <em class=\"sig-param\">step=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:\nThe fitted S0 value in all voxels if it was fitted. Otherwise 1 in\nall voxels.</p>\n</dd>\n<dt><strong>step</strong><span class=\"classifier\">int</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with\ndefault value 10,000.</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. This parameter sets the number of\nvoxels that will be fit at once in each iteration. A larger step\nvalue should speed things up, but it will also take up more memory.\nIt is advisable to keep an eye on memory consumption as this value\nis increased.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[S(  heta, b) = S_0 * e^{-b ADC}\\]</div>\n<p>Where:\n.. math</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">ADC</span> <span class=\"o\">=</span>       <span class=\"n\">heta</span> <span class=\"n\">Q</span>  <span class=\"n\">heta</span><span class=\"o\">^</span><span class=\"n\">T</span>\n</pre></div>\n</div>\n<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for\nwhich a signal is to be predicted and <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b value provided in\nthe GradientTable input for that direction</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.quadratic_form\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">quadratic_form</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.quadratic_form\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.rd\">\n<code class=\"sig-name descname\">rd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.rd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>rd</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated RD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[RD = \\frac{\\lambda_2 + \\lambda_3}{2}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.sphericity\">\n<code class=\"sig-name descname\">sphericity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.sphericity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#rfaac9e9dfad2-1\" id=\"id205\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity = \\frac{3 \\lambda_3}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rfaac9e9dfad2-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id205\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki.TensorFit.trace\">\n<code class=\"sig-name descname\">trace</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.TensorFit.trace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>trace</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated trace.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The trace is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[trace = \\lambda_1 + \\lambda_2 + \\lambda_3\\]</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wcons\">\n<h3>Wcons<a class=\"headerlink\" href=\"#wcons\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.Wcons\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">Wcons</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">k_elements</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.Wcons\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Construct the full 4D kurtosis tensors from its 15 independent\nelements</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>k_elements</strong><span class=\"classifier\">(15,)</span></dt><dd><p>elements of the kurtosis tensor in the following order:</p>\n</dd>\n<dt><strong>.. math::</strong></dt><dd></dd>\n<dt><strong>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</strong></dt><dd><p>&amp; \u2026 \\\n&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}\n&amp; \u2026 \\\n&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}\n&amp; &amp; )end{matrix}</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>W</strong><span class=\"classifier\">array(3, 3, 3, 3)</span></dt><dd><p>Full 4D kurtosis tensor</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wrotate\">\n<h3>Wrotate<a class=\"headerlink\" href=\"#wrotate\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.Wrotate\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">Wrotate</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">kt</em>, <em class=\"sig-param\">Basis</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.Wrotate\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Rotate a kurtosis tensor from the standard Cartesian coordinate system\nto another coordinate system basis</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>kt</strong><span class=\"classifier\">(15,)</span></dt><dd><p>Vector with the 15 independent elements of the kurtosis tensor</p>\n</dd>\n<dt><strong>Basis</strong><span class=\"classifier\">array (3, 3)</span></dt><dd><p>Vectors of the basis column-wise oriented</p>\n</dd>\n<dt><strong>inds</strong><span class=\"classifier\">array(m, 4) (optional)</span></dt><dd><p>Array of vectors containing the four indexes of m specific elements of\nthe rotated kurtosis tensor. If not specified all 15 elements of the\nrotated kurtosis tensor are computed.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>Wrot</strong><span class=\"classifier\">array (m,) or (15,)</span></dt><dd><p>Vector with the m independent elements of the rotated kurtosis tensor.\nIf \u2018indices\u2019 is not specified all 15 elements of the rotated kurtosis\ntensor are computed.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>KT elements are assumed to be ordered as follows:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<dl class=\"simple\">\n<dt>begin{matrix} ( &amp; W_{xxxx} &amp; W_{yyyy} &amp; W_{zzzz} &amp; W_{xxxy} &amp; W_{xxxz}</dt><dd><p>&amp; \u2026 \\\n&amp; W_{xyyy} &amp; W_{yyyz} &amp; W_{xzzz} &amp; W_{yzzz} &amp; W_{xxyy}\n&amp; \u2026 \\\n&amp; W_{xxzz} &amp; W_{yyzz} &amp; W_{xxyz} &amp; W_{xyyz} &amp; W_{xyzz}\n&amp; &amp; )end{matrix}</p>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR\ncharacterization of neural tissues using directional diffusion kurtosis\nanalysis. Neuroimage 42(1): 122-34</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wrotate-element\">\n<h3>Wrotate_element<a class=\"headerlink\" href=\"#wrotate-element\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.Wrotate_element\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">Wrotate_element</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">kt</em>, <em class=\"sig-param\">indi</em>, <em class=\"sig-param\">indj</em>, <em class=\"sig-param\">indk</em>, <em class=\"sig-param\">indl</em>, <em class=\"sig-param\">B</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.Wrotate_element\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the the specified index element of a kurtosis tensor rotated\nto the coordinate system basis B.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>kt</strong><span class=\"classifier\">ndarray (x, y, z, 15) or (n, 15)</span></dt><dd><p>Array containing the 15 independent elements of the kurtosis tensor</p>\n</dd>\n<dt><strong>indi</strong><span class=\"classifier\">int</span></dt><dd><p>Rotated kurtosis tensor element index i (0 for x, 1 for y, 2 for z)</p>\n</dd>\n<dt><strong>indj</strong><span class=\"classifier\">int</span></dt><dd><p>Rotated kurtosis tensor element index j (0 for x, 1 for y, 2 for z)</p>\n</dd>\n<dt><strong>indk</strong><span class=\"classifier\">int</span></dt><dd><p>Rotated kurtosis tensor element index k (0 for x, 1 for y, 2 for z)</p>\n</dd>\n<dt><strong>indl: int</strong></dt><dd><p>Rotated kurtosis tensor element index l (0 for x, 1 for y, 2 for z)</p>\n</dd>\n<dt><strong>B: array (x, y, z, 3, 3) or (n, 15)</strong></dt><dd><p>Vectors of the basis column-wise oriented</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>Wre</strong><span class=\"classifier\">float</span></dt><dd><p>rotated kurtosis tensor element of index ind_i, ind_j, ind_k, ind_l</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>It is assumed that initial kurtosis tensor elementes are defined on the\nCartesian coordinate system.</p>\n<p class=\"rubric\">References</p>\n<p>[1] Hui ES, Cheung MM, Qi L, Wu EX, 2008. Towards better MR\ncharacterization of neural tissues using directional diffusion kurtosis\nanalysis. Neuroimage 42(1): 122-34</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"apparent-kurtosis-coef\">\n<h3>apparent_kurtosis_coef<a class=\"headerlink\" href=\"#apparent-kurtosis-coef\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.apparent_kurtosis_coef\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">apparent_kurtosis_coef</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">min_diffusivity=0</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.apparent_kurtosis_coef\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each direction\nof a sphere <a class=\"reference internal\" href=\"#r1b3e9922dec3-1\" id=\"id207\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvectors respectively</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">a Sphere class instance</span></dt><dd><p>The AKC will be calculated for each of the vertices in the sphere</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues\ncause quite a lot of noise in diffusion-based metrics, diffusivity\nvalues smaller than <cite>min_diffusivity</cite> are replaced with\n<cite>min_diffusivity</cite>. Default = 0</p>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physicaly\nand biologicaly pluasible, and these cause artefacts in\nkurtosis-based measures, directional kurtosis values smaller than\n<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7\n(theoretical kurtosis limit for regions that consist of water confined\nto spherical pores <a class=\"reference internal\" href=\"#r1b3e9922dec3-2\" id=\"id208\">[2]</a>)</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>akc</strong><span class=\"classifier\">ndarray (x, y, z, g) or (n, g)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) for all g directions of a sphere.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For each sphere direction with coordinates <span class=\"math notranslate nohighlight\">\\((n_{1}, n_{2}, n_{3})\\)</span>, the\ncalculation of AKC is done using formula <a class=\"reference internal\" href=\"#r1b3e9922dec3-1\" id=\"id209\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AKC(n)=\\frac{MD^{2}}{ADC(n)^{2}}\\sum_{i=1}^{3}\\sum_{j=1}^{3}\n\\sum_{k=1}^{3}\\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W_{ijkl}\\)</span> are the elements of the kurtosis tensor, MD the mean\ndiffusivity and ADC the apparent diffusion coefficent computed as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[ADC(n)=\\sum_{i=1}^{3}\\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(D_{ij}\\)</span> are the elements of the diffusion tensor.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1b3e9922dec3-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id5\">1</a>,<a href=\"#id207\">2</a>,<a href=\"#id209\">3</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n<dt class=\"label\" id=\"r1b3e9922dec3-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id208\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"axial-kurtosis\">\n<h3>axial_kurtosis<a class=\"headerlink\" href=\"#axial-kurtosis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.axial_kurtosis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">axial_kurtosis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.axial_kurtosis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes axial Kurtosis (AK) from the kurtosis tensor <a class=\"reference internal\" href=\"#rf80d380179f9-1\" id=\"id212\">[1]</a>, <a class=\"reference internal\" href=\"#rf80d380179f9-2\" id=\"id213\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with\n<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions\nthat consist of water confined to spherical pores <a class=\"reference internal\" href=\"#rf80d380179f9-3\" id=\"id214\">[3]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with\n<cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,\notherwise it will be computed from the apparent diffusion kurtosis\nvalues along the principal axis of the diffusion tensor (see notes).\nDefault is set to True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ak</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated AK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>AK is defined as the directional kurtosis parallel to the fiber\u2019s main\ndirection e1 <a class=\"reference internal\" href=\"#rf80d380179f9-1\" id=\"id215\">[1]</a>, <a class=\"reference internal\" href=\"#rf80d380179f9-2\" id=\"id216\">[2]</a>. You can compute AK using to approaches:</p>\n<ol class=\"arabic simple\">\n<li><p>AK is calculated from rotated diffusion kurtosis tensor <a class=\"reference internal\" href=\"#rf80d380179f9-2\" id=\"id217\">[2]</a>, i.e.:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = \\hat{W}_{1111}\n    \\frac{(\\lambda_{1}+\\lambda_{2}+\\lambda_{3})^2}{(9 \\lambda_{1}^2)}\\]</div>\n<ol class=\"arabic simple\" start=\"2\">\n<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = K(\\mathbf{\\mathbf{e}_1)\\]</div>\n<p>Although both approaches leads to an exact calculation of AK, the first\napproach will be referred to as the analytical method while the second\napproach will be referred to as the numerical method based on their analogy\nto the estimation strategies for MK and RK.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf80d380179f9-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id6\">1</a>,<a href=\"#id212\">2</a>,<a href=\"#id215\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"rf80d380179f9-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id7\">1</a>,<a href=\"#id213\">2</a>,<a href=\"#id216\">3</a>,<a href=\"#id217\">4</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"rf80d380179f9-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id214\">3</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"carlson-rd\">\n<h3>carlson_rd<a class=\"headerlink\" href=\"#carlson-rd\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.carlson_rd\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">carlson_rd</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em>, <em class=\"sig-param\">errtol=0.0001</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.carlson_rd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the Carlson\u2019s incomplete elliptic integral of the second kind\ndefined as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[R_D = \\frac{3}{2} \\int_{0}^{\\infty} (t+x)^{-\\frac{1}{2}}\n(t+y)^{-\\frac{1}{2}}(t+z)  ^{-\\frac{3}{2}}\\]</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">ndarray</span></dt><dd><p>First independent variable of the integral.</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>\n</dd>\n<dt><strong>errtol</strong><span class=\"classifier\">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in\nmagnitude than the defined value</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>RD</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Value of the incomplete second order elliptic integral</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>x, y, and z have to be nonnegative and at most x or y is zero.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"carlson-rf\">\n<h3>carlson_rf<a class=\"headerlink\" href=\"#carlson-rf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.carlson_rf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">carlson_rf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em>, <em class=\"sig-param\">errtol=0.0003</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.carlson_rf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the Carlson\u2019s incomplete elliptic integral of the first kind\ndefined as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[R_F = \\frac{1}{2} \\int_{0}^{\\infty} \\left [(t+x)(t+y)(t+z)  \\right ]\n^{-\\frac{1}{2}}dt\\]</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">ndarray</span></dt><dd><p>First independent variable of the integral.</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Second independent variable of the integral.</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Third independent variable of the integral.</p>\n</dd>\n<dt><strong>errtol</strong><span class=\"classifier\">float</span></dt><dd><p>Error tolerance. Integral is computed with relative error less in\nmagnitude than the defined value</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>RF</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Value of the incomplete first order elliptic integral</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>x, y, and z have to be nonnegative and at most one of them is zero.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1621ed3829b0-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Carlson, B.C., 1994. Numerical computation of real or complex\nelliptic integrals. arXiv:math/9409227 [math.CA]</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id222\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id222\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"check-multi-b\">\n<h3>check_multi_b<a class=\"headerlink\" href=\"#check-multi-b\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.check_multi_b\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">check_multi_b</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">n_bvals</em>, <em class=\"sig-param\">non_zero=True</em>, <em class=\"sig-param\">bmag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.check_multi_b\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Check if you have enough different b-values in your gradient table</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance.</span></dt><dd></dd>\n<dt><strong>n_bvals</strong><span class=\"classifier\">int</span></dt><dd><p>The number of different b-values you are checking for.</p>\n</dd>\n<dt><strong>non_zero</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to check only non-zero bvalues. In this case, we will require\nat least <cite>n_bvals</cite> <em>non-zero</em> b-values (where non-zero is defined\ndepending on the <cite>gtab</cite> object\u2019s <cite>b0_threshold</cite> attribute)</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude of the b-values used. The function will\nnormalize the b-values relative <span class=\"math notranslate nohighlight\">\\(10^{bmag}\\)</span>. Default: derive this\nvalue from the maximal b-value provided:\n<span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>bool</strong><span class=\"classifier\">Whether there are at least <cite>n_bvals</cite> different b-values in the</span></dt><dd></dd>\n<dt>gradient table used.</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"decompose-tensor\">\n<h3>decompose_tensor<a class=\"headerlink\" href=\"#decompose-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.decompose_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">decompose_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.decompose_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>\n<p>Computes tensor eigen decomposition to calculate eigenvalues and\neigenvectors (Basser et al., 1994a).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,\nmuch smaller than the diffusion weighting, cause quite a lot of noise\nin metrics such as fa, diffusivity values smaller than\n<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative\neigenvalues are replaced by zero. Sorted from largest to smallest.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[\u2026, :, j] is associated with\neigvals[\u2026, j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"design-matrix\">\n<h3>design_matrix<a class=\"headerlink\" href=\"#design-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Construct B design matrix for DKI.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Measurement directions.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>B</strong><span class=\"classifier\">array (N, 22)</span></dt><dd><p>Design matrix or B matrix for the DKI model\nB[j, :] = (Bxx, Bxy, Bzz, Bxz, Byz, Bzz,</p>\n<blockquote>\n<div><p>Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,\nBxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,\nBxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,\nBlogS0)</p>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"directional-diffusion\">\n<h3>directional_diffusion<a class=\"headerlink\" href=\"#directional-diffusion\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.directional_diffusion\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">directional_diffusion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dt</em>, <em class=\"sig-param\">V</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.directional_diffusion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent diffusion coefficient (adc) in each direction\nof a sphere for a single voxel <a class=\"reference internal\" href=\"#r62a8a421f533-1\" id=\"id223\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dt</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>\n</dd>\n<dt><strong>V</strong><span class=\"classifier\">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues\ncause quite a lot of noise in diffusion-based metrics, diffusivity\nvalues smaller than <cite>min_diffusivity</cite> are replaced with\n<cite>min_diffusivity</cite>. Default = 0</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adc</strong><span class=\"classifier\">ndarray (g,)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere\nfor a single voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r62a8a421f533-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id8\">1</a>,<a href=\"#id223\">2</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"directional-diffusion-variance\">\n<h3>directional_diffusion_variance<a class=\"headerlink\" href=\"#directional-diffusion-variance\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.directional_diffusion_variance\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">directional_diffusion_variance</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">kt</em>, <em class=\"sig-param\">V</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.directional_diffusion_variance\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent diffusion variance (adv) in each direction\nof a sphere for a single voxel <a class=\"reference internal\" href=\"#r87e53edeef9c-1\" id=\"id225\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dt</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>\n</dd>\n<dt><strong>kt</strong><span class=\"classifier\">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>\n</dd>\n<dt><strong>V</strong><span class=\"classifier\">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physicaly\nand biologicaly pluasible, and these cause artefacts in\nkurtosis-based measures, directional kurtosis values smaller than\n<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7\n(theoretical kurtosis limit for regions that consist of water confined\nto spherical pores <a href=\"#id985\"><span class=\"problematic\" id=\"id226\">[2]_</span></a>)</p>\n</dd>\n<dt><strong>adc</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere\nfor a single voxel.</p>\n</dd>\n<dt><strong>adv</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion variance coefficient (advc) in all g directions of\na sphere for a single voxel.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adv</strong><span class=\"classifier\">ndarray (g,)</span></dt><dd><p>Apparent diffusion variance (adv) in all g directions of a sphere for\na single voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r87e53edeef9c-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id9\">1</a>,<a href=\"#id225\">2</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"directional-kurtosis\">\n<h3>directional_kurtosis<a class=\"headerlink\" href=\"#directional-kurtosis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.directional_kurtosis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">directional_kurtosis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dt</em>, <em class=\"sig-param\">md</em>, <em class=\"sig-param\">kt</em>, <em class=\"sig-param\">V</em>, <em class=\"sig-param\">min_diffusivity=0</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">adc=None</em>, <em class=\"sig-param\">adv=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.directional_kurtosis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent kurtosis coefficient (akc) in each direction\nof a sphere for a single voxel <a class=\"reference internal\" href=\"#ra6181896282f-1\" id=\"id228\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dt</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>\n</dd>\n<dt><strong>md</strong><span class=\"classifier\">float</span></dt><dd><p>mean diffusivity of the voxel</p>\n</dd>\n<dt><strong>kt</strong><span class=\"classifier\">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>\n</dd>\n<dt><strong>V</strong><span class=\"classifier\">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues\ncause quite a lot of noise in diffusion-based metrics, diffusivity\nvalues smaller than <cite>min_diffusivity</cite> are replaced with\n<cite>min_diffusivity</cite>. Default = 0</p>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physicaly\nand biologicaly pluasible, and these cause artefacts in\nkurtosis-based measures, directional kurtosis values smaller than\n<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7\n(theoretical kurtosis limit for regions that consist of water confined\nto spherical pores <a class=\"reference internal\" href=\"#ra6181896282f-2\" id=\"id229\">[2]</a>)</p>\n</dd>\n<dt><strong>adc</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere\nfor a single voxel.</p>\n</dd>\n<dt><strong>adv</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion variance (advc) in all g directions of a sphere for\na single voxel.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>akc</strong><span class=\"classifier\">ndarray (g,)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) in all g directions of a sphere for\na single voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra6181896282f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id10\">1</a>,<a href=\"#id228\">2</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n<dt class=\"label\" id=\"ra6181896282f-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id229\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"dki-prediction\">\n<h3>dki_prediction<a class=\"headerlink\" href=\"#dki-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.dki_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">dki_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.dki_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal given diffusion kurtosis imaging parameters.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><blockquote>\n<div><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>gtab<span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt>S0<span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><blockquote>\n<div><p>Simulated signal based on the DKI model:</p>\n</div></blockquote>\n<div class=\"math notranslate nohighlight\">\n\\[S=S_{0}e^{-bD+\\]</div>\n</dd>\n<dt>rac{1}{6}b^{2}D^{2}K}</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"from-lower-triangular\">\n<h3>from_lower_triangular<a class=\"headerlink\" href=\"#from-lower-triangular\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.from_lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">from_lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.from_lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns a tensor given the six unique tensor elements</p>\n<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,\nDyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are\nignored.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">array_like, (\u2026, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">ndarray (\u2026, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"get-fnames\">\n<h3>get_fnames<a class=\"headerlink\" href=\"#get-fnames\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.get_fnames\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">get_fnames</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name='small_64D'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.get_fnames\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Provide full paths to example or test datasets.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>the filename/s of which dataset to return, one of:\n- \u2018small_64D\u2019 small region of interest nifti,bvecs,bvals 64 directions\n- \u2018small_101D\u2019 small region of interest nifti, bvecs, bvals</p>\n<blockquote>\n<div><p>101 directions</p>\n</div></blockquote>\n<ul class=\"simple\">\n<li><p>\u2018aniso_vox\u2019 volume with anisotropic voxel size as Nifti</p></li>\n<li><p>\u2018fornix\u2019 300 tracks in Trackvis format (from Pittsburgh\nBrain Competition)</p></li>\n<li><p>\u2018gqi_vectors\u2019 the scanner wave vectors needed for a GQI acquisitions\nof 101 directions tested on Siemens 3T Trio</p></li>\n<li><p>\u2018small_25\u2019 small ROI (10x8x2) DTI data (b value 2000, 25 directions)</p></li>\n<li><p>\u2018test_piesno\u2019 slice of N=8, K=14 diffusion data</p></li>\n<li><p>\u2018reg_c\u2019 small 2D image used for validating registration</p></li>\n<li><p>\u2018reg_o\u2019 small 2D image used for validation registration</p></li>\n<li><p>\u2018cb_2\u2019 two vectorized cingulum bundles</p></li>\n</ul>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fnames</strong><span class=\"classifier\">tuple</span></dt><dd><p>filenames for dataset</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.io.image</span> <span class=\"k\">import</span> <span class=\"n\">load_nifti</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_fnames</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fimg</span><span class=\"p\">,</span> <span class=\"n\">fbvals</span><span class=\"p\">,</span> <span class=\"n\">fbvecs</span> <span class=\"o\">=</span> <span class=\"n\">get_fnames</span><span class=\"p\">(</span><span class=\"s1\">&#39;small_101D&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">loadtxt</span><span class=\"p\">(</span><span class=\"n\">fbvals</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">loadtxt</span><span class=\"p\">(</span><span class=\"n\">fbvecs</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">T</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">affine</span> <span class=\"o\">=</span> <span class=\"n\">load_nifti</span><span class=\"p\">(</span><span class=\"n\">fimg</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">102</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">102</span><span class=\"p\">,)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">102</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id232\">\n<h3>get_sphere<a class=\"headerlink\" href=\"#id232\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.get_sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">get_sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name='symmetric362'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.get_sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>provide triangulated spheres</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>which sphere - one of:\n* \u2018symmetric362\u2019\n* \u2018symmetric642\u2019\n* \u2018symmetric724\u2019\n* \u2018repulsion724\u2019\n* \u2018repulsion100\u2019\n* \u2018repulsion200\u2019</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">a dipy.core.sphere.Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;symmetric362&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">faces</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">362</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">faces</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">720</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;not a sphere name&#39;</span><span class=\"p\">)</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">DataError</span>: <span class=\"n\">No sphere called &quot;not a sphere name&quot;</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"kurtosis-fractional-anisotropy\">\n<h3>kurtosis_fractional_anisotropy<a class=\"headerlink\" href=\"#kurtosis-fractional-anisotropy\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.kurtosis_fractional_anisotropy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">kurtosis_fractional_anisotropy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.kurtosis_fractional_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the anisotropy of the kurtosis tensor (KFA) <a class=\"reference internal\" href=\"#r1c91af01b9f3-1\" id=\"id233\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014-</strong></dt><dd></dd>\n<dt><strong>kfa</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The KFA is defined as <a class=\"reference internal\" href=\"#r1c91af01b9f3-1\" id=\"id234\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[KFA \\equiv\n\\frac{||\\mathbf{W} - MKT \\mathbf{I}^{(4)}||_F}{||\\mathbf{W}||_F}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W\\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class=\"math notranslate nohighlight\">\\(I^(4)\\)</span> is\nthe fully symmetric rank 2 isotropic tensor and <span class=\"math notranslate nohighlight\">\\(||...||_F\\)</span> is the tensor\u2019s\nFrobenius norm <a class=\"reference internal\" href=\"#r1c91af01b9f3-1\" id=\"id235\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1c91af01b9f3-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id11\">1</a>,<a href=\"#id233\">2</a>,<a href=\"#id234\">3</a>,<a href=\"#id235\">4</a>)</span></dt>\n<dd><p>Glenn, G. R., Helpern, J. A., Tabesh, A., and Jensen, J. H. (2015).\nQuantitative assessment of diffusional kurtosis anisotropy.\nNMR in Biomedicine 28, 448\u2013459. doi:10.1002/nbm.3271</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"kurtosis-maximum\">\n<h3>kurtosis_maximum<a class=\"headerlink\" href=\"#kurtosis-maximum\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.kurtosis_maximum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">kurtosis_maximum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=0.01</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.kurtosis_maximum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes kurtosis maximum value</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eingenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the\nmaximal value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the\ndirections sampled on the sphere class instance. The gradient of the\nconvergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken from\nthe initial sampled directions of the given sphere object</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be\nanalyzed that has the shape dki_params.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>max_value</strong><span class=\"classifier\">float</span></dt><dd><p>kurtosis tensor maximum value</p>\n</dd>\n<dt><strong>max_dir</strong><span class=\"classifier\">array (3,)</span></dt><dd><p>Cartesian coordinates of the direction of the maximal kurtosis value</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id237\">\n<h3>local_maxima<a class=\"headerlink\" href=\"#id237\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.local_maxima\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">local_maxima</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.local_maxima\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>\n<p>If a function is evaluated on some set of points where each pair of\nneighboring points is an edge in edges, find the local maxima.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">array, 1d, dtype=double</span></dt><dd><p>The function evaluated on a set of discrete points.</p>\n</dd>\n<dt><strong>edges</strong><span class=\"classifier\">array (N, 2)</span></dt><dd><p>The set of neighbor relations between the points. Every edge, ie\n<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>peak_values</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Value of odf at a maximum point. Peak values is sorted in descending\norder.</p>\n</dd>\n<dt><strong>peak_indices</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so\n<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"../dipy.core/#module-dipy.core.sphere\" title=\"dipy.core.sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dipy.core.sphere</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>A point is a local maximum if it is &gt; at least one neighbor and &gt;= all\nneighbors. If no points meet the above criteria, 1 maximum is returned such\nthat <cite>odf[maximum] == max(odf)</cite>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lower-triangular\">\n<h3>lower_triangular<a class=\"headerlink\" href=\"#lower-triangular\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the six lower triangular values of the tensor and a dummy variable\nif b0 is not None</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array_like (\u2026, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>\n</dd>\n<dt><strong>b0</strong><span class=\"classifier\">float</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (\u2026, 6) otherwise (\u2026, 7)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mean-diffusivity\">\n<h3>mean_diffusivity<a class=\"headerlink\" href=\"#mean-diffusivity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.mean_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">mean_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.mean_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1 + \\lambda_2 + \\lambda_3}{3}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mean-kurtosis\">\n<h3>mean_kurtosis<a class=\"headerlink\" href=\"#mean-kurtosis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.mean_kurtosis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">mean_kurtosis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=3</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.mean_kurtosis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with\n<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions\nthat consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r953e26c55b6a-4\" id=\"id238\">[4]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with\n<cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, MK is calculated using its analytical solution, otherwise an\nexact numerical estimator is used (see Notes). Default is set to True</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MK is defined as the average of directional kurtosis coefficients\nacross all spatial directions, which can be formulated by the following\nsurface integral[R953e26c55b6a-1]_:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MK \\equiv \\frac{1}{4\\pi} \\int d\\Omega_\\mathbf{n} K(\\mathbf{n})\\]</div>\n<p>This integral can be numerically solved by averaging directional\nkurtosis values sampled for directions of a spherical t-design <a class=\"reference internal\" href=\"#r953e26c55b6a-2\" id=\"id239\">[2]</a>.</p>\n<p>Alternatively, MK can be solved from the analytical solution derived by\nTabesh et al. <a class=\"reference internal\" href=\"#r953e26c55b6a-3\" id=\"id240\">[3]</a>. This solution is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\begin{split}MK=F_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{1111}+\n   F_1(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{2222}+\n   F_1(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{3333}+ \\\\\n   F_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}+\n   F_2(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{1133}+\n   F_2(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{1122}\\end{split}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{W}_{ijkl}\\)</span> are the components of the <span class=\"math notranslate nohighlight\">\\(W\\)</span> tensor in the\ncoordinates system defined by the eigenvectors of the diffusion tensor\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{D}\\)</span> and</p>\n<div class=\"math notranslate nohighlight\">\n\\[ \\begin{align}\\begin{aligned}\\begin{split}F_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{18(\\lambda_1-\\lambda_2)(\\lambda_1-\\lambda_3)}\n[\\frac{\\sqrt{\\lambda_2\\lambda_3}}{\\lambda_1}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{3\\lambda_1^2-\\lambda_1\\lambda_2-\\lambda_2\\lambda_3-\n\\lambda_1\\lambda_3}\n{3\\lambda_1 \\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-1 ]\\end{split}\\\\\\begin{split}F_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{3(\\lambda_2-\\lambda_3)^2}\n[\\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{2\\lambda_1-\\lambda_2-\\lambda_3}{3\\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-2]\\end{split}\\end{aligned}\\end{align} \\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(R_f\\)</span> and <span class=\"math notranslate nohighlight\">\\(R_d\\)</span> are the Carlson\u2019s elliptic integrals.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r953e26c55b6a-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r953e26c55b6a-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id239\">2</a></span></dt>\n<dd><p>Hardin, R.H., Sloane, N.J.A., 1996. McLaren\u2019s Improved Snub Cube and\nOther New Spherical Designs in Three Dimensions. Discrete and\nComputational Geometry 15, 429-441.</p>\n</dd>\n<dt class=\"label\" id=\"r953e26c55b6a-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id240\">3</a></span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r953e26c55b6a-4\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id238\">4</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mean-kurtosis-tensor\">\n<h3>mean_kurtosis_tensor<a class=\"headerlink\" href=\"#mean-kurtosis-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.mean_kurtosis_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">mean_kurtosis_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.mean_kurtosis_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#r36a19797d370-1\" id=\"id245\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with\n<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions\nthat consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r36a19797d370-2\" id=\"id246\">[2]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with\n<cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014-</strong></dt><dd></dd>\n<dt><strong>mkt</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MKT is defined as <a class=\"reference internal\" href=\"#r36a19797d370-1\" id=\"id247\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MKT \\equiv \\frac{1}{4\\pi} \\int d\n\\Omega_{\\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\\]</div>\n<p>which can be directly computed from the trace of the kurtosis tensor:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}\n(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r36a19797d370-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id12\">1</a>,<a href=\"#id245\">2</a>,<a href=\"#id247\">3</a>)</span></dt>\n<dd><p>Hansen, B., Lund, T. E., Sangill, R., and Jespersen, S. N. (2013).\nExperimentally and computationally fast method for estimation of\na mean kurtosis.Magnetic Resonance in Medicine69,  1754\u20131760.388\ndoi:10.1002/mrm.24743</p>\n</dd>\n<dt class=\"label\" id=\"r36a19797d370-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id246\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id250\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id250\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nlls-fit-tensor\">\n<h3>nlls_fit_tensor<a class=\"headerlink\" href=\"#nlls-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.nlls_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">nlls_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">weighting=None</em>, <em class=\"sig-param\">sigma=None</em>, <em class=\"sig-param\">jac=True</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.nlls_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear\nleast-squares.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, Npar)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients. First six parameters of design matrix should correspond\nto the six unique diffusion tensor elements in the lower triangular\norder (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz), while last parameter to -log(S0)</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>weighting: str</strong></dt><dd><p>the weighting scheme to use in considering the\nsquared-error. Default behavior is to use uniform weighting. Other\noptions: \u2018sigma\u2019 \u2018gmm\u2019</p>\n</dd>\n<dt><strong>sigma: float</strong></dt><dd><p>If the \u2018sigma\u2019 weighting scheme is used, a value of sigma needs to be\nprovided here. According to <a class=\"reference internal\" href=\"../../examples_built/restore_dti/#chang2005\" id=\"id251\"><span>[Chang2005]</span></a>, a good value to use is\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool</span></dt><dd><p>Use the Jacobian? Default: True</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>nlls_params: the eigen-values and eigen-vectors of the tensor in each</dt><dd><p>voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ols-fit-dki\">\n<h3>ols_fit_dki<a class=\"headerlink\" href=\"#ols-fit-dki\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.ols_fit_dki\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">ols_fit_dki</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.ols_fit_dki\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the diffusion and kurtosis tensors using an ordinary linear\nleast squares (OLS) approach <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id252\">1</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array (N, g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">array (N, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki.wls_fit_dki\" title=\"dipy.reconst.dki.wls_fit_dki\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">wls_fit_dki</span></code></a>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nls_fit_dki</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"simple\">\n<dt>[1] Lu, H., Jensen, J. H., Ramani, A., and Helpern, J. A. (2006).</dt><dd><p>Three-dimensional characterization of non-gaussian water diffusion in\nhumans using diffusion kurtosis imaging. NMR in Biomedicine 19,\n236\u2013247. doi:10.1002/nbm.1020</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"perpendicular-directions\">\n<h3>perpendicular_directions<a class=\"headerlink\" href=\"#perpendicular-directions\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.perpendicular_directions\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">perpendicular_directions</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">v</em>, <em class=\"sig-param\">num=30</em>, <em class=\"sig-param\">half=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.perpendicular_directions\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes n evenly spaced perpendicular directions relative to a given\nvector v</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">array (3,)</span></dt><dd><p>Array containing the three cartesian coordinates of vector v</p>\n</dd>\n<dt><strong>num</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Number of perpendicular directions to generate</p>\n</dd>\n<dt><strong>half</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If half is True, perpendicular directions are sampled on half of the\nunit circumference perpendicular to v, otherwive perpendicular\ndirections are sampled on the full circumference. Default of half is\nFalse</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>psamples</strong><span class=\"classifier\">array (n, 3)</span></dt><dd><p>array of vectors perpendicular to v</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Perpendicular directions are estimated using the following two step\nprocedure:</p>\n<blockquote>\n<div><p>1) the perpendicular directions are first sampled in a unit\ncircumference parallel to the plane normal to the x-axis.</p>\n<p>2) Samples are then rotated and aligned to the plane normal to vector\nv. The rotational matrix for this rotation is constructed as reference\nframe basis which axis are the following:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>The first axis is vector v</p></li>\n<li><p>The second axis is defined as the normalized vector given by the</p></li>\n</ul>\n<p>cross product between vector v and the unit vector aligned to the\nx-axis\n- The third axis is defined as the cross product between the\nprevious computed vector and vector v.</p>\n</div></blockquote>\n</div></blockquote>\n<p>Following this two steps, coordinates of the final perpendicular directions\nare given as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\left [ -\\sin(a_{i}) \\sqrt{{v_{y}}^{2}+{v_{z}}^{2}}\n\\; , \\;\n\\frac{v_{x}v_{y}\\sin(a_{i})-v_{z}\\cos(a_{i})}\n{\\sqrt{{v_{y}}^{2}+{v_{z}}^{2}}}\n\\; , \\;\n\\frac{v_{x}v_{z}\\sin(a_{i})-v_{y}\\cos(a_{i})}\n{\\sqrt{{v_{y}}^{2}+{v_{z}}^{2}}} \\right  ]\\]</div>\n<p>This procedure has a singularity when vector v is aligned to the x-axis. To\nsolve this singularity, perpendicular directions in procedure\u2019s step 1 are\ndefined in the plane normal to y-axis and the second axis of the rotated\nframe of reference is computed as the normalized vector given by the cross\nproduct between vector v and the unit vector aligned to the y-axis.\nFollowing this, the coordinates of the perpendicular directions are given\nas:</p>\n<blockquote>\n<div><p>left [ -frac{left (v_{x}v_{y}sin(a_{i})+v_{z}cos(a_{i}) right )}\n{sqrt{{v_{x}}^{2}+{v_{z}}^{2}}}\n; , ;\nsin(a_{i}) sqrt{{v_{x}}^{2}+{v_{z}}^{2}}\n; , ;\nfrac{v_{y}v_{z}sin(a_{i})+v_{x}cos(a_{i})}\n{sqrt{{v_{x}}^{2}+{v_{z}}^{2}}} right  ]</p>\n</div></blockquote>\n<p>For more details on this calculation, see ` here &lt;<a class=\"reference external\" href=\"http://gsoc2015dipydki.blogspot.it/2015/07/rnh-post-8-computing-perpendicular.html\">http://gsoc2015dipydki.blogspot.it/2015/07/rnh-post-8-computing-perpendicular.html</a>&gt;`_.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"radial-kurtosis\">\n<h3>radial_kurtosis<a class=\"headerlink\" href=\"#radial-kurtosis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.radial_kurtosis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">radial_kurtosis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.radial_kurtosis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r7cf9df14e56e-1\" id=\"id253\">[1]</a>, <a class=\"reference internal\" href=\"#r7cf9df14e56e-2\" id=\"id254\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced with\n<cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit for regions\nthat consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r7cf9df14e56e-3\" id=\"id255\">[3]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, radial\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced with\n<cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise an\nexact numerical estimator is used (see Notes). Default is set to True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated RK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RK is defined as the average of the directional kurtosis perpendicular\nto the fiber\u2019s main direction e1 <a class=\"reference internal\" href=\"#r7cf9df14e56e-1\" id=\"id256\">[1]</a>, <a class=\"reference internal\" href=\"#r7cf9df14e56e-2\" id=\"id257\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<dl class=\"simple\">\n<dt>RK equiv frac{1}{2pi} int dOmega _mathbf{theta} K(mathbf{theta})</dt><dd><p>delta (mathbf{theta}cdot mathbf{e}_1)</p>\n</dd>\n</dl>\n<p>This equation can be numerically computed by averaging apparent\ndirectional kurtosis samples for directions perpendicular to e1.</p>\n<p>Otherwise, RK can be calculated from its analytical solution <a class=\"reference internal\" href=\"#r7cf9df14e56e-2\" id=\"id258\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[K_{\\bot} = G_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2222} +\n           G_1(\\lambda_1,\\lambda_3,\\lambda_2)\\hat{W}_{3333} +\n           G_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}\\]</div>\n<p>where:</p>\n<div class=\"math notranslate nohighlight\">\n\\[G_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{18\\lambda_2(\\lambda_2-\n\\lambda_3)} \\left (2\\lambda_2 +\n\\frac{\\lambda_3^2-3\\lambda_2\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\n\\right)\\]</div>\n<p>and</p>\n<div class=\"math notranslate nohighlight\">\n\\[G_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{(\\lambda_2-\\lambda_3)^2}\n\\left ( \\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}-2\\right )\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r7cf9df14e56e-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id14\">1</a>,<a href=\"#id253\">2</a>,<a href=\"#id256\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r7cf9df14e56e-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id15\">1</a>,<a href=\"#id254\">2</a>,<a href=\"#id257\">3</a>,<a href=\"#id258\">4</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r7cf9df14e56e-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id255\">3</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on Biomedical\nImaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"restore-fit-tensor\">\n<h3>restore_fit_tensor<a class=\"headerlink\" href=\"#restore-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.restore_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">restore_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">sigma=None</em>, <em class=\"sig-param\">jac=True</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.restore_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Use the RESTORE algorithm <a class=\"reference internal\" href=\"#r60e7076f793f-1\" id=\"id262\">[1]</a> to calculate a robust tensor fit</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array of shape (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float</span></dt><dd><p>An estimate of the variance. <a class=\"reference internal\" href=\"#r60e7076f793f-1\" id=\"id263\">[1]</a> recommend to use\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to use the Jacobian of the tensor to speed the non-linear\noptimization procedure used to fit the tensor parameters (see also\n<a class=\"reference internal\" href=\"#dipy.reconst.dki.nlls_fit_tensor\" title=\"dipy.reconst.dki.nlls_fit_tensor\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">nlls_fit_tensor()</span></code></a>). Default: True</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>restore_params</strong><span class=\"classifier\">an estimate of the tensor parameters in each voxel.</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r60e7076f793f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id16\">1</a>,<a href=\"#id262\">2</a>,<a href=\"#id263\">3</a>)</span></dt>\n<dd><p>Chang, L-C, Jones, DK and Pierpaoli, C (2005). RESTORE: robust</p>\n</dd>\n</dl>\n<p>estimation of tensors by outlier rejection. MRM, 53: 1088-95.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sphere2cart\">\n<h3>sphere2cart<a class=\"headerlink\" href=\"#sphere2cart\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.sphere2cart\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">sphere2cart</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.sphere2cart\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical to Cartesian coordinates</p>\n<p>This is the standard physics convention where <cite>theta</cite> is the\ninclination (polar) angle, and <cite>phi</cite> is the azimuth angle.</p>\n<p>Imagine a sphere with center (0,0,0).  Orient it with the z axis\nrunning south-north, the y axis running west-east and the x axis\nfrom posterior to anterior.  <cite>theta</cite> (the inclination angle) is the\nangle to rotate from the z-axis (the zenith) around the y-axis,\ntowards the x axis.  Thus the rotation is counter-clockwise from the\npoint of view of positive y.  <cite>phi</cite> (azimuth) gives the angle of\nrotation around the z-axis towards the y axis.  The rotation is\ncounter-clockwise from the point of view of positive z.</p>\n<p>Equivalently, given a point P on the sphere, with coordinates x, y,\nz, <cite>theta</cite> is the angle between P and the z-axis, and <cite>phi</cite> is\nthe angle between the projection of P onto the XY plane, and the X\naxis.</p>\n<p>Geographical nomenclature designates theta as \u2018co-latitude\u2019, and phi\nas \u2018longitude\u2019</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array_like</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array_like</span></dt><dd><p>inclination or polar angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array_like</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array</span></dt><dd><p>x coordinate(s) in Cartesion space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array</span></dt><dd><p>y coordinate(s) in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>See these pages:</p>\n<ul class=\"simple\">\n<li><p><a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Spherical_coordinate_system\">http://en.wikipedia.org/wiki/Spherical_coordinate_system</a></p></li>\n<li><p><a class=\"reference external\" href=\"http://mathworld.wolfram.com/SphericalCoordinates.html\">http://mathworld.wolfram.com/SphericalCoordinates.html</a></p></li>\n</ul>\n<p>for excellent discussion of the many different conventions\npossible.  Here we use the physics conventions, used in the\nwikipedia page.</p>\n<p>Derivations of the formulae are simple. Consider a vector x, y, z of\nlength r (norm of x, y, z).  The inclination angle (theta) can be\nfound from: cos(theta) == z / r -&gt; z == r * cos(theta).  This gives\nthe hypotenuse of the projection onto the XY plane, which we will\ncall Q. Q == r*sin(theta). Now x / Q == cos(phi) -&gt; x == r *\nsin(theta) * cos(phi) and so on.</p>\n<p>We have deliberately named this function <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> rather than\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sph2cart</span></code> to distinguish it from the Matlab function of that\nname, because the Matlab function uses an unusual convention for the\nangles that we did not want to replicate.  The Matlab function is\ntrivial to implement with the formulae given in the Matlab help.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"split-dki-param\">\n<h3>split_dki_param<a class=\"headerlink\" href=\"#split-dki-param\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.split_dki_param\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">split_dki_param</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.split_dki_param\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor\neigenvector matrix, and the 15 independent elements of the kurtosis tensor\nfrom the model parameters estimated from the DKI model</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (x, y, z, 3) or (n, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[:,j] is associated with\neigvals[j])</p>\n</dd>\n<dt><strong>kt</strong><span class=\"classifier\">array (x, y, z, 15) or (n, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id265\">\n<h3>vec_val_vect<a class=\"headerlink\" href=\"#id265\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">shape (\u2026, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>\n</dd>\n<dt><strong>vals</strong><span class=\"classifier\">shape (\u2026, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> shape above must\nmatch that for <cite>vecs</cite></p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">shape (\u2026, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code>, loops to get (M, N) <code class=\"docutils literal notranslate\"><span class=\"pre\">vec</span></code>\nmatrix, and (N,) <code class=\"docutils literal notranslate\"><span class=\"pre\">vals</span></code> vector, and calculates\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Make a 3D array where the first dimension is only 1</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec_val_vect</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">vals</span><span class=\"p\">)</span>\n<span class=\"go\">array([[[   9.,   24.,   39.],</span>\n<span class=\"go\">        [  24.,   66.,  108.],</span>\n<span class=\"go\">        [  39.,  108.,  177.]]])</span>\n</pre></div>\n</div>\n<p>That\u2019s the same as the 2D case (apart from the float casting):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">),</span> <span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n<span class=\"go\">array([[  9,  24,  39],</span>\n<span class=\"go\">       [ 24,  66, 108],</span>\n<span class=\"go\">       [ 39, 108, 177]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wls-fit-dki\">\n<h3>wls_fit_dki<a class=\"headerlink\" href=\"#wls-fit-dki\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki.wls_fit_dki\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki.</code><code class=\"sig-name descname\">wls_fit_dki</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki.wls_fit_dki\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the diffusion and kurtosis tensors using a weighted linear\nleast squares (WLS) approach <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id266\">1</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 22)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array (N, g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">array (N, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model for all N\nvoxels.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"simple\">\n<dt>[1] Veraart, J., Sijbers, J., Sunaert, S., Leemans, A., Jeurissen, B.,</dt><dd><p>2013. Weighted linear least squares estimation of diffusion MRI\nparameters: Strengths, limitations, and pitfalls. Magn Reson Med 81,\n335-346.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id267\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a><a class=\"headerlink\" href=\"#id267\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">DiffusionKurtosisFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit\" title=\"dipy.reconst.dti.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dti.TensorFit</span></code></a></p>\n<p>Class for fitting the Diffusion Kurtosis Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kfa\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kfa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kfa</span></code></a></dt><dd><p>Returns the kurtosis tensor (KFA) <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id268\">1</a>.</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kt\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kt</span></code></a></dt><dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.ak\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.ak\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ak</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#rb73f8e7cd86f-1\" id=\"id269\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.akc\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.akc\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">akc</span></code></a>(sphere)</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kmax</span></code></a>([sphere,\u00a0gtol,\u00a0mask])</p></td>\n<td><p>Computes the maximum value of a single voxel kurtosis tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.mk\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.mk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mk</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.mkt\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.mkt\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mkt</span></code></a>([min_kurtosis,\u00a0max_kurtosis])</p></td>\n<td><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#r413c1076c843-1\" id=\"id270\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.predict\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a DKI model fit, predict the signal on the vertices of a gradient table</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.rk\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.rk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rk</span></code></a>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r28a508c47eba-1\" id=\"id271\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a DiffusionKurtosisFit class instance.</p>\n<p>Since DKI is an extension of DTI, class instance is defined as subclass\nof the TensorFit from dti.py</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>model</strong><span class=\"classifier\">DiffusionKurtosisModel Class instance</span></dt><dd><p>Class instance containing the Diffusion Kurtosis Model for the fit</p>\n</dd>\n<dt><strong>model_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.ak\">\n<code class=\"sig-name descname\">ak</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.ak\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#rb73f8e7cd86f-1\" id=\"id272\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#rb73f8e7cd86f-2\" id=\"id273\">[2]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, axial\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, AK is calculated from rotated diffusion kurtosis tensor,\notherwise it will be computed from the apparent diffusion kurtosis\nvalues along the principal axis of the diffusion tensor\n(see notes). Default is set to True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ak</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated AK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>AK is defined as the directional kurtosis parallel to the fiber\u2019s main\ndirection e1 <a class=\"reference internal\" href=\"#rb73f8e7cd86f-1\" id=\"id274\">[1]</a>, <a class=\"reference internal\" href=\"#rb73f8e7cd86f-2\" id=\"id275\">[2]</a>. You can compute AK using to approaches:</p>\n<ol class=\"arabic simple\">\n<li><p>AK is calculated from rotated diffusion kurtosis tensor <a class=\"reference internal\" href=\"#rb73f8e7cd86f-2\" id=\"id276\">[2]</a>, i.e.:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = \\hat{W}_{1111}\n\\frac{(\\lambda_{1}+\\lambda_{2}+\\lambda_{3})^2}{(9 \\lambda_{1}^2)}\\]</div>\n<ol class=\"arabic simple\" start=\"2\">\n<li><p>AK can be sampled from the principal axis of the diffusion tensor:</p></li>\n</ol>\n<div class=\"math notranslate nohighlight\">\n\\[AK = K(\\mathbf{\\mathbf{e}_1)\\]</div>\n<p>Although both approaches leads to an exact calculation of AK, the\nfirst approach will be referred to as the analytical method while the\nsecond approach will be referred to as the numerical method based on\ntheir analogy to the estimation strategies for MK and RK.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb73f8e7cd86f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id269\">1</a>,<a href=\"#id272\">2</a>,<a href=\"#id274\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"rb73f8e7cd86f-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id273\">1</a>,<a href=\"#id275\">2</a>,<a href=\"#id276\">3</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"rb73f8e7cd86f-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.akc\">\n<code class=\"sig-name descname\">akc</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.akc\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent kurtosis coefficient (AKC) in each\ndirection on the sphere for each voxel in the data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>akc</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The estimates of the apparent kurtosis coefficient in every\ndirection on the input sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For each sphere direction with coordinates <span class=\"math notranslate nohighlight\">\\((n_{1}, n_{2}, n_{3})\\)</span>, the\ncalculation of AKC is done using formula:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AKC(n)=\\frac{MD^{2}}{ADC(n)^{2}}\\sum_{i=1}^{3}\\sum_{j=1}^{3}\n\\sum_{k=1}^{3}\\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W_{ijkl}\\)</span> are the elements of the kurtosis tensor, MD the mean\ndiffusivity and ADC the apparent diffusion coefficent computed as:</p>\n<div class=\"math notranslate nohighlight\">\n\\[ADC(n)=\\sum_{i=1}^{3}\\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(D_{ij}\\)</span> are the elements of the diffusion tensor.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kfa\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">kfa</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the kurtosis tensor (KFA) <a class=\"reference internal\" href=\"#r30a58a5a1e78-1\" id=\"id280\">[1]</a>.</p>\n<p class=\"rubric\">Notes</p>\n<p>The KFA is defined as <a class=\"reference internal\" href=\"#r30a58a5a1e78-1\" id=\"id281\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[KFA \\equiv\n\\frac{||\\mathbf{W} - MKT \\mathbf{I}^{(4)}||_F}{||\\mathbf{W}||_F}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(W\\)</span> is the kurtosis tensor, MKT the kurtosis tensor mean, <span class=\"math notranslate nohighlight\">\\(I^(4)\\)</span>\nis the fully symmetric rank 2 isotropic tensor and <span class=\"math notranslate nohighlight\">\\(||...||_F\\)</span> is the\ntensor\u2019s Frobenius norm <a class=\"reference internal\" href=\"#r30a58a5a1e78-1\" id=\"id282\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r30a58a5a1e78-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id280\">1</a>,<a href=\"#id281\">2</a>,<a href=\"#id282\">3</a>)</span></dt>\n<dd><p>Glenn, G. R., Helpern, J. A., Tabesh, A., and Jensen, J. H.\n(2015). Quantitative assessment of diffusional kurtosis\nanisotropy. NMR in Biomedicine 28, 448\u2013459. doi:10.1002/nbm.3271</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax\">\n<code class=\"sig-name descname\">kmax</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=1e-05</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kmax\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the maximum value of a single voxel kurtosis tensor</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of\nthe maximum value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the\ndirections sampled on the sphere class instance. The gradient of\nthe convergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken\nfrom the initial sampled directions of the given sphere object</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>max_value</strong><span class=\"classifier\">float</span></dt><dd><p>kurtosis tensor maximum value</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.kt\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">kt</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.kt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.mk\">\n<code class=\"sig-name descname\">mk</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.mk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#rb657f27beb9e-4\" id=\"id284\">[4]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, MK is calculated using its analytical solution, otherwise\nan exact numerical estimator is used (see Notes). Default is set to\nTrue.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MK is defined as the average of directional kurtosis coefficients\nacross all spatial directions, which can be formulated by the following\nsurface integral[Rb657f27beb9e-1]_:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MK \\equiv \\frac{1}{4\\pi} \\int d\\Omega_\\mathbf{n} K(\\mathbf{n})\\]</div>\n<p>This integral can be numerically solved by averaging directional\nkurtosis values sampled for directions of a spherical t-design <a class=\"reference internal\" href=\"#rb657f27beb9e-2\" id=\"id285\">[2]</a>.</p>\n<p>Alternatively, MK can be solved from the analytical solution derived by\nTabesh et al. <a class=\"reference internal\" href=\"#rb657f27beb9e-3\" id=\"id286\">[3]</a>. This solution is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\begin{split}MK=F_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{1111}+\n   F_1(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{2222}+\n   F_1(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{3333}+ \\\\\n   F_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}+\n   F_2(\\lambda_2,\\lambda_1,\\lambda_3)\\hat{W}_{1133}+\n   F_2(\\lambda_3,\\lambda_2,\\lambda_1)\\hat{W}_{1122}\\end{split}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{W}_{ijkl}\\)</span> are the components of the <span class=\"math notranslate nohighlight\">\\(W\\)</span> tensor in the\ncoordinates system defined by the eigenvectors of the diffusion tensor\n<span class=\"math notranslate nohighlight\">\\(\\mathbf{D}\\)</span> and</p>\n<div class=\"math notranslate nohighlight\">\n\\[ \\begin{align}\\begin{aligned}\\begin{split}F_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{18(\\lambda_1-\\lambda_2)(\\lambda_1-\\lambda_3)}\n[\\frac{\\sqrt{\\lambda_2\\lambda_3}}{\\lambda_1}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{3\\lambda_1^2-\\lambda_1\\lambda_2-\\lambda_2\\lambda_3-\n\\lambda_1\\lambda_3}\n{3\\lambda_1 \\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-1 ]\\end{split}\\\\\\begin{split}F_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}\n{3(\\lambda_2-\\lambda_3)^2}\n[\\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\nR_F(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)+\\\\\n\\frac{2\\lambda_1-\\lambda_2-\\lambda_3}{3\\sqrt{\\lambda_2 \\lambda_3}}\nR_D(\\frac{\\lambda_1}{\\lambda_2},\\frac{\\lambda_1}{\\lambda_3},1)-2]\\end{split}\\end{aligned}\\end{align} \\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(R_f\\)</span> and <span class=\"math notranslate nohighlight\">\\(R_d\\)</span> are the Carlson\u2019s elliptic integrals.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb657f27beb9e-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"rb657f27beb9e-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id285\">2</a></span></dt>\n<dd><p>Hardin, R.H., Sloane, N.J.A., 1996. McLaren\u2019s Improved Snub Cube\nand Other New Spherical Designs in Three Dimensions. Discrete\nand Computational Geometry 15, 429-441.</p>\n</dd>\n<dt class=\"label\" id=\"rb657f27beb9e-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id286\">3</a></span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"rb657f27beb9e-4\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id284\">4</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.mkt\">\n<code class=\"sig-name descname\">mkt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.mkt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean of the kurtosis tensor (MKT) <a class=\"reference internal\" href=\"#r413c1076c843-1\" id=\"id291\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are smaller than <cite>min_kurtosis</cite> are replaced\nwith <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis limit\nfor regions that consist of water confined to spherical pores <a class=\"reference internal\" href=\"#r413c1076c843-2\" id=\"id292\">[2]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range, mean\nkurtosis values that are larger than <cite>max_kurtosis</cite> are replaced\nwith <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mkt</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated mean kurtosis tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The MKT is defined as <a class=\"reference internal\" href=\"#r413c1076c843-1\" id=\"id293\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MKT \\equiv \\frac{1}{4\\pi} \\int d\n\\Omega_{\\mathnbf{n}} n_i n_j n_k n_l W_{ijkl}\\]</div>\n<p>which can be directly computed from the trace of the kurtosis tensor:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<p>MKT = frac{1}{5} Tr(mathbf{W}) = frac{1}{5}\n(W_{1111} + W_{2222} + W_{3333} + 2W_{1122} + 2W_{1133} + 2W_{2233})</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r413c1076c843-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id270\">1</a>,<a href=\"#id291\">2</a>,<a href=\"#id293\">3</a>)</span></dt>\n<dd><p>Hansen, B., Lund, T. E., Sangill, R., and Jespersen, S. N. 2013.\nExperimentally and computationally fast method for estimation\nof a mean kurtosis. Magnetic Resonance in Medicine69, 1754\u20131760.\n388. doi:10.1002/mrm.24743</p>\n</dd>\n<dt class=\"label\" id=\"r413c1076c843-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id292\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a DKI model fit, predict the signal on the vertices of a\ngradient table</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[S(n,b)=S_{0}e^{-bD(n)+\\frac{1}{6}b^{2}D(n)^{2}K(n)}\\]</div>\n<p><span class=\"math notranslate nohighlight\">\\(\\mathbf{D(n)}\\)</span> and <span class=\"math notranslate nohighlight\">\\(\\mathbf{K(n)}\\)</span> can be computed from the DT and KT\nusing the following equations:</p>\n<div class=\"math notranslate nohighlight\">\n\\[D(n)=\\sum_{i=1}^{3}\\sum_{j=1}^{3}n_{i}n_{j}D_{ij}\\]</div>\n<p>and</p>\n<div class=\"math notranslate nohighlight\">\n\\[K(n)=\\frac{MD^{2}}{D(n)^{2}}\\sum_{i=1}^{3}\\sum_{j=1}^{3}\n\\sum_{k=1}^{3}\\sum_{l=1}^{3}n_{i}n_{j}n_{k}n_{l}W_{ijkl}\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(D_{ij}\\)</span> and <span class=\"math notranslate nohighlight\">\\(W_{ijkl}\\)</span> are the elements of the second-order DT\nand the fourth-order KT tensors, respectively, and <span class=\"math notranslate nohighlight\">\\(MD\\)</span> is the mean\ndiffusivity.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisFit.rk\">\n<code class=\"sig-name descname\">rk</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">max_kurtosis=10</em>, <em class=\"sig-param\">analytical=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisFit.rk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <a class=\"reference internal\" href=\"#r28a508c47eba-1\" id=\"id296\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,\nradial kurtosis values that are smaller than <cite>min_kurtosis</cite> are\nreplaced with <cite>min_kurtosis</cite>. Default = -3./7 (theoretical kurtosis\nlimit for regions that consist of water confined to spherical pores\n<a class=\"reference internal\" href=\"#r28a508c47eba-3\" id=\"id297\">[3]</a>)</p>\n</dd>\n<dt><strong>max_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>To keep kurtosis values within a plausible biophysical range,\nradial kurtosis values that are larger than <cite>max_kurtosis</cite> are\nreplaced with <cite>max_kurtosis</cite>. Default = 10</p>\n</dd>\n<dt><strong>analytical</strong><span class=\"classifier\">bool (optional)</span></dt><dd><p>If True, RK is calculated using its analytical solution, otherwise\nan exact numerical estimator is used (see Notes). Default is set to\nTrue</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rk</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated RK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RK is defined as the average of the directional kurtosis perpendicular\nto the fiber\u2019s main direction e1 <a class=\"reference internal\" href=\"#r28a508c47eba-1\" id=\"id298\">[1]</a>, <a class=\"reference internal\" href=\"#r28a508c47eba-2\" id=\"id299\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<dl class=\"simple\">\n<dt>RK equiv frac{1}{2pi} int dOmega _mathbf{theta}</dt><dd><p>K(mathbf{theta}) delta (mathbf{theta}cdot mathbf{e}_1)</p>\n</dd>\n</dl>\n<p>This equation can be numerically computed by averaging apparent\ndirectional kurtosis samples for directions perpendicular to e1.</p>\n<p>Otherwise, RK can be calculated from its analytical solution <a class=\"reference internal\" href=\"#r28a508c47eba-2\" id=\"id300\">[2]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[K_{\\bot} = G_1(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2222} +\n           G_1(\\lambda_1,\\lambda_3,\\lambda_2)\\hat{W}_{3333} +\n           G_2(\\lambda_1,\\lambda_2,\\lambda_3)\\hat{W}_{2233}\\]</div>\n<p>where:</p>\n<div class=\"math notranslate nohighlight\">\n\\[G_1(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{18\\lambda_2(\\lambda_2-\n\\lambda_3)} \\left (2\\lambda_2 +\n\\frac{\\lambda_3^2-3\\lambda_2\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}\n\\right)\\]</div>\n<p>and</p>\n<div class=\"math notranslate nohighlight\">\n\\[ G_2(\\lambda_1,\\lambda_2,\\lambda_3)=\n\\frac{(\\lambda_1+\\lambda_2+\\lambda_3)^2}{(\\lambda_2-\\lambda_3)^2}\n\\left ( \\frac{\\lambda_2+\\lambda_3}{\\sqrt{\\lambda_2\\lambda_3}}-\n2\\right )\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r28a508c47eba-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id271\">1</a>,<a href=\"#id296\">2</a>,<a href=\"#id298\">3</a>)</span></dt>\n<dd><p>Jensen, J.H., Helpern, J.A., 2010. MRI quantification of\nnon-Gaussian water diffusion by kurtosis analysis. NMR in\nBiomedicine 23(7): 698-710</p>\n</dd>\n<dt class=\"label\" id=\"r28a508c47eba-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id299\">1</a>,<a href=\"#id300\">2</a>)</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.\nEstimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd>\n<dt class=\"label\" id=\"r28a508c47eba-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id297\">3</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id304\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a><a class=\"headerlink\" href=\"#id304\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">DiffusionKurtosisModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Class for the Diffusion Kurtosis Model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel.fit\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the DKI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel.predict\" title=\"dipy.reconst.dki_micro.DiffusionKurtosisModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(dki_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this DKI model class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion Kurtosis Tensor Model [1]</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:\n\u2018OLS\u2019 or \u2018ULLS\u2019 for ordinary least squares</p>\n<blockquote>\n<div><p>dki.ols_fit_dki</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 or \u2018UWLLS\u2019 for weighted ordinary least squares</dt><dd><p>dki.wls_fit_dki</p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id305\"><span class=\"problematic\" id=\"id306\">*</span></a>args, <a href=\"#id307\"><span class=\"problematic\" id=\"id308\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r37c013a7aa4e-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tabesh, A., Jensen, J.H., Ardekani, B.A., Helpern, J.A., 2011.</p>\n</dd>\n</dl>\n<p>Estimation of tensors and tensor-derived measures in diffusional\nkurtosis imaging. Magn Reson Med. 65(3), 823-836</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the DKI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal from one voxel.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.DiffusionKurtosisModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.DiffusionKurtosisModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this DKI model class instance given\nparameters.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"kurtosismicrostructuralfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructuralFit</span></code></a><a class=\"headerlink\" href=\"#kurtosismicrostructuralfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">KurtosisMicrostructuralFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisFit\" title=\"dipy.reconst.dki.DiffusionKurtosisFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dki.DiffusionKurtosisFit</span></code></a></p>\n<p>Class for fitting the Diffusion Kurtosis Microstructural Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">awf</span></code></a></dt><dd><p>Returns the volume fraction of the restricted diffusion compartment also known as axonal water fraction.</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">axonal_diffusivity</span></code></a></dt><dd><p>Returns the axonal diffusivity defined as the restricted diffusion tensor trace <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id310\">1</a>.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hindered_ad</span></code></a></dt><dd><p>Returns the axial diffusivity of the hindered compartment.</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hindered_evals</span></code></a></dt><dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">hindered_rd</span></code></a></dt><dd><p>Returns the radial diffusivity of the hindered compartment.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kfa</span></code></dt><dd><p>Returns the kurtosis tensor (KFA) <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id311\">1</a>.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kt</span></code></dt><dd><p>Returns the 15 independent elements of the kurtosis tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">restricted_evals</span></code></a></dt><dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.tortuosity\" title=\"dipy.reconst.dki_micro.tortuosity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tortuosity</span></code></a></dt><dd><p>Returns the tortuosity of the hindered diffusion which is defined by ADe / RDe, where ADe and RDe are the axial and radial diffusivities of the hindered compartment <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id312\">1</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ak</span></code>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Axial Kurtosis (AK) of a diffusion kurtosis tensor <span id=\"id313\">[R0b1a747e81c9-1]</span>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">akc</span></code>(sphere)</p></td>\n<td><p>Calculates the apparent kurtosis coefficient (AKC) in each direction on the sphere for each voxel in the data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">kmax</span></code>([sphere,\u00a0gtol,\u00a0mask])</p></td>\n<td><p>Computes the maximum value of a single voxel kurtosis tensor</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mk</span></code>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Computes mean Kurtosis (MK) from the kurtosis tensor.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mkt</span></code>([min_kurtosis,\u00a0max_kurtosis])</p></td>\n<td><p>Computes mean of the kurtosis tensor (MKT) <span id=\"id314\">[R8b3dd90f2e0d-1]</span>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a DKI microstructural model fit, predict the signal on the vertices of a gradient table</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rk</span></code>([min_kurtosis,\u00a0max_kurtosis,\u00a0analytical])</p></td>\n<td><p>Radial Kurtosis (RK) of a diffusion kurtosis tensor <span id=\"id315\">[Rc4101656d30e-1]</span>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a KurtosisMicrostructural Fit class instance.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>model</strong><span class=\"classifier\">DiffusionKurtosisModel Class instance</span></dt><dd><p>Class instance containing the Diffusion Kurtosis Model for the fit</p>\n</dd>\n<dt><strong>model_params</strong><span class=\"classifier\">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis\nmicrostructural model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n<li><p>Six elements of the hindered diffusion tensor</p></li>\n<li><p>Six elements of the restricted diffusion tensor</p></li>\n<li><p>Axonal water fraction</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In the original article of DKI microstructural model <a class=\"reference internal\" href=\"#re21233a693ae-1\" id=\"id316\">[1]</a>, the hindered\nand restricted tensors were definde as the intra-cellular and\nextra-cellular diffusion compartments respectively.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re21233a693ae-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id316\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">awf</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.awf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the volume fraction of the restricted diffusion compartment\nalso known as axonal water fraction.</p>\n<p class=\"rubric\">Notes</p>\n<p>The volume fraction of the restricted diffusion compartment can be seem\nas the volume fraction of the intra-cellular compartment <a class=\"reference internal\" href=\"#r4c8a5eb03d8b-1\" id=\"id318\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r4c8a5eb03d8b-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id318\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">axonal_diffusivity</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.axonal_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the axonal diffusivity defined as the restricted diffusion\ntensor trace <a class=\"reference internal\" href=\"#rb958a4769cfc-1\" id=\"id320\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb958a4769cfc-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id320\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">hindered_ad</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_ad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the axial diffusivity of the hindered compartment.</p>\n<p class=\"rubric\">Notes</p>\n<p>The hindered diffusion tensor can be seem as the tissue\u2019s\nextra-cellular diffusion compartment <a class=\"reference internal\" href=\"#rcb29c1d0417b-1\" id=\"id322\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcb29c1d0417b-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id322\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">hindered_evals</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_evals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvalues of the hindered diffusion compartment.</p>\n<p class=\"rubric\">Notes</p>\n<p>The hindered diffusion tensor can be seem as the tissue\u2019s\nextra-cellular diffusion compartment <a class=\"reference internal\" href=\"#r948cec370d67-1\" id=\"id324\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r948cec370d67-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id324\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">hindered_rd</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.hindered_rd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the radial diffusivity of the hindered compartment.</p>\n<p class=\"rubric\">Notes</p>\n<p>The hindered diffusion tensor can be seem as the tissue\u2019s\nextra-cellular diffusion compartment <a class=\"reference internal\" href=\"#r83ec1ea181c7-1\" id=\"id326\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r83ec1ea181c7-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id326\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a DKI microstructural model fit, predict the signal on the\nvertices of a gradient table</p>\n<dl class=\"simple\">\n<dt>gtab<span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt>S0<span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<p><span class=\"math notranslate nohighlight\">\\(S(\\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\\)</span>,\nwhere <span class=\"math notranslate nohighlight\">\\(ADC_{r}\\)</span> and <span class=\"math notranslate nohighlight\">\\(ADC_{h}\\)</span> are the apparent diffusion coefficients\nof the diffusion hindered and restricted compartment for a given\ndirection <span class=\"math notranslate nohighlight\">\\(\\theta\\)</span>, <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b value provided in the GradientTable\ninput for that direction, <span class=\"math notranslate nohighlight\">\\(f\\)</span> is the volume fraction of the restricted\ndiffusion compartment (also known as the axonal water fraction).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">restricted_evals</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.restricted_evals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvalues of the restricted diffusion compartment.</p>\n<p class=\"rubric\">Notes</p>\n<p>The restricted diffusion tensor can be seem as the tissue\u2019s\nintra-cellular diffusion compartment <a class=\"reference internal\" href=\"#rd96f073eac17-1\" id=\"id328\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd96f073eac17-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id328\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">tortuosity</code><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructuralFit.tortuosity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the tortuosity of the hindered diffusion which is defined\nby ADe / RDe, where ADe and RDe are the axial and radial diffusivities\nof the hindered compartment <a class=\"reference internal\" href=\"#r09f7b36bb2d5-1\" id=\"id330\">[1]</a>.</p>\n<p class=\"rubric\">Notes</p>\n<p>The hindered diffusion tensor can be seem as the tissue\u2019s\nextra-cellular diffusion compartment <a class=\"reference internal\" href=\"#r09f7b36bb2d5-1\" id=\"id331\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r09f7b36bb2d5-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id330\">1</a>,<a href=\"#id331\">2</a>)</span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"kurtosismicrostructuremodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructureModel</span></code></a><a class=\"headerlink\" href=\"#kurtosismicrostructuremodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">KurtosisMicrostructureModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dki.DiffusionKurtosisModel\" title=\"dipy.reconst.dki.DiffusionKurtosisModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dki.DiffusionKurtosisModel</span></code></a></p>\n<p>Class for the Diffusion Kurtosis Microstructural Model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask,\u00a0sphere,\u00a0gtol,\u00a0awf_only])</p></td>\n<td><p>Fit method of the Diffusion Kurtosis Microstructural Model</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict\" title=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for the DKI microstructural model class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a KurtosisMicrostrutureModel class instance <a class=\"reference internal\" href=\"#r54404032803e-1\" id=\"id333\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:\n\u2018OLS\u2019 or \u2018ULLS\u2019 to fit the diffusion tensor and kurtosis tensor\nusing the ordinary linear least squares solution</p>\n<blockquote>\n<div><p>dki.ols_fit_dki</p>\n</div></blockquote>\n<p>\u2018WLS\u2019 or \u2018UWLLS\u2019 to fit the diffusion tensor and kurtosis tensor\nusing the ordinary linear least squares solution</p>\n<blockquote>\n<div><p>dki.wls_fit_dki</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id334\"><span class=\"problematic\" id=\"id335\">*</span></a>args, <a href=\"#id336\"><span class=\"problematic\" id=\"id337\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dki.ols_fit_dki, dki.wls_fit_dki for details</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r54404032803e-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id333\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=0.01</em>, <em class=\"sig-param\">awf_only=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the Diffusion Kurtosis Microstructural Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>An 4D matrix containing the diffusion-weighted data.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[-1]</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of\nthe maximal value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the\ndirections sampled on the sphere class instance. The gradient of\nthe convergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken\nfrom the initial sampled directions of the given sphere object</p>\n</dd>\n<dt><strong>awf_only</strong><span class=\"classifier\">bool, optiomal</span></dt><dd><p>If set to true only the axonal volume fraction is computed from\nthe kurtosis tensor. Default = False</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.KurtosisMicrostructureModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for the DKI microstructural model class instance\ngiven parameters.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>params</strong><span class=\"classifier\">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis\nmicrostructural model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n<li><p>Six elements of the hindered diffusion tensor</p></li>\n<li><p>Six elements of the restricted diffusion tensor</p></li>\n<li><p>Axonal water fraction</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In the original article of DKI microstructural model <a class=\"reference internal\" href=\"#r34e1450d7d99-1\" id=\"id339\">[1]</a>, the hindered\nand restricted tensors were definde as the intra-cellular and\nextra-cellular diffusion compartments respectively.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r34e1450d7d99-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id339\">1</a></span></dt>\n<dd><p>Fieremans, E., Jensen, J.H., Helpern, J.A., 2011. White Matter\nCharacterization with Diffusion Kurtosis Imaging. Neuroimage\n58(1): 177-188. doi:10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"axial-diffusivity\">\n<h3>axial_diffusivity<a class=\"headerlink\" href=\"#axial-diffusivity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.axial_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">axial_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.axial_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial Diffusivity (AD) of a diffusion tensor.\nAlso called parallel diffusivity.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order\nalong <cite>axis</cite>.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ad</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated AD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>AD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AD = \\lambda_1\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"axonal-water-fraction\">\n<h3>axonal_water_fraction<a class=\"headerlink\" href=\"#axonal-water-fraction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.axonal_water_fraction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">axonal_water_fraction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=0.01</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.axonal_water_fraction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the axonal water fraction from DKI <a class=\"reference internal\" href=\"#r48388d37c81b-1\" id=\"id341\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the\nmaximal value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maxima under the precision of the\ndirections sampled on the sphere class instance. The gradient of the\nconvergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken from\nthe initial sampled directions of the given sphere object</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be\nanalyzed that has the shape dki_params.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>awf</strong><span class=\"classifier\">ndarray (x, y, z) or (n)</span></dt><dd><p>Axonal Water Fraction</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r48388d37c81b-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id18\">1</a>,<a href=\"#id341\">2</a>)</span></dt>\n<dd><p>Fieremans E, Jensen JH, Helpern JA, 2011. White matter\ncharacterization with diffusional kurtosis imaging.\nNeuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id343\">\n<h3>decompose_tensor<a class=\"headerlink\" href=\"#id343\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.decompose_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">decompose_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.decompose_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>\n<p>Computes tensor eigen decomposition to calculate eigenvalues and\neigenvectors (Basser et al., 1994a).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,\nmuch smaller than the diffusion weighting, cause quite a lot of noise\nin metrics such as fa, diffusivity values smaller than\n<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative\neigenvalues are replaced by zero. Sorted from largest to smallest.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[\u2026, :, j] is associated with\neigvals[\u2026, j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusion-components\">\n<h3>diffusion_components<a class=\"headerlink\" href=\"#diffusion-components\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.diffusion_components\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">diffusion_components</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">awf=None</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.diffusion_components\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Extracts the restricted and hindered diffusion tensors of well aligned\nfibers from diffusion kurtosis imaging parameters <a class=\"reference internal\" href=\"#rfba5c976a30b-1\" id=\"id344\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions to sample the restricted and\nhindered cellular diffusion tensors. For more details see Fieremans\net al., 2011.</p>\n</dd>\n<dt><strong>awf</strong><span class=\"classifier\">ndarray (optional)</span></dt><dd><p>Array containing values of the axonal water fraction that has the shape\ndki_params.shape[:-1]. If not given this will be automatically computed\nusing <a class=\"reference internal\" href=\"#dipy.reconst.dki_micro.axonal_water_fraction\" title=\"dipy.reconst.dki_micro.axonal_water_fraction\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">axonal_water_fraction()</span></code></a>\u201d with function\u2019s default precision.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray (optional)</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be\nanalyzed that has the shape dki_params.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>edt</strong><span class=\"classifier\">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the hindered diffusion tensor.</p>\n</dd>\n<dt><strong>idt</strong><span class=\"classifier\">ndarray (x, y, z, 6) or (n, 6)</span></dt><dd><p>Parameters of the restricted diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In the original article of DKI microstructural model <a class=\"reference internal\" href=\"#rfba5c976a30b-1\" id=\"id345\">[1]</a>, the hindered and\nrestricted tensors were definde as the intra-cellular and extra-cellular\ndiffusion compartments respectively.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rfba5c976a30b-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id19\">1</a>,<a href=\"#id344\">2</a>,<a href=\"#id345\">3</a>)</span></dt>\n<dd><p>Fieremans E, Jensen JH, Helpern JA, 2011. White matter\ncharacterization with diffusional kurtosis imaging.\nNeuroimage 58(1):177-88. doi: 10.1016/j.neuroimage.2011.06.006</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id347\">\n<h3>directional_diffusion<a class=\"headerlink\" href=\"#id347\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.directional_diffusion\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">directional_diffusion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dt</em>, <em class=\"sig-param\">V</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.directional_diffusion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent diffusion coefficient (adc) in each direction\nof a sphere for a single voxel <a class=\"reference internal\" href=\"#r1dff1a553580-1\" id=\"id348\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dt</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>\n</dd>\n<dt><strong>V</strong><span class=\"classifier\">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues\ncause quite a lot of noise in diffusion-based metrics, diffusivity\nvalues smaller than <cite>min_diffusivity</cite> are replaced with\n<cite>min_diffusivity</cite>. Default = 0</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adc</strong><span class=\"classifier\">ndarray (g,)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere\nfor a single voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1dff1a553580-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id20\">1</a>,<a href=\"#id348\">2</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id350\">\n<h3>directional_kurtosis<a class=\"headerlink\" href=\"#id350\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.directional_kurtosis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">directional_kurtosis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dt</em>, <em class=\"sig-param\">md</em>, <em class=\"sig-param\">kt</em>, <em class=\"sig-param\">V</em>, <em class=\"sig-param\">min_diffusivity=0</em>, <em class=\"sig-param\">min_kurtosis=-0.42857142857142855</em>, <em class=\"sig-param\">adc=None</em>, <em class=\"sig-param\">adv=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.directional_kurtosis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the apparent kurtosis coefficient (akc) in each direction\nof a sphere for a single voxel <a class=\"reference internal\" href=\"#r014624b5ce79-1\" id=\"id351\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dt</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>elements of the diffusion tensor of the voxel.</p>\n</dd>\n<dt><strong>md</strong><span class=\"classifier\">float</span></dt><dd><p>mean diffusivity of the voxel</p>\n</dd>\n<dt><strong>kt</strong><span class=\"classifier\">array (15,)</span></dt><dd><p>elements of the kurtosis tensor of the voxel.</p>\n</dd>\n<dt><strong>V</strong><span class=\"classifier\">array (g, 3)</span></dt><dd><p>g directions of a Sphere in Cartesian coordinates</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues\ncause quite a lot of noise in diffusion-based metrics, diffusivity\nvalues smaller than <cite>min_diffusivity</cite> are replaced with\n<cite>min_diffusivity</cite>. Default = 0</p>\n</dd>\n<dt><strong>min_kurtosis</strong><span class=\"classifier\">float (optional)</span></dt><dd><p>Because high-amplitude negative values of kurtosis are not physicaly\nand biologicaly pluasible, and these cause artefacts in\nkurtosis-based measures, directional kurtosis values smaller than\n<cite>min_kurtosis</cite> are replaced with <cite>min_kurtosis</cite>. Default = -3./7\n(theoretical kurtosis limit for regions that consist of water confined\nto spherical pores <a class=\"reference internal\" href=\"#r014624b5ce79-2\" id=\"id352\">[2]</a>)</p>\n</dd>\n<dt><strong>adc</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion coefficient (adc) in all g directions of a sphere\nfor a single voxel.</p>\n</dd>\n<dt><strong>adv</strong><span class=\"classifier\">ndarray(g,) (optional)</span></dt><dd><p>Apparent diffusion variance (advc) in all g directions of a sphere for\na single voxel.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>akc</strong><span class=\"classifier\">ndarray (g,)</span></dt><dd><p>Apparent kurtosis coefficient (AKC) in all g directions of a sphere for\na single voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r014624b5ce79-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id21\">1</a>,<a href=\"#id351\">2</a>)</span></dt>\n<dd><p>Neto Henriques R, Correia MM, Nunes RG, Ferreira HA (2015).\nExploring the 3D geometry of the diffusion kurtosis tensor -\nImpact on the development of robust tractography procedures and\nnovel biomarkers, NeuroImage 111: 85-99</p>\n</dd>\n<dt class=\"label\" id=\"r014624b5ce79-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id352\">2</a></span></dt>\n<dd><p>Barmpoutis, A., &amp; Zhuo, J., 2011. Diffusion kurtosis imaging:\nRobust estimation from DW-MRI using homogeneous polynomials.\nProceedings of the 8th {IEEE} International Symposium on\nBiomedical Imaging: From Nano to Macro, ISBI 2011, 262-265.\ndoi: 10.1109/ISBI.2011.5872402</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"dkimicro-prediction\">\n<h3>dkimicro_prediction<a class=\"headerlink\" href=\"#dkimicro-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.dkimicro_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">dkimicro_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.dkimicro_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Signal prediction given the DKI microstructure model parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">ndarray (x, y, z, 40) or (n, 40)</span></dt><dd></dd>\n<dt><strong>All parameters estimated from the diffusion kurtosis microstructure model.</strong></dt><dd><dl class=\"simple\">\n<dt>Parameters are ordered as follows:</dt><dd><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n<li><p>Six elements of the hindered diffusion tensor</p></li>\n<li><p>Six elements of the restricted diffusion tensor</p></li>\n<li><p>Axonal water fraction</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated signal based on the DKI microstructure model</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>1) The predicted signal is given by:\n<span class=\"math notranslate nohighlight\">\\(S(\\theta, b) = S_0 * [f * e^{-b ADC_{r}} + (1-f) * e^{-b ADC_{h}]\\)</span>, where\n:math:` ADC_{r} and ADC_{h} are the apparent diffusion coefficients of the\ndiffusion hindered and restricted compartment for a given direction\n<cite>theta:math:</cite>, <cite>b:math:</cite> is the b value provided in the GradientTable input for that\ndirection, <a href=\"#id355\"><span class=\"problematic\" id=\"id356\">`</span></a>f$ is the volume fraction of the restricted diffusion\ncompartment (also known as the axonal water fraction).</p>\n<p>2) In the original article of DKI microstructural model <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id357\">1</a>, the hindered\nand restricted tensors were definde as the intra-cellular and\nextra-cellular diffusion compartments respectively.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"dti-design-matrix\">\n<h3>dti_design_matrix<a class=\"headerlink\" href=\"#dti-design-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.dti_design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">dti_design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.dti_design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for DTI weighted least squares or\nleast squares fitting. (Basser et al., 1994a)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">A GradientTable class instance</span></dt><dd></dd>\n<dt><strong>dtype</strong><span class=\"classifier\">string</span></dt><dd><p>Parameter to control the dtype of returned designed matrix</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model\ndesign_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id358\">\n<h3>from_lower_triangular<a class=\"headerlink\" href=\"#id358\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.from_lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">from_lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.from_lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns a tensor given the six unique tensor elements</p>\n<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,\nDyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are\nignored.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">array_like, (\u2026, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">ndarray (\u2026, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id359\">\n<h3>get_sphere<a class=\"headerlink\" href=\"#id359\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.get_sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">get_sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name='symmetric362'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.get_sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>provide triangulated spheres</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>which sphere - one of:\n* \u2018symmetric362\u2019\n* \u2018symmetric642\u2019\n* \u2018symmetric724\u2019\n* \u2018repulsion724\u2019\n* \u2018repulsion100\u2019\n* \u2018repulsion200\u2019</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">a dipy.core.sphere.Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;symmetric362&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">faces</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">362</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">faces</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">720</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;not a sphere name&#39;</span><span class=\"p\">)</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">DataError</span>: <span class=\"n\">No sphere called &quot;not a sphere name&quot;</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id360\">\n<h3>kurtosis_maximum<a class=\"headerlink\" href=\"#id360\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.kurtosis_maximum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">kurtosis_maximum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em>, <em class=\"sig-param\">sphere='repulsion100'</em>, <em class=\"sig-param\">gtol=0.01</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.kurtosis_maximum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes kurtosis maximum value</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eingenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>The sphere providing sample directions for the initial search of the\nmaximal value of kurtosis.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This input is to refine kurtosis maximum under the precision of the\ndirections sampled on the sphere class instance. The gradient of the\nconvergence procedure must be less than gtol before successful\ntermination. If gtol is None, fiber direction is directly taken from\nthe initial sampled directions of the given sphere object</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be\nanalyzed that has the shape dki_params.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>max_value</strong><span class=\"classifier\">float</span></dt><dd><p>kurtosis tensor maximum value</p>\n</dd>\n<dt><strong>max_dir</strong><span class=\"classifier\">array (3,)</span></dt><dd><p>Cartesian coordinates of the direction of the maximal kurtosis value</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id361\">\n<h3>lower_triangular<a class=\"headerlink\" href=\"#id361\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the six lower triangular values of the tensor and a dummy variable\nif b0 is not None</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array_like (\u2026, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>\n</dd>\n<dt><strong>b0</strong><span class=\"classifier\">float</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (\u2026, 6) otherwise (\u2026, 7)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id362\">\n<h3>mean_diffusivity<a class=\"headerlink\" href=\"#id362\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.mean_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">mean_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.mean_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1 + \\lambda_2 + \\lambda_3}{3}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id363\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id363\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"radial-diffusivity\">\n<h3>radial_diffusivity<a class=\"headerlink\" href=\"#radial-diffusivity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.radial_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">radial_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.radial_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial Diffusivity (RD) of a diffusion tensor.\nAlso called perpendicular diffusivity.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order\nalong <cite>axis</cite>.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rd</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated RD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[RD = \\frac{\\lambda_2 + \\lambda_3}{2}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id364\">\n<h3>split_dki_param<a class=\"headerlink\" href=\"#id364\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.split_dki_param\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">split_dki_param</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dki_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.split_dki_param\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Extract the diffusion tensor eigenvalues, the diffusion tensor\neigenvector matrix, and the 15 independent elements of the kurtosis tensor\nfrom the model parameters estimated from the DKI model</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>dki_params</strong><span class=\"classifier\">ndarray (x, y, z, 27) or (n, 27)</span></dt><dd><p>All parameters estimated from the diffusion kurtosis model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the first,\nsecond and third coordinates of the eigenvector</p></li>\n<li><p>Fifteen elements of the kurtosis tensor</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (x, y, z, 3) or (n, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (x, y, z, 3, 3) or (n, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[:,j] is associated with\neigvals[j])</p>\n</dd>\n<dt><strong>kt</strong><span class=\"classifier\">array (x, y, z, 15) or (n, 15)</span></dt><dd><p>Fifteen elements of the kurtosis tensor</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"tortuosity\">\n<h3>tortuosity<a class=\"headerlink\" href=\"#tortuosity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.tortuosity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">tortuosity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">hindered_ad</em>, <em class=\"sig-param\">hindered_rd</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.tortuosity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the tortuosity of the hindered diffusion compartment given\nits axial and radial diffusivities</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>hindered_ad: ndarray</strong></dt><dd><p>Array containing the values of the hindered axial diffusivity.</p>\n</dd>\n<dt><strong>hindered_rd: ndarray</strong></dt><dd><p>Array containing the values of the hindered radial diffusivity.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>Tortuosity of the hindered diffusion compartment</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"trace\">\n<h3>trace<a class=\"headerlink\" href=\"#trace\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.trace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">trace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.trace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Trace of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>trace</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated trace of the diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Trace is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Trace = \\lambda_1 + \\lambda_2 + \\lambda_3\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id365\">\n<h3>vec_val_vect<a class=\"headerlink\" href=\"#id365\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dki_micro.vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dki_micro.</code><code class=\"sig-name descname\">vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dki_micro.vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">shape (\u2026, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>\n</dd>\n<dt><strong>vals</strong><span class=\"classifier\">shape (\u2026, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> shape above must\nmatch that for <cite>vecs</cite></p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">shape (\u2026, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code>, loops to get (M, N) <code class=\"docutils literal notranslate\"><span class=\"pre\">vec</span></code>\nmatrix, and (N,) <code class=\"docutils literal notranslate\"><span class=\"pre\">vals</span></code> vector, and calculates\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Make a 3D array where the first dimension is only 1</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec_val_vect</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">vals</span><span class=\"p\">)</span>\n<span class=\"go\">array([[[   9.,   24.,   39.],</span>\n<span class=\"go\">        [  24.,   66.,  108.],</span>\n<span class=\"go\">        [  39.,  108.,  177.]]])</span>\n</pre></div>\n</div>\n<p>That\u2019s the same as the 2D case (apart from the float casting):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">),</span> <span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n<span class=\"go\">array([[  9,  24,  39],</span>\n<span class=\"go\">       [ 24,  66, 108],</span>\n<span class=\"go\">       [ 39, 108, 177]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id366\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.Cache\" title=\"dipy.reconst.dsi.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id366\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.dsi.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.Cache.cache_clear\" title=\"dipy.reconst.dsi.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.Cache.cache_get\" title=\"dipy.reconst.dsi.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.Cache.cache_set\" title=\"dipy.reconst.dsi.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionspectrumdeconvfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvFit</span></code></a><a class=\"headerlink\" href=\"#diffusionspectrumdeconvfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">DiffusionSpectrumDeconvFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dsi.DiffusionSpectrumFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd_discrete</span></code>([normalized])</p></td>\n<td><p>Calculates the mean squared displacement on the discrete propagator</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>Calculates the real discrete odf for a given discrete sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf</span></code></a>()</p></td>\n<td><p>Applies the 3D FFT in the q-space grid to generate the DSI diffusion propagator, remove the background noise with a hard threshold and then deconvolve the propagator with the Lucy-Richardson deconvolution algorithm</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_pdf</span></code>([normalized])</p></td>\n<td><p>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_signal</span></code>([filtering])</p></td>\n<td><p>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>DiffusionSpectrumModel</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>signal values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf\">\n<code class=\"sig-name descname\">pdf</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvFit.pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies the 3D FFT in the q-space grid to generate\nthe DSI diffusion propagator, remove the background noise with a\nhard threshold and then deconvolve the propagator with the\nLucy-Richardson deconvolution algorithm</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionspectrumdeconvmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvModel</span></code></a><a class=\"headerlink\" href=\"#diffusionspectrumdeconvmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">DiffusionSpectrumDeconvModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">qgrid_size=35</em>, <em class=\"sig-param\">r_start=4.1</em>, <em class=\"sig-param\">r_end=13.0</em>, <em class=\"sig-param\">r_step=0.4</em>, <em class=\"sig-param\">filter_width=inf</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dsi.DiffusionSpectrumModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit\" title=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">qgrid_size=35</em>, <em class=\"sig-param\">r_start=4.1</em>, <em class=\"sig-param\">r_end=13.0</em>, <em class=\"sig-param\">r_step=0.4</em>, <em class=\"sig-param\">filter_width=inf</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion Spectrum Deconvolution</p>\n<p>The idea is to remove the convolution on the DSI propagator that is\ncaused by the truncation of the q-space in the DSI sampling.</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{eqnarray*}</dt><dd><p>P_{dsi}(mathbf{r}) &amp; = &amp; S_{0}^{-1}iiintlimits_{| mathbf{q} | le mathbf{q_{max}}} S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \\\n&amp; = &amp; S_{0}^{-1}iiintlimits_{mathbf{q}} left( S(mathbf{q}) cdot M(mathbf{q}) right) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} \\\n&amp; = &amp; P(mathbf{r}) otimes left( S_{0}^{-1}iiintlimits_{mathbf{q}}  M(mathbf{q}) exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{q} right) \\</p>\n</dd>\n</dl>\n<p>end{eqnarray*}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\mathbf{r}\\)</span> is the displacement vector and <span class=\"math notranslate nohighlight\">\\(\\mathbf{q}\\)</span> is the\nwave vector which corresponds to different gradient directions,\n<span class=\"math notranslate nohighlight\">\\(M(\\mathbf{q})\\)</span> is a mask corresponding to your q-space sampling and\n<span class=\"math notranslate nohighlight\">\\(\\otimes\\)</span> is the convolution operator <a class=\"reference internal\" href=\"#rb9b5836384d2-1\" id=\"id367\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>Gradient directions and bvalues container class</p>\n</dd>\n<dt><strong>qgrid_size</strong><span class=\"classifier\">int,</span></dt><dd><p>has to be an odd number. Sets the size of the q_space grid.\nFor example if qgrid_size is 35 then the shape of the grid will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(35,</span> <span class=\"pre\">35,</span> <span class=\"pre\">35)</span></code>.</p>\n</dd>\n<dt><strong>r_start</strong><span class=\"classifier\">float,</span></dt><dd><p>ODF is sampled radially in the PDF. This parameters shows where the\nsampling should start.</p>\n</dd>\n<dt><strong>r_end</strong><span class=\"classifier\">float,</span></dt><dd><p>Radial endpoint of ODF sampling</p>\n</dd>\n<dt><strong>r_step</strong><span class=\"classifier\">float,</span></dt><dd><p>Step size of the ODf sampling from r_start to r_end</p>\n</dd>\n<dt><strong>filter_width</strong><span class=\"classifier\">float,</span></dt><dd><p>Strength of the hanning filter</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb9b5836384d2-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id367\">1</a></span></dt>\n<dd><p>Canales-Rodriguez E.J et al., \u201cDeconvolution in Diffusion</p>\n</dd>\n</dl>\n<p>Spectrum Imaging\u201d, Neuroimage, 2010.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb9b5836384d2-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Biggs David S.C. et al., \u201cAcceleration of Iterative Image</p>\n</dd>\n</dl>\n<p>Restoration Algorithms\u201d, Applied Optics, vol. 36, No. 8, p. 1766-1775,\n1997.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumDeconvModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionspectrumfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumFit</span></code></a><a class=\"headerlink\" href=\"#diffusionspectrumfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">DiffusionSpectrumFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd_discrete</span></code></a>([normalized])</p></td>\n<td><p>Calculates the mean squared displacement on the discrete propagator</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.odf\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>Calculates the real discrete odf for a given discrete sphere</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.pdf\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit.pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf</span></code></a>([normalized])</p></td>\n<td><p>Applies the 3D FFT in the q-space grid to generate the diffusion propagator</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_pdf</span></code></a>([normalized])</p></td>\n<td><p>Calculates the return to origin probability from the propagator, which is the propagator evaluated at zero (see Descoteaux et Al.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal\" title=\"dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_signal</span></code></a>([filtering])</p></td>\n<td><p>Calculates the return to origin probability (rtop) from the signal rtop equals to the sum of all signal values</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates PDF and ODF and other properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>DiffusionSpectrumModel</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>signal values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete\">\n<code class=\"sig-name descname\">msd_discrete</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">normalized=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.msd_discrete\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the mean squared displacement on the discrete propagator</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}int_{-infty}^{infty} P(hat{mathbf{r}}) cdot hat{mathbf{r}}^{2} dr_x dr_y dr_z</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{\\mathbf{r}}\\)</span> is a point in the 3D Propagator space\n(see Wu et al. <a class=\"reference internal\" href=\"#rd62ffbcc354a-1\" id=\"id370\">[1]</a>).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>normalized</strong><span class=\"classifier\">boolean, optional</span></dt><dd><p>Whether to normalize the propagator by its sum in order to obtain a\npdf. Default: True</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>msd</strong><span class=\"classifier\">float</span></dt><dd><p>the mean square displacement</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd62ffbcc354a-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id370\">1</a></span></dt>\n<dd><p>Wu Y. et al., \u201cHybrid diffusion imaging\u201d, NeuroImage, vol 36,</p>\n</dd>\n</dl>\n<ol class=\"loweralpha simple\" start=\"16\">\n<li><p>617-629, 2007.</p></li>\n</ol>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the real discrete odf for a given discrete sphere</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>psi_{DSI}(hat{mathbf{u}})=int_{0}^{infty}P(rhat{mathbf{u}})r^{2}dr</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{\\mathbf{u}}\\)</span> is the unit vector which corresponds to a\nsphere point.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.pdf\">\n<code class=\"sig-name descname\">pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">normalized=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies the 3D FFT in the q-space grid to generate\nthe diffusion propagator</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf\">\n<code class=\"sig-name descname\">rtop_pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">normalized=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the return to origin probability from the propagator, which is\nthe propagator evaluated at zero (see Descoteaux et Al. <a class=\"reference internal\" href=\"#rca1849cdf01b-1\" id=\"id372\">[1]</a>,\nTuch <a class=\"reference internal\" href=\"#rca1849cdf01b-2\" id=\"id373\">[2]</a>, Wu et al. <a class=\"reference internal\" href=\"#rca1849cdf01b-3\" id=\"id374\">[3]</a>)\nrtop = P(0)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>normalized</strong><span class=\"classifier\">boolean, optional</span></dt><dd><p>Whether to normalize the propagator by its sum in order to obtain a\npdf. Default: True.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rtop</strong><span class=\"classifier\">float</span></dt><dd><p>the return to origin probability</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rca1849cdf01b-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id372\">1</a></span></dt>\n<dd><p>Descoteaux M. et al., \u201cMultiple q-shell diffusion propagator</p>\n</dd>\n</dl>\n<p>imaging\u201d, Medical Image Analysis, vol 15, No. 4, p. 603-621, 2011.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rca1849cdf01b-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id373\">2</a></span></dt>\n<dd><p>Tuch D.S., \u201cDiffusion MRI of Complex Tissue Structure\u201d,\nPhD Thesis, 2002.</p>\n</dd>\n<dt class=\"label\" id=\"rca1849cdf01b-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id374\">3</a></span></dt>\n<dd><p>Wu Y. et al., \u201cComputation of Diffusion Function Measures</p>\n</dd>\n</dl>\n<p>in q -Space Using Magnetic Resonance Hybrid Diffusion Imaging\u201d,\nIEEE TRANSACTIONS ON MEDICAL IMAGING, vol. 27, No. 6, p. 858-865, 2008</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal\">\n<code class=\"sig-name descname\">rtop_signal</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">filtering=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumFit.rtop_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the return to origin probability (rtop) from the signal\nrtop equals to the sum of all signal values</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>filtering</strong><span class=\"classifier\">boolean, optional</span></dt><dd><p>Whether to perform Hanning filtering. Default: True</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rtop</strong><span class=\"classifier\">float</span></dt><dd><p>the return to origin probability</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"diffusionspectrummodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumModel</span></code></a><a class=\"headerlink\" href=\"#diffusionspectrummodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">DiffusionSpectrumModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">qgrid_size=17</em>, <em class=\"sig-param\">r_start=2.1</em>, <em class=\"sig-param\">r_end=6.0</em>, <em class=\"sig-param\">r_step=0.2</em>, <em class=\"sig-param\">filter_width=32</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel.fit\" title=\"dipy.reconst.dsi.DiffusionSpectrumModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">qgrid_size=17</em>, <em class=\"sig-param\">r_start=2.1</em>, <em class=\"sig-param\">r_end=6.0</em>, <em class=\"sig-param\">r_step=0.2</em>, <em class=\"sig-param\">filter_width=32</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion Spectrum Imaging</p>\n<p>The theoretical idea underlying this method is that the diffusion\npropagator <span class=\"math notranslate nohighlight\">\\(P(\\mathbf{r})\\)</span> (probability density function of the average\nspin displacements) can be estimated by applying 3D FFT to the signal\nvalues <span class=\"math notranslate nohighlight\">\\(S(\\mathbf{q})\\)</span></p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{eqnarray}</dt><dd><p>P(mathbf{r}) &amp; = &amp; S_{0}^{-1}int S(mathbf{q})exp(-i2pimathbf{q}cdotmathbf{r})dmathbf{r}</p>\n</dd>\n</dl>\n<p>end{eqnarray}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\mathbf{r}\\)</span> is the displacement vector and <span class=\"math notranslate nohighlight\">\\(\\mathbf{q}\\)</span> is the\nwave vector which corresponds to different gradient directions. Method\nused to calculate the ODFs. Here we implement the method proposed by\nWedeen et al. <a class=\"reference internal\" href=\"#rb4175f35d86a-1\" id=\"id378\">[1]</a>.</p>\n<p>The main assumption for this model is fast gradient switching and that\nthe acquisition gradients will sit on a keyhole Cartesian grid in\nq_space <a class=\"reference internal\" href=\"#rb4175f35d86a-3\" id=\"id379\">[3]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>Gradient directions and bvalues container class</p>\n</dd>\n<dt><strong>qgrid_size</strong><span class=\"classifier\">int,</span></dt><dd><p>has to be an odd number. Sets the size of the q_space grid.\nFor example if qgrid_size is 17 then the shape of the grid will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(17,</span> <span class=\"pre\">17,</span> <span class=\"pre\">17)</span></code>.</p>\n</dd>\n<dt><strong>r_start</strong><span class=\"classifier\">float,</span></dt><dd><p>ODF is sampled radially in the PDF. This parameters shows where the\nsampling should start.</p>\n</dd>\n<dt><strong>r_end</strong><span class=\"classifier\">float,</span></dt><dd><p>Radial endpoint of ODF sampling</p>\n</dd>\n<dt><strong>r_step</strong><span class=\"classifier\">float,</span></dt><dd><p>Step size of the ODf sampling from r_start to r_end</p>\n</dd>\n<dt><strong>filter_width</strong><span class=\"classifier\">float,</span></dt><dd><p>Strength of the hanning filter</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dipy.reconst.gqi.GeneralizedQSampling</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>A. Have in mind that DSI expects gradients on both hemispheres. If your\ngradients span only one hemisphere you need to duplicate the data and\nproject them to the other hemisphere before calling this class. The\nfunction dipy.reconst.dsi.half_to_full_qspace can be used for this\npurpose.</p>\n<p>B. If you increase the size of the grid (parameter qgrid_size) you will\nmost likely also need to update the r_* parameters. This is because\nthe added zero padding from the increase of gqrid_size also introduces\na scaling of the PDF.</p>\n<ol class=\"upperalpha simple\" start=\"3\">\n<li><p>We assume that data only one b0 volume is provided.</p></li>\n</ol>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb4175f35d86a-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id378\">1</a></span></dt>\n<dd><p>Wedeen V.J et al., \u201cMapping Complex Tissue Architecture With</p>\n</dd>\n</dl>\n<p>Diffusion Spectrum Magnetic Resonance Imaging\u201d, MRM 2005.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb4175f35d86a-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Canales-Rodriguez E.J et al., \u201cDeconvolution in Diffusion</p>\n</dd>\n</dl>\n<p>Spectrum Imaging\u201d, Neuroimage, 2010.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb4175f35d86a-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id379\">3</a></span></dt>\n<dd><p>Garyfallidis E, \u201cTowards an accurate brain tractography\u201d, PhD</p>\n</dd>\n</dl>\n<p>thesis, University of Cambridge, 2012.</p>\n<p class=\"rubric\">Examples</p>\n<p>In this example where we provide the data, a gradient table\nand a reconstruction sphere, we calculate generalized FA for the first\nvoxel in the data with the reconstruction performed using DSI.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">warnings</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">dsi_voxels</span><span class=\"p\">,</span> <span class=\"n\">default_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">dsi_voxels</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.dsi</span> <span class=\"k\">import</span> <span class=\"n\">DiffusionSpectrumModel</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">DiffusionSpectrumModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dsfit</span> <span class=\"o\">=</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.odf</span> <span class=\"k\">import</span> <span class=\"n\">gfa</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">gfa</span><span class=\"p\">(</span><span class=\"n\">dsfit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"p\">))[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"go\">0.11</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.DiffusionSpectrumModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"odffit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfFit\" title=\"dipy.reconst.dsi.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a><a class=\"headerlink\" href=\"#odffit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.OdfFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">OdfFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfFit.odf\" title=\"dipy.reconst.dsi.OdfFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>To be implemented but specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.OdfFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.OdfFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented but specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"odfmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfModel\" title=\"dipy.reconst.dsi.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a><a class=\"headerlink\" href=\"#odfmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dsi.OdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">OdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>An abstract class to be sub-classed by specific odf models</p>\n<p>All odf models should provide a fit method which may take data as it\u2019s\nfirst and only argument.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dsi.OdfModel.fit\" title=\"dipy.reconst.dsi.OdfModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.OdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dsi.OdfModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.OdfModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented by specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lr-deconv\">\n<h3>LR_deconv<a class=\"headerlink\" href=\"#lr-deconv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.LR_deconv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">LR_deconv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">prop</em>, <em class=\"sig-param\">psf</em>, <em class=\"sig-param\">numit=5</em>, <em class=\"sig-param\">acc_factor=1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.LR_deconv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Perform Lucy-Richardson deconvolution algorithm on a 3D array.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>prop</strong><span class=\"classifier\">3-D ndarray of dtype float</span></dt><dd><p>The 3D volume to be deconvolve</p>\n</dd>\n<dt><strong>psf</strong><span class=\"classifier\">3-D ndarray of dtype float</span></dt><dd><p>The filter that will be used for the deconvolution.</p>\n</dd>\n<dt><strong>numit</strong><span class=\"classifier\">int</span></dt><dd><p>Number of Lucy-Richardson iteration to perform.</p>\n</dd>\n<dt><strong>acc_factor</strong><span class=\"classifier\">float</span></dt><dd><p>Exponential acceleration factor as in <a class=\"reference internal\" href=\"#rc26f028c341d-1\" id=\"id383\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc26f028c341d-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id383\">1</a></span></dt>\n<dd><p>Biggs David S.C. et al., \u201cAcceleration of Iterative Image\nRestoration Algorithms\u201d, Applied Optics, vol. 36, No. 8, p. 1766-1775,\n1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"create-qspace\">\n<h3>create_qspace<a class=\"headerlink\" href=\"#create-qspace\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.create_qspace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">create_qspace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">origin</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.create_qspace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>create the 3D grid which holds the signal values (q-space)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>origin</strong><span class=\"classifier\">(3,) ndarray</span></dt><dd><p>center of qspace</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>qgrid</strong><span class=\"classifier\">ndarray</span></dt><dd><p>qspace coordinates</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"create-qtable\">\n<h3>create_qtable<a class=\"headerlink\" href=\"#create-qtable\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.create_qtable\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">create_qtable</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">origin</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.create_qtable\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>create a normalized version of gradients</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>origin</strong><span class=\"classifier\">(3,) ndarray</span></dt><dd><p>center of qspace</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>qtable</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fftn\">\n<h3>fftn<a class=\"headerlink\" href=\"#fftn\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.fftn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">fftn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">shape=None</em>, <em class=\"sig-param\">axes=None</em>, <em class=\"sig-param\">overwrite_x=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.fftn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return multidimensional discrete Fourier transform.</p>\n<p>The returned array contains:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">j_1</span><span class=\"p\">,</span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"n\">j_d</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">[</span><span class=\"n\">k_1</span><span class=\"o\">=</span><span class=\"mf\">0.</span><span class=\"o\">.</span><span class=\"n\">n_1</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">k_d</span><span class=\"o\">=</span><span class=\"mf\">0.</span><span class=\"o\">.</span><span class=\"n\">n_d</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n   <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">k_1</span><span class=\"p\">,</span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"n\">k_d</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">prod</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mf\">1.</span><span class=\"o\">.</span><span class=\"n\">d</span><span class=\"p\">]</span> <span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"n\">n_i</span> <span class=\"o\">*</span> <span class=\"n\">j_i</span> <span class=\"o\">*</span> <span class=\"n\">k_i</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>where d = len(x.shape) and n = x.shape.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>The (N-D) array to transform.</p>\n</dd>\n<dt><strong>shape</strong><span class=\"classifier\">int or array_like of ints or None, optional</span></dt><dd><p>The shape of the result. If both <cite>shape</cite> and <cite>axes</cite> (see below) are\nNone, <cite>shape</cite> is <code class=\"docutils literal notranslate\"><span class=\"pre\">x.shape</span></code>; if <cite>shape</cite> is None but <cite>axes</cite> is\nnot None, then <cite>shape</cite> is <code class=\"docutils literal notranslate\"><span class=\"pre\">scipy.take(x.shape,</span> <span class=\"pre\">axes,</span> <span class=\"pre\">axis=0)</span></code>.\nIf <code class=\"docutils literal notranslate\"><span class=\"pre\">shape[i]</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">x.shape[i]</span></code>, the ith dimension is padded with zeros.\nIf <code class=\"docutils literal notranslate\"><span class=\"pre\">shape[i]</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">x.shape[i]</span></code>, the ith dimension is truncated to\nlength <code class=\"docutils literal notranslate\"><span class=\"pre\">shape[i]</span></code>.\nIf any element of <cite>shape</cite> is -1, the size of the corresponding\ndimension of <cite>x</cite> is used.</p>\n</dd>\n<dt><strong>axes</strong><span class=\"classifier\">int or array_like of ints or None, optional</span></dt><dd><p>The axes of <cite>x</cite> (<cite>y</cite> if <cite>shape</cite> is not None) along which the\ntransform is applied.\nThe default is over all axes.</p>\n</dd>\n<dt><strong>overwrite_x</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, the contents of <cite>x</cite> can be destroyed. Default is False.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y</strong><span class=\"classifier\">complex-valued N-D NumPy array</span></dt><dd><p>The (N-D) DFT of the input array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ifftn</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> is real-valued, then\n<code class=\"docutils literal notranslate\"><span class=\"pre\">y[...,</span> <span class=\"pre\">j_i,</span> <span class=\"pre\">...]</span> <span class=\"pre\">==</span> <span class=\"pre\">y[...,</span> <span class=\"pre\">n_i-j_i,</span> <span class=\"pre\">...].conjugate()</span></code>.</p>\n<p>Both single and double precision routines are implemented. Half precision\ninputs will be converted to single precision. Non-floating-point inputs\nwill be converted to double precision. Long-double precision inputs are\nnot supported.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.fftpack</span> <span class=\"k\">import</span> <span class=\"n\">fftn</span><span class=\"p\">,</span> <span class=\"n\">ifftn</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"mi\">8</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">fftn</span><span class=\"p\">(</span><span class=\"n\">ifftn</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)))</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fftshift\">\n<h3>fftshift<a class=\"headerlink\" href=\"#fftshift\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.fftshift\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">fftshift</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">axes=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.fftshift\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Shift the zero-frequency component to the center of the spectrum.</p>\n<p>This function swaps half-spaces for all axes listed (defaults to all).\nNote that <code class=\"docutils literal notranslate\"><span class=\"pre\">y[0]</span></code> is the Nyquist component only if <code class=\"docutils literal notranslate\"><span class=\"pre\">len(x)</span></code> is even.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>Input array.</p>\n</dd>\n<dt><strong>axes</strong><span class=\"classifier\">int or shape tuple, optional</span></dt><dd><p>Axes over which to shift.  Default is None, which shifts all axes.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The shifted array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dsi.ifftshift\" title=\"dipy.reconst.dsi.ifftshift\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ifftshift</span></code></a></dt><dd><p>The inverse of <cite>fftshift</cite>.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftfreq</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span>\n<span class=\"go\">array([ 0.,  1.,  2., ..., -3., -2., -1.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftshift</span><span class=\"p\">(</span><span class=\"n\">freqs</span><span class=\"p\">)</span>\n<span class=\"go\">array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])</span>\n</pre></div>\n</div>\n<p>Shift the zero-frequency component only along the second axis:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftfreq</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">1.</span><span class=\"o\">/</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span>\n<span class=\"go\">array([[ 0.,  1.,  2.],</span>\n<span class=\"go\">       [ 3.,  4., -4.],</span>\n<span class=\"go\">       [-3., -2., -1.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftshift</span><span class=\"p\">(</span><span class=\"n\">freqs</span><span class=\"p\">,</span> <span class=\"n\">axes</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,))</span>\n<span class=\"go\">array([[ 2.,  0.,  1.],</span>\n<span class=\"go\">       [-4.,  3.,  4.],</span>\n<span class=\"go\">       [-1., -3., -2.]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gen-psf\">\n<h3>gen_PSF<a class=\"headerlink\" href=\"#gen-psf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.gen_PSF\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">gen_PSF</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">qgrid_sampling</em>, <em class=\"sig-param\">siz_x</em>, <em class=\"sig-param\">siz_y</em>, <em class=\"sig-param\">siz_z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.gen_PSF\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generate a PSF for DSI Deconvolution by taking the ifft of the binary\nq-space sampling mask and truncating it to keep only the center.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"half-to-full-qspace\">\n<h3>half_to_full_qspace<a class=\"headerlink\" href=\"#half-to-full-qspace\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.half_to_full_qspace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">half_to_full_qspace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.half_to_full_qspace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Half to full Cartesian grid mapping</p>\n<p>Useful when dMRI data are provided in one qspace hemisphere as\nDiffusionSpectrum expects data to be in full qspace.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array, shape (X, Y, Z, W)</span></dt><dd><p>where (X, Y, Z) volume size and W number of gradient directions</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>container for b-values and b-vectors (gradient directions)</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>new_data</strong><span class=\"classifier\">array, shape (X, Y, Z, 2 * W -1)</span></dt><dd></dd>\n<dt><strong>new_gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>We assume here that only on b0 is provided with the initial data. If that\nis not the case then you will need to write your own preparation function\nbefore providing the gradients and the data to the DiffusionSpectrumModel\nclass.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"hanning-filter\">\n<h3>hanning_filter<a class=\"headerlink\" href=\"#hanning-filter\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.hanning_filter\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">hanning_filter</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">filter_width</em>, <em class=\"sig-param\">origin</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.hanning_filter\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>create a hanning window</p>\n<p>The signal is premultiplied by a Hanning window before\nFourier transform in order to ensure a smooth attenuation\nof the signal at high q values.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>filter_width</strong><span class=\"classifier\">int</span></dt><dd></dd>\n<dt><strong>origin</strong><span class=\"classifier\">(3,) ndarray</span></dt><dd><p>center of qspace</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>filter</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>where N is the number of non-b0 gradient directions</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ifftshift\">\n<h3>ifftshift<a class=\"headerlink\" href=\"#ifftshift\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.ifftshift\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">ifftshift</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">axes=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.ifftshift\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The inverse of <cite>fftshift</cite>. Although identical for even-length <cite>x</cite>, the\nfunctions differ by one sample for odd-length <cite>x</cite>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>Input array.</p>\n</dd>\n<dt><strong>axes</strong><span class=\"classifier\">int or shape tuple, optional</span></dt><dd><p>Axes over which to calculate.  Defaults to None, which shifts all axes.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The shifted array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dsi.fftshift\" title=\"dipy.reconst.dsi.fftshift\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fftshift</span></code></a></dt><dd><p>Shift zero-frequency component to the center of the spectrum.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftfreq</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">1.</span><span class=\"o\">/</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">freqs</span>\n<span class=\"go\">array([[ 0.,  1.,  2.],</span>\n<span class=\"go\">       [ 3.,  4., -4.],</span>\n<span class=\"go\">       [-3., -2., -1.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">ifftshift</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"o\">.</span><span class=\"n\">fftshift</span><span class=\"p\">(</span><span class=\"n\">freqs</span><span class=\"p\">))</span>\n<span class=\"go\">array([[ 0.,  1.,  2.],</span>\n<span class=\"go\">       [ 3.,  4., -4.],</span>\n<span class=\"go\">       [-3., -2., -1.]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"map-coordinates\">\n<h3>map_coordinates<a class=\"headerlink\" href=\"#map-coordinates\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.map_coordinates\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">map_coordinates</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">input</em>, <em class=\"sig-param\">coordinates</em>, <em class=\"sig-param\">output=None</em>, <em class=\"sig-param\">order=3</em>, <em class=\"sig-param\">mode='constant'</em>, <em class=\"sig-param\">cval=0.0</em>, <em class=\"sig-param\">prefilter=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.map_coordinates\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Map the input array to new coordinates by interpolation.</p>\n<p>The array of coordinates is used to find, for each point in the output,\nthe corresponding coordinates in the input. The value of the input at\nthose coordinates is determined by spline interpolation of the\nrequested order.</p>\n<p>The shape of the output is derived from that of the coordinate\narray by dropping the first axis. The values of the array along\nthe first axis are the coordinates in the input array at which the\noutput value is found.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>input</strong><span class=\"classifier\">array_like</span></dt><dd><p>The input array.</p>\n</dd>\n<dt><strong>coordinates</strong><span class=\"classifier\">array_like</span></dt><dd><p>The coordinates at which <cite>input</cite> is evaluated.</p>\n</dd>\n<dt><strong>output</strong><span class=\"classifier\">array or dtype, optional</span></dt><dd><p>The array in which to place the output, or the dtype of the\nreturned array. By default an array of the same dtype as input\nwill be created.</p>\n</dd>\n<dt><strong>order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 3.\nThe order has to be in the range 0-5.</p>\n</dd>\n<dt><strong>mode</strong><span class=\"classifier\">{\u2018reflect\u2019, \u2018constant\u2019, \u2018nearest\u2019, \u2018mirror\u2019, \u2018wrap\u2019}, optional</span></dt><dd><p>The <cite>mode</cite> parameter determines how the input array is extended\nbeyond its boundaries. Default is \u2018constant\u2019. Behavior for each valid\nvalue is as follows:</p>\n<dl class=\"simple\">\n<dt>\u2018reflect\u2019 (<cite>d c b a | a b c d | d c b a</cite>)</dt><dd><p>The input is extended by reflecting about the edge of the last\npixel.</p>\n</dd>\n<dt>\u2018constant\u2019 (<cite>k k k k | a b c d | k k k k</cite>)</dt><dd><p>The input is extended by filling all values beyond the edge with\nthe same constant value, defined by the <cite>cval</cite> parameter.</p>\n</dd>\n<dt>\u2018nearest\u2019 (<cite>a a a a | a b c d | d d d d</cite>)</dt><dd><p>The input is extended by replicating the last pixel.</p>\n</dd>\n<dt>\u2018mirror\u2019 (<cite>d c b | a b c d | c b a</cite>)</dt><dd><p>The input is extended by reflecting about the center of the last\npixel.</p>\n</dd>\n<dt>\u2018wrap\u2019 (<cite>a b c d | a b c d | a b c d</cite>)</dt><dd><p>The input is extended by wrapping around to the opposite edge.</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>cval</strong><span class=\"classifier\">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is \u2018constant\u2019. Default\nis 0.0.</p>\n</dd>\n<dt><strong>prefilter</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Determines if the input array is prefiltered with <cite>spline_filter</cite>\nbefore interpolation. The default is True, which will create a\ntemporary <cite>float64</cite> array of filtered values if <cite>order &gt; 1</cite>. If\nsetting this to False, the output will be slightly blurred if\n<cite>order &gt; 1</cite>, unless the input is prefiltered, i.e. it is the result\nof calling <cite>spline_filter</cite> on the original input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>map_coordinates</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The result of transforming the input. The shape of the output is\nderived from that of <cite>coordinates</cite> by dropping the first axis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">spline_filter</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">geometric_transform</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.interpolate</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy</span> <span class=\"k\">import</span> <span class=\"n\">ndimage</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mf\">12.</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span>\n<span class=\"go\">array([[  0.,   1.,   2.],</span>\n<span class=\"go\">       [  3.,   4.,   5.],</span>\n<span class=\"go\">       [  6.,   7.,   8.],</span>\n<span class=\"go\">       [  9.,  10.,  11.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"p\">[[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]],</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 2.,  7.])</span>\n</pre></div>\n</div>\n<p>Above, the interpolated value of a[0.5, 0.5] gives output[0], while\na[2, 1] is output[1].</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">inds</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=-</span><span class=\"mf\">33.3</span><span class=\"p\">)</span>\n<span class=\"go\">array([  2. , -33.3])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 2.,  8.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">map_coordinates</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">inds</span><span class=\"p\">,</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">cval</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"nb\">bool</span><span class=\"p\">)</span>\n<span class=\"go\">array([ True, False], dtype=bool)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id385\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id385\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"pdf-interp-coords\">\n<h3>pdf_interp_coords<a class=\"headerlink\" href=\"#pdf-interp-coords\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.pdf_interp_coords\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">pdf_interp_coords</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">rradius</em>, <em class=\"sig-param\">origin</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.pdf_interp_coords\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Precompute coordinates for ODF calculation from the PDF</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">object,</span></dt><dd><p>Sphere</p>\n</dd>\n<dt><strong>rradius</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>line interpolation points</p>\n</dd>\n<dt><strong>origin</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>center of the grid</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"pdf-odf\">\n<h3>pdf_odf<a class=\"headerlink\" href=\"#pdf-odf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.pdf_odf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">pdf_odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">Pr</em>, <em class=\"sig-param\">rradius</em>, <em class=\"sig-param\">interp_coords</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.pdf_odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the real ODF from the diffusion propagator(PDF) Pr</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>Pr</strong><span class=\"classifier\">array, shape (X, X, X)</span></dt><dd><p>probability density function</p>\n</dd>\n<dt><strong>rradius</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>interpolation range on the radius</p>\n</dd>\n<dt><strong>interp_coords</strong><span class=\"classifier\">array, shape (3, M, N)</span></dt><dd><p>coordinates in the pdf for interpolating the odf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"project-hemisph-bvecs\">\n<h3>project_hemisph_bvecs<a class=\"headerlink\" href=\"#project-hemisph-bvecs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.project_hemisph_bvecs\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">project_hemisph_bvecs</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.project_hemisph_bvecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Project any near identical bvecs to the other hemisphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">object,</span></dt><dd><p>GradientTable</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Useful only when working with some types of dsi data.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"threshold-propagator\">\n<h3>threshold_propagator<a class=\"headerlink\" href=\"#threshold-propagator\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dsi.threshold_propagator\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dsi.</code><code class=\"sig-name descname\">threshold_propagator</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">P</em>, <em class=\"sig-param\">estimated_snr=15.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dsi.threshold_propagator\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies hard threshold on the propagator to remove background noise for the\ndeconvolution.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id386\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dti.ReconstModel\" title=\"dipy.reconst.dti.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id386\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dti.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id387\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit\" title=\"dipy.reconst.dti.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a><a class=\"headerlink\" href=\"#id387\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dti.TensorFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">TensorFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.directions\" title=\"dipy.reconst.dti.TensorFit.directions\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></a></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.evals\" title=\"dipy.reconst.dti.TensorFit.evals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></a></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.evecs\" title=\"dipy.reconst.dti.TensorFit.evecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></a></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.quadratic_form\" title=\"dipy.reconst.dti.TensorFit.quadratic_form\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></a></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.ad\" title=\"dipy.reconst.dti.TensorFit.ad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code></a>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.adc\" title=\"dipy.reconst.dti.TensorFit.adc\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code></a>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.color_fa\" title=\"dipy.reconst.dti.TensorFit.color_fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code></a>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.fa\" title=\"dipy.reconst.dti.TensorFit.fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code></a>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.ga\" title=\"dipy.reconst.dti.TensorFit.ga\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code></a>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.linearity\" title=\"dipy.reconst.dti.TensorFit.linearity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.md\" title=\"dipy.reconst.dti.TensorFit.md\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code></a>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.mode\" title=\"dipy.reconst.dti.TensorFit.mode\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code></a>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.odf\" title=\"dipy.reconst.dti.TensorFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.planarity\" title=\"dipy.reconst.dti.TensorFit.planarity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.predict\" title=\"dipy.reconst.dti.TensorFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0,\u00a0step])</p></td>\n<td><p>Given a model fit, predict the signal on the vertices of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.rd\" title=\"dipy.reconst.dti.TensorFit.rd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code></a>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.sphericity\" title=\"dipy.reconst.dti.TensorFit.sphericity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit.trace\" title=\"dipy.reconst.dti.TensorFit.trace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code></a>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a TensorFit class instance.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.S0_hat\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">S0_hat</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.S0_hat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.ad\">\n<code class=\"sig-name descname\">ad</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.ad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ad</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated AD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AD = \\lambda_1\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.adc\">\n<code class=\"sig-name descname\">adc</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.adc\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><blockquote>\n<div><p>Calculate the apparent diffusion coefficient (ADC) in each direction on\nthe sphere for each voxel in the data</p>\n</div></blockquote>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adc</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The estimates of the apparent diffusion coefficient in every\ndirection on the input sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>ec{b} Q \nec{b}^T</p>\n<blockquote>\n<div><p>Where Q is the quadratic form of the tensor.</p>\n</div></blockquote>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.color_fa\">\n<code class=\"sig-name descname\">color_fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.color_fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Color fractional anisotropy of diffusion tensor</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.directions\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">directions</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.directions\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>For tracking - return the primary direction in each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.evals\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evals</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.evals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.evecs\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evecs</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.evecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.fa\">\n<code class=\"sig-name descname\">fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.ga\">\n<code class=\"sig-name descname\">ga</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.ga\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.linearity\">\n<code class=\"sig-name descname\">linearity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.linearity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>linearity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated linearity of the diffusion tensor <a class=\"reference internal\" href=\"#r8c505d95d8a9-1\" id=\"id388\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Linearity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Linearity =\n\\frac{\\lambda_1-\\lambda_2}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8c505d95d8a9-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id388\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.lower_triangular\">\n<code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.md\">\n<code class=\"sig-name descname\">md</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.md\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1+\\lambda_2+\\lambda_3}{3}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.mode\">\n<code class=\"sig-name descname\">mode</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.mode\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Tensor mode calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The diffusion orientation distribution function (dODF). This is an\nestimate of the diffusion distance in each direction</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance.</span></dt><dd><p>The dODF is calculated in the vertices of this input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The diffusion distance in every direction of the sphere in every\nvoxel in the input data.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This is based on equation 3 in <a class=\"reference internal\" href=\"#r0c640848df6f-1\" id=\"id390\">[1]</a>. To re-derive it from\nscratch, follow steps in <a class=\"reference internal\" href=\"#r0c640848df6f-2\" id=\"id391\">[2]</a>, Section 7.9 Equation\n7.24 but with an <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the integral.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0c640848df6f-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id390\">1</a></span></dt>\n<dd><p>Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,\nK., &amp; Harel, N. (2010). Reconstruction of the orientation\ndistribution function in single- and multiple-shell q-ball imaging\nwithin constant solid angle. Magnetic Resonance in Medicine, 64(2),\n554-566. doi:DOI: 10.1002/mrm.22365</p>\n</dd>\n<dt class=\"label\" id=\"r0c640848df6f-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id391\">2</a></span></dt>\n<dd><p>Descoteaux, M. (2008). PhD Thesis: High Angular\nResolution Diffusion MRI: from Local Estimation to Segmentation and\nTractography.\n<a class=\"reference external\" href=\"ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf\">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.planarity\">\n<code class=\"sig-name descname\">planarity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.planarity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#rede33b18dc5f-1\" id=\"id394\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity =\n\\frac{2 (\\lambda_2 - \\lambda_3)}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rede33b18dc5f-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id394\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=None</em>, <em class=\"sig-param\">step=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:\nThe fitted S0 value in all voxels if it was fitted. Otherwise 1 in\nall voxels.</p>\n</dd>\n<dt><strong>step</strong><span class=\"classifier\">int</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with\ndefault value 10,000.</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. This parameter sets the number of\nvoxels that will be fit at once in each iteration. A larger step\nvalue should speed things up, but it will also take up more memory.\nIt is advisable to keep an eye on memory consumption as this value\nis increased.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[S(  heta, b) = S_0 * e^{-b ADC}\\]</div>\n<p>Where:\n.. math</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">ADC</span> <span class=\"o\">=</span>       <span class=\"n\">heta</span> <span class=\"n\">Q</span>  <span class=\"n\">heta</span><span class=\"o\">^</span><span class=\"n\">T</span>\n</pre></div>\n</div>\n<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for\nwhich a signal is to be predicted and <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b value provided in\nthe GradientTable input for that direction</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.quadratic_form\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">quadratic_form</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.quadratic_form\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.rd\">\n<code class=\"sig-name descname\">rd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.rd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>rd</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated RD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[RD = \\frac{\\lambda_2 + \\lambda_3}{2}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.sphericity\">\n<code class=\"sig-name descname\">sphericity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.sphericity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#r467f8a1ecdae-1\" id=\"id396\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity = \\frac{3 \\lambda_3}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r467f8a1ecdae-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id396\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorFit.trace\">\n<code class=\"sig-name descname\">trace</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorFit.trace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>trace</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated trace.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The trace is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[trace = \\lambda_1 + \\lambda_2 + \\lambda_3\\]</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id398\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorModel\" title=\"dipy.reconst.dti.TensorModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a><a class=\"headerlink\" href=\"#id398\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.dti.TensorModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">TensorModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Diffusion Tensor</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorModel.fit\" title=\"dipy.reconst.dti.TensorModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the DTI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorModel.predict\" title=\"dipy.reconst.dti.TensorModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(dti_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A Diffusion Tensor Model <a class=\"reference internal\" href=\"#r9aa998fac9a2-1\" id=\"id399\">[1]</a>, <a class=\"reference internal\" href=\"#r9aa998fac9a2-2\" id=\"id400\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:</p>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 for weighted least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.wls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018LS\u2019 or \u2018OLS\u2019 for ordinary least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.ols_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018NLLS\u2019 for non-linear least-squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.nlls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018RT\u2019 or \u2018restore\u2019 or \u2018RESTORE\u2019 for RESTORE robust tensor</dt><dd><p>fitting <a class=\"reference internal\" href=\"#r9aa998fac9a2-3\" id=\"id401\">[3]</a>\n<code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.restore_fit_tensor()</span></code></p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id402\"><span class=\"problematic\" id=\"id403\">*</span></a>args, <a href=\"#id404\"><span class=\"problematic\" id=\"id405\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: minimal signal in the data provided to <cite>fit</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. Many fit_methods use the \u2018step\u2019\nparameter to set the number of voxels that will be fit at once in each\niteration. This is the chunk size as a number of voxels. A larger step\nvalue should speed things up, but it will also take up more memory. It\nis advisable to keep an eye on memory consumption as this value is\nincreased.</p>\n<p>E.g., in <a class=\"reference internal\" href=\"#dipy.reconst.dti.iter_fit_tensor\" title=\"dipy.reconst.dti.iter_fit_tensor\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter_fit_tensor()</span></code></a> we have a default step value of\n1e4</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9aa998fac9a2-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id399\">1</a></span></dt>\n<dd><p>Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of\nthe effective self-diffusion tensor from the NMR spin echo. J Magn\nReson B 103, 247-254.</p>\n</dd>\n<dt class=\"label\" id=\"r9aa998fac9a2-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id400\">2</a></span></dt>\n<dd><p>Basser, P., Pierpaoli, C., 1996. Microstructural and\nphysiological features of tissues elucidated by quantitative\ndiffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</p>\n</dd>\n<dt class=\"label\" id=\"r9aa998fac9a2-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id401\">3</a></span></dt>\n<dd><p>Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust\nestimation of tensors by outlier rejection. MRM 53: 1088-1095</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the DTI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal from one voxel.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.dti.TensorModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dti_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.TensorModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dti_params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The last dimension should have 12 tensor parameters: 3\neigenvalues, followed by the 3 eigenvectors</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"apparent-diffusion-coef\">\n<h3>apparent_diffusion_coef<a class=\"headerlink\" href=\"#apparent-diffusion-coef\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.apparent_diffusion_coef\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">apparent_diffusion_coef</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em>, <em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.apparent_diffusion_coef\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the apparent diffusion coefficient (ADC) in each direction of a\nsphere.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (\u2026, 3, 3)</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">a Sphere class instance</span></dt><dd><p>The ADC will be calculated for each of the vertices in the sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The calculation of ADC, relies on the following relationship:</p>\n<div class=\"math notranslate nohighlight\">\n\\[ADC = \\vec{b} Q \\vec{b}^T\\]</div>\n<p>Where Q is the quadratic form of the tensor.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id409\">\n<h3>auto_attr<a class=\"headerlink\" href=\"#id409\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.auto_attr\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">auto_attr</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.auto_attr\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Decorator to create OneTimeProperty attributes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">method</span></dt><dd><p>The method that will be called the first time to compute a value.\nAfterwards, the method\u2019s name will be a standard attribute holding the\nvalue of this computation.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">MagicProp</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nd\">@auto_attr</span>\n<span class=\"gp\">... </span>    <span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>        <span class=\"k\">return</span> <span class=\"mi\">99</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">MagicProp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"go\">99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id410\">\n<h3>axial_diffusivity<a class=\"headerlink\" href=\"#id410\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.axial_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">axial_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.axial_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial Diffusivity (AD) of a diffusion tensor.\nAlso called parallel diffusivity.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order\nalong <cite>axis</cite>.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ad</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated AD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>AD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AD = \\lambda_1\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"color-fa\">\n<h3>color_fa<a class=\"headerlink\" href=\"#color-fa\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.color_fa\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">color_fa</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fa</em>, <em class=\"sig-param\">evecs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.color_fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Color fractional anisotropy of diffusion tensor</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fa</strong><span class=\"classifier\">array-like</span></dt><dd><p>Array of the fractional anisotropy (can be 1D, 2D or 3D)</p>\n</dd>\n<dt><strong>evecs</strong><span class=\"classifier\">array-like</span></dt><dd><p>eigen vectors from the tensor model</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rgb</strong><span class=\"classifier\">Array with 3 channels for each color as the last dimension.</span></dt><dd><p>Colormap of the FA with red for the x value, y for the green\nvalue and z for the blue value.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>It is computed from the clipped FA between 0 and 1 using the following\nformula</p>\n<div class=\"math notranslate nohighlight\">\n\\[rgb = abs(max(\\vec{e})) \\times fa\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id411\">\n<h3>decompose_tensor<a class=\"headerlink\" href=\"#id411\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.decompose_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">decompose_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.decompose_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>\n<p>Computes tensor eigen decomposition to calculate eigenvalues and\neigenvectors (Basser et al., 1994a).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,\nmuch smaller than the diffusion weighting, cause quite a lot of noise\nin metrics such as fa, diffusivity values smaller than\n<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative\neigenvalues are replaced by zero. Sorted from largest to smallest.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[\u2026, :, j] is associated with\neigvals[\u2026, j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id412\">\n<h3>design_matrix<a class=\"headerlink\" href=\"#id412\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for DTI weighted least squares or\nleast squares fitting. (Basser et al., 1994a)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">A GradientTable class instance</span></dt><dd></dd>\n<dt><strong>dtype</strong><span class=\"classifier\">string</span></dt><dd><p>Parameter to control the dtype of returned designed matrix</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model\ndesign_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"determinant\">\n<h3>determinant<a class=\"headerlink\" href=\"#determinant\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.determinant\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">determinant</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.determinant\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The determinant of a tensor, given in quadratic form</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>det</strong><span class=\"classifier\">array</span></dt><dd><p>The determinant of the tensor in each spatial coordinate</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"deviatoric\">\n<h3>deviatoric<a class=\"headerlink\" href=\"#deviatoric\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.deviatoric\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">deviatoric</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.deviatoric\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the deviatoric (anisotropic) part of the tensor <a class=\"reference internal\" href=\"#rfe2215338679-1\" id=\"id413\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>A_squiggle</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The deviatoric part of the tensor in each spatial coordinate.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The deviatoric part of the tensor is defined as (equations 3-5 in <a class=\"reference internal\" href=\"#rfe2215338679-1\" id=\"id414\">[1]</a>):</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\widetilde{A} = A - \\bar{A}\\]</div>\n<p>Where <span class=\"math notranslate nohighlight\">\\(A\\)</span> is the tensor quadratic form and <span class=\"math notranslate nohighlight\">\\(\\bar{A}\\)</span> is the anisotropic\npart of the tensor.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rfe2215338679-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id22\">1</a>,<a href=\"#id413\">2</a>,<a href=\"#id414\">3</a>)</span></dt>\n<dd><p>Daniel B. Ennis and G. Kindlmann, \u201cOrthogonal Tensor\nInvariants and the Analysis of Diffusion Tensor Magnetic Resonance\nImages\u201d, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,\n2006.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"eig-from-lo-tri\">\n<h3>eig_from_lo_tri<a class=\"headerlink\" href=\"#eig-from-lo-tri\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.eig_from_lo_tri\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">eig_from_lo_tri</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.eig_from_lo_tri\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates tensor eigenvalues/eigenvectors from an array containing the\nlower diagonal form of the six unique tensor elements.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array_like (\u2026, 6)</span></dt><dd><p>diffusion tensors elements stored in lower triangular order</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float</span></dt><dd><p>See decompose_tensor()</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>dti_params</strong><span class=\"classifier\">array (\u2026, 12)</span></dt><dd><p>Eigen-values and eigen-vectors of the same array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id416\">\n<h3>fractional_anisotropy<a class=\"headerlink\" href=\"#id416\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.fractional_anisotropy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">fractional_anisotropy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.fractional_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fa</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>FA is calculated using the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[FA = \\sqrt{\\frac{1}{2}\\frac{(\\lambda_1-\\lambda_2)^2+(\\lambda_1-\n            \\lambda_3)^2+(\\lambda_2-\\lambda_3)^2}{\\lambda_1^2+\n            \\lambda_2^2+\\lambda_3^2}}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id417\">\n<h3>from_lower_triangular<a class=\"headerlink\" href=\"#id417\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.from_lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">from_lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.from_lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns a tensor given the six unique tensor elements</p>\n<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,\nDyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are\nignored.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">array_like, (\u2026, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">ndarray (\u2026, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"geodesic-anisotropy\">\n<h3>geodesic_anisotropy<a class=\"headerlink\" href=\"#geodesic-anisotropy\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.geodesic_anisotropy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">geodesic_anisotropy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.geodesic_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Geodesic anisotropy (GA) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ga</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated GA. In the range 0 to +infinity</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>GA is calculated using the following equation given in <a class=\"reference internal\" href=\"#r12155c045a58-1\" id=\"id418\">[1]</a>:</p>\n<div class=\"math notranslate nohighlight\">\n\\[GA = \\sqrt{\\sum_{i=1}^3\n\\log^2{\\left ( \\lambda_i/&lt;\\mathbf{D}&gt; \\right )}},\n\\quad \\textrm{where} \\quad &lt;\\mathbf{D}&gt; =\n(\\lambda_1\\lambda_2\\lambda_3)^{1/3}\\]</div>\n<p>Note that the notation, <span class=\"math notranslate nohighlight\">\\(&lt;D&gt;\\)</span>, is often used as the mean diffusivity (MD)\nof the diffusion tensor and can lead to confusions in the literature\n(see <a class=\"reference internal\" href=\"#r12155c045a58-1\" id=\"id419\">[1]</a> versus <a class=\"reference internal\" href=\"#r12155c045a58-2\" id=\"id420\">[2]</a> versus <a class=\"reference internal\" href=\"#r12155c045a58-3\" id=\"id421\">[3]</a> for example). Reference <a class=\"reference internal\" href=\"#r12155c045a58-2\" id=\"id422\">[2]</a> defines\ngeodesic anisotropy (GA) with <span class=\"math notranslate nohighlight\">\\(&lt;D&gt;\\)</span> as the MD in the denominator of the\nsum. This is wrong. The original paper <a class=\"reference internal\" href=\"#r12155c045a58-1\" id=\"id423\">[1]</a> defines GA with\n<span class=\"math notranslate nohighlight\">\\(&lt;D&gt; = det(D)^{1/3}\\)</span>, as the isotropic part of the distance. This might be\nan explanation for the confusion. The isotropic part of the diffusion\ntensor in Euclidean space is the MD whereas the isotropic part of the\ntensor in log-Euclidean space is <span class=\"math notranslate nohighlight\">\\(det(D)^{1/3}\\)</span>. The Appendix of <a class=\"reference internal\" href=\"#r12155c045a58-1\" id=\"id424\">[1]</a> and\nlog-Euclidean derivations from <a class=\"reference internal\" href=\"#r12155c045a58-3\" id=\"id425\">[3]</a> are clear on this. Hence, all that to\nsay that <span class=\"math notranslate nohighlight\">\\(&lt;D&gt; = det(D)^{1/3}\\)</span> here for the GA definition and not MD.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r12155c045a58-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id418\">1</a>,<a href=\"#id419\">2</a>,<a href=\"#id423\">3</a>,<a href=\"#id424\">4</a>)</span></dt>\n<dd><p>P. G. Batchelor, M. Moakher, D. Atkinson, F. Calamante,\nA. Connelly, \u201cA rigorous framework for diffusion tensor calculus\u201d,\nMagnetic Resonance in Medicine, vol. 53, pp. 221-225, 2005.</p>\n</dd>\n<dt class=\"label\" id=\"r12155c045a58-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id420\">1</a>,<a href=\"#id422\">2</a>)</span></dt>\n<dd><p>M. M. Correia, V. F. Newcombe, G.B. Williams.\n\u201cContrast-to-noise ratios for indices of anisotropy obtained from\ndiffusion MRI: a study with standard clinical b-values at 3T\u201d.\nNeuroImage, vol. 57, pp. 1103-1115, 2011.</p>\n</dd>\n<dt class=\"label\" id=\"r12155c045a58-3\"><span class=\"brackets\">3</span><span class=\"fn-backref\">(<a href=\"#id421\">1</a>,<a href=\"#id425\">2</a>)</span></dt>\n<dd><p>A. D. Lee, etal, P. M. Thompson.\n\u201cComparison of fractional and geodesic anisotropy in diffusion tensor\nimages of 90 monozygotic and dizygotic twins\u201d. 5th IEEE International\nSymposium on Biomedical Imaging (ISBI), pp. 943-946, May 2008.</p>\n</dd>\n<dt class=\"label\" id=\"r12155c045a58-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>V. Arsigny, P. Fillard, X. Pennec, N. Ayache.\n\u201cLog-Euclidean metrics for fast and simple calculus on diffusion\ntensors.\u201d Magnetic Resonance in Medecine, vol 56, pp. 411-421, 2006.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id430\">\n<h3>get_sphere<a class=\"headerlink\" href=\"#id430\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.get_sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">get_sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name='symmetric362'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.get_sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>provide triangulated spheres</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>which sphere - one of:\n* \u2018symmetric362\u2019\n* \u2018symmetric642\u2019\n* \u2018symmetric724\u2019\n* \u2018repulsion724\u2019\n* \u2018repulsion100\u2019\n* \u2018repulsion200\u2019</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">a dipy.core.sphere.Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">get_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;symmetric362&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"o\">.</span><span class=\"n\">faces</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">362</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">faces</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">720</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">verts</span><span class=\"p\">,</span> <span class=\"n\">faces</span> <span class=\"o\">=</span> <span class=\"n\">get_sphere</span><span class=\"p\">(</span><span class=\"s1\">&#39;not a sphere name&#39;</span><span class=\"p\">)</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">DataError</span>: <span class=\"n\">No sphere called &quot;not a sphere name&quot;</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gradient-table\">\n<h3>gradient_table<a class=\"headerlink\" href=\"#gradient-table\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.gradient_table\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">gradient_table</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bvecs=None</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">atol=0.01</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.gradient_table\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A general function for creating diffusion MR gradients.</p>\n<p>It reads, loads and prepares scanner parameters like the b-values and\nb-vectors so that they can be useful during the reconstruction process.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">can be any of the four options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</p></li>\n<li><p>a path for the file which contains an array like the above (1).</p></li>\n<li><p>an array of shape (N, 4) or (4, N). Then this parameter is\nconsidered to be a b-table which contains both bvals and bvecs. In\nthis case the next parameter is skipped.</p></li>\n<li><p>a path for the file which contains an array like the one at (3).</p></li>\n</ol>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">can be any of two options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>\n<li><p>a path for the file which contains an array like the previous.</p></li>\n</ol>\n</dd>\n<dt><strong>big_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse separation time in seconds (default None)</p>\n</dd>\n<dt><strong>small_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse duration time in seconds (default None)</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n<dt><strong>atol</strong><span class=\"classifier\">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>\n</dd>\n<dt><strong>btens</strong><span class=\"classifier\">can be any of three options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>a string specifying the shape of the encoding tensor for all volumes\nin data. Options: \u2018LTE\u2019, \u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to\nlinear, planar, spherical, and \u201ccigar-shaped\u201d tensor encoding.\nTensors are rotated so that linear and cigar tensors are aligned\nwith the corresponding gradient direction and the planar tensor\u2019s\nnormal is aligned with the corresponding gradient direction.\nMagnitude is scaled to match the b-value.</p></li>\n<li><p>an array of strings of shape (N,), (N, 1), or (1, N) specifying\nencoding tensor shape for each volume separately. N corresponds to\nthe number volumes in data. Options for elements in array: \u2018LTE\u2019,\n\u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to linear, planar, spherical, and\n\u201ccigar-shaped\u201d tensor encoding. Tensors are rotated so that linear\nand cigar tensors are aligned with the corresponding gradient\ndirection and the planar tensor\u2019s normal is aligned with the\ncorresponding gradient direction. Magnitude is scaled to match the\nb-value.</p></li>\n<li><p>an array of shape (N,3,3) specifying the b-tensor of each volume\nexactly. N corresponds to the number volumes in data. No rotation or\nscaling is performed.</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<ol class=\"arabic simple\">\n<li><p>Often b0s (b-values which correspond to images without diffusion\nweighting) have 0 values however in some cases the scanner cannot\nprovide b0s of an exact 0 value and it gives a bit higher values\ne.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>\n<li><p>We assume that the minimum number of b-values is 7.</p></li>\n<li><p>B-vectors should be unit vectors.</p></li>\n</ol>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sq2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"isotropic\">\n<h3>isotropic<a class=\"headerlink\" href=\"#isotropic\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.isotropic\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">isotropic</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.isotropic\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the isotropic part of the tensor <a class=\"reference internal\" href=\"#rd0568a744381-1\" id=\"id431\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>A_hat: ndarray</dt><dd><p>The isotropic part of the tensor in each spatial coordinate</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The isotropic part of a tensor is defined as (equations 3-5 of <a class=\"reference internal\" href=\"#rd0568a744381-1\" id=\"id432\">[1]</a>):</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\bar{A} = \\frac{1}{2} tr(A) I\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd0568a744381-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id23\">1</a>,<a href=\"#id431\">2</a>,<a href=\"#id432\">3</a>)</span></dt>\n<dd><p>Daniel B. Ennis and G. Kindlmann, \u201cOrthogonal Tensor\nInvariants and the Analysis of Diffusion Tensor Magnetic Resonance\nImages\u201d, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,\n2006.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"iter-fit-tensor\">\n<h3>iter_fit_tensor<a class=\"headerlink\" href=\"#iter-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.iter_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">iter_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">step=10000.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.iter_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Wrap a fit_tensor func and iterate over chunks of data with given length</p>\n<p>Splits data into a number of chunks of specified size and iterates the\ndecorated fit_tensor function over them. This is useful to counteract the\ntemporary but significant memory usage increase in fit_tensor functions\nthat use vectorized operations and need to store large temporary arrays for\ntheir vectorized operations.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>step</strong><span class=\"classifier\">int</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with default\nvalue 10,000.</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. This parameter sets the number of\nvoxels that will be fit at once in each iteration. A larger step value\nshould speed things up, but it will also take up more memory. It is\nadvisable to keep an eye on memory consumption as this value is\nincreased.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"linearity\">\n<h3>linearity<a class=\"headerlink\" href=\"#linearity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.linearity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">linearity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.linearity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The linearity of the tensor <a class=\"reference internal\" href=\"#r6fa152915e78-1\" id=\"id434\">[1]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>linearity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Linearity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Linearity = \\frac{\\lambda_1-\\lambda_2}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6fa152915e78-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id24\">1</a>,<a href=\"#id434\">2</a>)</span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,\n\u201cGeometrical diffusion measures for MRI from tensor basis analysis\u201d in\nProc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id436\">\n<h3>lower_triangular<a class=\"headerlink\" href=\"#id436\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the six lower triangular values of the tensor and a dummy variable\nif b0 is not None</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array_like (\u2026, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>\n</dd>\n<dt><strong>b0</strong><span class=\"classifier\">float</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (\u2026, 6) otherwise (\u2026, 7)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id437\">\n<h3>mean_diffusivity<a class=\"headerlink\" href=\"#id437\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.mean_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">mean_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.mean_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1 + \\lambda_2 + \\lambda_3}{3}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mode\">\n<h3>mode<a class=\"headerlink\" href=\"#mode\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.mode\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">mode</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.mode\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mode (MO) of a diffusion tensor <a class=\"reference internal\" href=\"#rae241588dfcd-1\" id=\"id438\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (x, y, z, 3, 3) or (n, 3, 3) or (3, 3).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mode</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated tensor mode in each spatial coordinate.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Mode ranges between -1 (planar anisotropy) and +1 (linear anisotropy)\nwith 0 representing orthotropy. Mode is calculated with the\nfollowing equation (equation 9 in <a class=\"reference internal\" href=\"#rae241588dfcd-1\" id=\"id439\">[1]</a>):</p>\n<div class=\"math notranslate nohighlight\">\n\\[Mode = 3*\\sqrt{6}*det(\\widetilde{A}/norm(\\widetilde{A}))\\]</div>\n<p>Where <span class=\"math notranslate nohighlight\">\\(\\widetilde{A}\\)</span> is the deviatoric part of the tensor quadratic form.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rae241588dfcd-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id25\">1</a>,<a href=\"#id438\">2</a>,<a href=\"#id439\">3</a>)</span></dt>\n<dd><p>Daniel B. Ennis and G. Kindlmann, \u201cOrthogonal Tensor\nInvariants and the Analysis of Diffusion Tensor Magnetic Resonance\nImages\u201d, Magnetic Resonance in Medicine, vol. 55, no. 1, pp. 136-146,\n2006.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id441\">\n<h3>nlls_fit_tensor<a class=\"headerlink\" href=\"#id441\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.nlls_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">nlls_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">weighting=None</em>, <em class=\"sig-param\">sigma=None</em>, <em class=\"sig-param\">jac=True</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.nlls_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit the cumulant expansion params (e.g. DTI, DKI) using non-linear\nleast-squares.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, Npar)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients. First six parameters of design matrix should correspond\nto the six unique diffusion tensor elements in the lower triangular\norder (Dxx, Dxy, Dyy, Dxz, Dyz, Dzz), while last parameter to -log(S0)</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>weighting: str</strong></dt><dd><p>the weighting scheme to use in considering the\nsquared-error. Default behavior is to use uniform weighting. Other\noptions: \u2018sigma\u2019 \u2018gmm\u2019</p>\n</dd>\n<dt><strong>sigma: float</strong></dt><dd><p>If the \u2018sigma\u2019 weighting scheme is used, a value of sigma needs to be\nprovided here. According to <a class=\"reference internal\" href=\"../../examples_built/restore_dti/#chang2005\" id=\"id442\"><span>[Chang2005]</span></a>, a good value to use is\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool</span></dt><dd><p>Use the Jacobian? Default: True</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>nlls_params: the eigen-values and eigen-vectors of the tensor in each</dt><dd><p>voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"norm\">\n<h3>norm<a class=\"headerlink\" href=\"#norm\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.norm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">norm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">q_form</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.norm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the Frobenius norm of a tensor quadratic form</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>q_form: ndarray</strong></dt><dd><p>The quadratic form of a tensor, or an array with quadratic forms of\ntensors. Should be of shape (x,y,z,3,3) or (n, 3, 3) or (3,3).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>norm</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The Frobenius norm of the 3,3 tensor q_form in each spatial\ncoordinate.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">np.linalg.norm</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>The Frobenius norm is defined as:</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Math</dt>\n<dd class=\"field-odd\"><p>||A||_F = [sum_{i,j} abs(a_{i,j})^2]^{1/2}</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ols-fit-tensor\">\n<h3>ols_fit_tensor<a class=\"headerlink\" href=\"#ols-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.ols_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">ols_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.ols_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes ordinary least squares (OLS) fit to calculate self-diffusion\ntensor using a linear regression model <span id=\"id443\">[Rd310240b4eed-1]</span>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[:,j] is associated with\neigvals[j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">WLS_fit_tensor</span></code>, <a class=\"reference internal\" href=\"#dipy.reconst.dti.decompose_tensor\" title=\"dipy.reconst.dti.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.dti.design_matrix\" title=\"dipy.reconst.dti.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<div class=\"math notranslate nohighlight\">\n\\[ \\begin{align}\\begin{aligned}\\begin{split}y = \\mathrm{data} \\\\\nX = \\mathrm{design matrix} \\\\\\end{split}\\\\\\hat{\\beta}_\\mathrm{OLS} = (X^T X)^{-1} X^T y\\end{aligned}\\end{align} \\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"footnote brackets\">\n<dt class=\"label\" id=\"id444\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id13\">1</a>,<a href=\"#id17\">2</a>,<a href=\"#id37\">3</a>,<a href=\"#id155\">4</a>,<a href=\"#id252\">5</a>,<a href=\"#id266\">6</a>,<a href=\"#id268\">7</a>,<a href=\"#id310\">8</a>,<a href=\"#id311\">9</a>,<a href=\"#id312\">10</a>,<a href=\"#id357\">11</a>,<a href=\"#id658\">12</a>)</span></dt>\n<dd><p>Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap\napproaches for estimation of uncertainties of DTI parameters.\nNeuroImage 33, 531-541.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"pinv\">\n<h3>pinv<a class=\"headerlink\" href=\"#pinv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.pinv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">pinv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">a</em>, <em class=\"sig-param\">rcond=1e-15</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.pinv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorized version of <cite>numpy.linalg.pinv</cite></p>\n<p>If numpy version is less than 1.8, it falls back to iterating over\n<cite>np.linalg.pinv</cite> since there isn\u2019t a vectorized version of <cite>np.linalg.svd</cite>\navailable.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>a</strong><span class=\"classifier\">array_like (\u2026, M, N)</span></dt><dd><p>Matrix to be pseudo-inverted.</p>\n</dd>\n<dt><strong>rcond</strong><span class=\"classifier\">float</span></dt><dd><p>Cutoff for small singular values.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>B</strong><span class=\"classifier\">ndarray (\u2026, N, M)</span></dt><dd><p>The pseudo-inverse of <cite>a</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>LinAlgError</dt><dd><p>If the SVD computation does not converge.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">np.linalg.pinv</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"planarity\">\n<h3>planarity<a class=\"headerlink\" href=\"#planarity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.planarity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">planarity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.planarity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The planarity of the tensor <a class=\"reference internal\" href=\"#re4b018c1dd86-1\" id=\"id445\">[1]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>linearity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated linearity of the diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Planarity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Planarity =\n\\frac{2 (\\lambda_2-\\lambda_3)}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re4b018c1dd86-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id27\">1</a>,<a href=\"#id445\">2</a>)</span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,\n\u201cGeometrical diffusion measures for MRI from tensor basis analysis\u201d in\nProc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"quantize-evecs\">\n<h3>quantize_evecs<a class=\"headerlink\" href=\"#quantize-evecs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.quantize_evecs\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">quantize_evecs</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evecs</em>, <em class=\"sig-param\">odf_vertices=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.quantize_evecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find the closest orientation of an evenly distributed sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evecs</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n<dt><strong>odf_vertices</strong><span class=\"classifier\">None or ndarray</span></dt><dd><p>If None, then set vertices from symmetric362 sphere.  Otherwise use\npassed ndarray as vertices</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>IN</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id447\">\n<h3>radial_diffusivity<a class=\"headerlink\" href=\"#id447\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.radial_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">radial_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.radial_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial Diffusivity (RD) of a diffusion tensor.\nAlso called perpendicular diffusivity.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor, must be sorted in descending order\nalong <cite>axis</cite>.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>rd</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated RD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[RD = \\frac{\\lambda_2 + \\lambda_3}{2}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id448\">\n<h3>restore_fit_tensor<a class=\"headerlink\" href=\"#id448\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.restore_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">restore_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">sigma=None</em>, <em class=\"sig-param\">jac=True</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.restore_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Use the RESTORE algorithm <a class=\"reference internal\" href=\"#r26bc1bb874b1-1\" id=\"id449\">[1]</a> to calculate a robust tensor fit</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array of shape (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array of shape ([X, Y, Z, n_directions], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>sigma</strong><span class=\"classifier\">float</span></dt><dd><p>An estimate of the variance. <a class=\"reference internal\" href=\"#r26bc1bb874b1-1\" id=\"id450\">[1]</a> recommend to use\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to use the Jacobian of the tensor to speed the non-linear\noptimization procedure used to fit the tensor parameters (see also\n<a class=\"reference internal\" href=\"#dipy.reconst.dti.nlls_fit_tensor\" title=\"dipy.reconst.dti.nlls_fit_tensor\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">nlls_fit_tensor()</span></code></a>). Default: True</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>restore_params</strong><span class=\"classifier\">an estimate of the tensor parameters in each voxel.</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r26bc1bb874b1-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id28\">1</a>,<a href=\"#id449\">2</a>,<a href=\"#id450\">3</a>)</span></dt>\n<dd><p>Chang, L-C, Jones, DK and Pierpaoli, C (2005). RESTORE: robust</p>\n</dd>\n</dl>\n<p>estimation of tensors by outlier rejection. MRM, 53: 1088-95.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sphericity\">\n<h3>sphericity<a class=\"headerlink\" href=\"#sphericity\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.sphericity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">sphericity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.sphericity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The sphericity of the tensor <a class=\"reference internal\" href=\"#r6ba6fcb5068a-1\" id=\"id452\">[1]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity = \\frac{3 \\lambda_3)}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6ba6fcb5068a-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id29\">1</a>,<a href=\"#id452\">2</a>)</span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz F.,\n\u201cGeometrical diffusion measures for MRI from tensor basis analysis\u201d in\nProc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"tensor-prediction\">\n<h3>tensor_prediction<a class=\"headerlink\" href=\"#tensor-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.tensor_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">tensor_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dti_params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.tensor_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal given tensor parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dti_params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Tensor parameters. The last dimension should have 12 tensor\nparameters: 3 eigenvalues, followed by the 3 corresponding\neigenvectors.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by: <span class=\"math notranslate nohighlight\">\\(S(       heta, b) = S_0 * e^{-b ADC}\\)</span>, where\n<span class=\"math notranslate nohighlight\">\\(ADC =      heta Q  heta^T\\)</span>, :math:`      heta` is a unit vector pointing at any\ndirection on the sphere for which a signal is to be predicted, <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b\nvalue provided in the GradientTable input for that direction, <span class=\"math notranslate nohighlight\">\\(Q\\)</span> is the\nquadratic form of the tensor determined by the input parameters.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id454\">\n<h3>trace<a class=\"headerlink\" href=\"#id454\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.trace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">trace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.trace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Trace of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>trace</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated trace of the diffusion tensor.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Trace is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Trace = \\lambda_1 + \\lambda_2 + \\lambda_3\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id455\">\n<h3>vec_val_vect<a class=\"headerlink\" href=\"#id455\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">shape (\u2026, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>\n</dd>\n<dt><strong>vals</strong><span class=\"classifier\">shape (\u2026, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> shape above must\nmatch that for <cite>vecs</cite></p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">shape (\u2026, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code>, loops to get (M, N) <code class=\"docutils literal notranslate\"><span class=\"pre\">vec</span></code>\nmatrix, and (N,) <code class=\"docutils literal notranslate\"><span class=\"pre\">vals</span></code> vector, and calculates\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Make a 3D array where the first dimension is only 1</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec_val_vect</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">vals</span><span class=\"p\">)</span>\n<span class=\"go\">array([[[   9.,   24.,   39.],</span>\n<span class=\"go\">        [  24.,   66.,  108.],</span>\n<span class=\"go\">        [  39.,  108.,  177.]]])</span>\n</pre></div>\n</div>\n<p>That\u2019s the same as the 2D case (apart from the float casting):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">),</span> <span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n<span class=\"go\">array([[  9,  24,  39],</span>\n<span class=\"go\">       [ 24,  66, 108],</span>\n<span class=\"go\">       [ 39, 108, 177]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"vector-norm\">\n<h3>vector_norm<a class=\"headerlink\" href=\"#vector-norm\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.vector_norm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">vector_norm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vec</em>, <em class=\"sig-param\">axis=-1</em>, <em class=\"sig-param\">keepdims=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.vector_norm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return vector Euclidean (L2) norm</p>\n<p>See <a class=\"reference internal\" href=\"../../glossary/#term-unit-vector\"><span class=\"xref std std-term\">unit vector</span></a> and <a class=\"reference internal\" href=\"../../glossary/#term-euclidean-norm\"><span class=\"xref std std-term\">Euclidean norm</span></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vec</strong><span class=\"classifier\">array_like</span></dt><dd><p>Vectors to norm.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis over which to norm. By default norm over last axis. If <cite>axis</cite> is\nNone, <cite>vec</cite> is flattened then normed.</p>\n</dd>\n<dt><strong>keepdims</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, the output will have the same number of dimensions as <cite>vec</cite>,\nwith shape 1 on <cite>axis</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>norm</strong><span class=\"classifier\">array</span></dt><dd><p>Euclidean norms of vectors.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">36</span><span class=\"p\">,</span> <span class=\"mi\">77</span><span class=\"p\">]]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vector_norm</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">)</span>\n<span class=\"go\">array([ 17.,  85.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vector_norm</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"n\">keepdims</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">array([[ 17.],</span>\n<span class=\"go\">       [ 85.]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vector_norm</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">array([  8.,  39.,  77.])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wls-fit-tensor\">\n<h3>wls_fit_tensor<a class=\"headerlink\" href=\"#wls-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.dti.wls_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.dti.</code><code class=\"sig-name descname\">wls_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.dti.wls_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion\ntensor using a linear regression model <a class=\"reference internal\" href=\"#rba397ddf7dbd-1\" id=\"id456\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[:,j] is associated with\neigvals[j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dti.decompose_tensor\" title=\"dipy.reconst.dti.decompose_tensor\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">decompose_tensor</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>In Chung, et al. 2006, the regression of the WLS fit needed an unbiased\npreliminary estimate of the weights and therefore the ordinary least\nsquares (OLS) estimates were used. A \u201ctwo pass\u201d method was implemented:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>calculate OLS estimates of the data</p></li>\n<li><p>apply the OLS estimates as weights to the WLS fit of the data</p></li>\n</ol>\n</div></blockquote>\n<p>This ensured heteroscedasticity could be properly modeled for various\ntypes of bootstrap resampling (namely residual bootstrap).</p>\n<div class=\"math notranslate nohighlight\">\n\\[\\begin{split}y = \\mathrm{data} \\\\\nX = \\mathrm{design matrix} \\\\\n\\hat{\\beta}_\\mathrm{WLS} =\n\\mathrm{desired regression coefficients (e.g. tensor)}\\\\\n\\\\\n\\hat{\\beta}_\\mathrm{WLS} = (X^T W X)^{-1} X^T W y \\\\\n\\\\\nW = \\mathrm{diag}((X \\hat{\\beta}_\\mathrm{OLS})^2),\n\\mathrm{where} \\hat{\\beta}_\\mathrm{OLS} = (X^T X)^{-1} X^T y\\end{split}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rba397ddf7dbd-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id30\">1</a>,<a href=\"#id456\">2</a>)</span></dt>\n<dd><p>Chung, SW., Lu, Y., Henry, R.G., 2006. Comparison of bootstrap\napproaches for estimation of uncertainties of DTI parameters.\nNeuroImage 33, 531-541.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id458\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.Cache\" title=\"dipy.reconst.forecast.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id458\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.forecast.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.Cache.cache_clear\" title=\"dipy.reconst.forecast.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.Cache.cache_get\" title=\"dipy.reconst.forecast.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.Cache.cache_set\" title=\"dipy.reconst.forecast.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"forecastfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit\" title=\"dipy.reconst.forecast.ForecastFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ForecastFit</span></code></a><a class=\"headerlink\" href=\"#forecastfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.ForecastFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">ForecastFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">sh_coef</em>, <em class=\"sig-param\">d_par</em>, <em class=\"sig-param\">d_perp</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfFit</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.dpar\" title=\"dipy.reconst.forecast.ForecastFit.dpar\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dpar</span></code></a></dt><dd><p>The parallel diffusivity</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.dperp\" title=\"dipy.reconst.forecast.ForecastFit.dperp\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dperp</span></code></a></dt><dd><p>The perpendicular diffusivity</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.sh_coeff\" title=\"dipy.reconst.forecast.ForecastFit.sh_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sh_coeff</span></code></a></dt><dd><p>The FORECAST SH coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.fractional_anisotropy\" title=\"dipy.reconst.forecast.ForecastFit.fractional_anisotropy\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fractional_anisotropy</span></code></a>()</p></td>\n<td><p>Calculates the fractional anisotropy.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.mean_diffusivity\" title=\"dipy.reconst.forecast.ForecastFit.mean_diffusivity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean_diffusivity</span></code></a>()</p></td>\n<td><p>Calculates the mean diffusivity.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.odf\" title=\"dipy.reconst.forecast.ForecastFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere[,\u00a0clip_negative])</p></td>\n<td><p>Calculates the fODF for a given discrete sphere.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastFit.predict\" title=\"dipy.reconst.forecast.ForecastFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab,\u00a0S0])</p></td>\n<td><p>Calculates the fODF for a given discrete sphere.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">sh_coef</em>, <em class=\"sig-param\">d_par</em>, <em class=\"sig-param\">d_perp</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates diffusion properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>AnalyticalModel</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>fitted data</p>\n</dd>\n<dt><strong>sh_coef</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>forecast sh coefficients</p>\n</dd>\n<dt><strong>d_par</strong><span class=\"classifier\">float,</span></dt><dd><p>parallel diffusivity</p>\n</dd>\n<dt><strong>d_perp</strong><span class=\"classifier\">float,</span></dt><dd><p>perpendicular diffusivity</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.dpar\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">dpar</code><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.dpar\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The parallel diffusivity</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.dperp\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">dperp</code><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.dperp\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The perpendicular diffusivity</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.fractional_anisotropy\">\n<code class=\"sig-name descname\">fractional_anisotropy</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.fractional_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the fractional anisotropy.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.mean_diffusivity\">\n<code class=\"sig-name descname\">mean_diffusivity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.mean_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the mean diffusivity.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">clip_negative=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the fODF for a given discrete sphere.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere,</span></dt><dd><p>the odf sphere</p>\n</dd>\n<dt><strong>clip_negative</strong><span class=\"classifier\">boolean, optional</span></dt><dd><p>if True clip the negative odf values to 0, default True</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the fODF for a given discrete sphere.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable, optional</span></dt><dd><p>gradient directions and bvalues container class.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float, optional</span></dt><dd><p>the signal at b-value=0</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastFit.sh_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">sh_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastFit.sh_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The FORECAST SH coefficients</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"forecastmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastModel\" title=\"dipy.reconst.forecast.ForecastModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ForecastModel</span></code></a><a class=\"headerlink\" href=\"#forecastmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.ForecastModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">ForecastModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_lb=0.001</em>, <em class=\"sig-param\">dec_alg='CSD'</em>, <em class=\"sig-param\">sphere=None</em>, <em class=\"sig-param\">lambda_csd=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>Fiber ORientation Estimated using Continuous Axially Symmetric Tensors\n(FORECAST) [1,2,3]_. FORECAST is a Spherical Deconvolution reconstruction\nmodel for multi-shell diffusion data which enables the calculation of a\nvoxel adaptive response function using the Spherical Mean Tecnique (SMT)\n[2,3]_.</p>\n<p>With FORECAST it is possible to calculate crossing invariant parallel\ndiffusivity, perpendicular diffusivity, mean diffusivity, and fractional\nanisotropy <a class=\"reference internal\" href=\"#r1340df73dba1-2\" id=\"id459\">[2]</a></p>\n<p class=\"rubric\">Notes</p>\n<p>The implementation of FORECAST may require CVXPY (<a class=\"reference external\" href=\"http://www.cvxpy.org/\">http://www.cvxpy.org/</a>).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1340df73dba1-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Anderson A. W., \u201cMeasurement of Fiber Orientation Distributions\nUsing High Angular Resolution Diffusion Imaging\u201d, Magnetic\nResonance in Medicine, 2005.</p>\n</dd>\n<dt class=\"label\" id=\"r1340df73dba1-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id459\">2</a></span></dt>\n<dd><p>Kaden E. et al., \u201cQuantitative Mapping of the Per-Axon Diffusion\nCoefficients in Brain White Matter\u201d, Magnetic Resonance in\nMedicine, 2016.</p>\n</dd>\n<dt class=\"label\" id=\"r1340df73dba1-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Zucchelli E. et al., \u201cA generalized SMT-based framework for\nDiffusion MRI microstructural model estimation\u201d, MICCAI Workshop\non Computational DIFFUSION MRI (CDMRI), 2017.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.ForecastModel.fit\" title=\"dipy.reconst.forecast.ForecastModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">lambda_lb=0.001</em>, <em class=\"sig-param\">dec_alg='CSD'</em>, <em class=\"sig-param\">sphere=None</em>, <em class=\"sig-param\">lambda_csd=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Analytical and continuous modeling of the diffusion signal with\nrespect to the FORECAST basis [1,2,3]_.\nThis implementation is a modification of the original FORECAST\nmodel presented in <a class=\"reference internal\" href=\"#rb72cc5c16677-1\" id=\"id463\">[1]</a> adapted for multi-shell data as in [2,3]_ .</p>\n<p>The main idea is to model the diffusion signal as the combination of a\nsingle fiber response function <span class=\"math notranslate nohighlight\">\\(F(\\mathbf{b})\\)</span> times the fODF\n<span class=\"math notranslate nohighlight\">\\(\\rho(\\mathbf{v})\\)</span></p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>E(mathbf{b}) = int_{mathbf{v} in mathcal{S}^2} rho(mathbf{v}) F({mathbf{b}} | mathbf{v}) d mathbf{v}</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\mathbf{b}\\)</span> is the b-vector (b-value times gradient direction)\nand <span class=\"math notranslate nohighlight\">\\(\\mathbf{v}\\)</span> is an unit vector representing a fiber direction.</p>\n<p>In FORECAST <span class=\"math notranslate nohighlight\">\\(\\rho\\)</span> is modeled using real symmetric Spherical Harmonics\n(SH) and <span class=\"math notranslate nohighlight\">\\(F(\\mathbf(b))\\)</span> is an axially symmetric tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the SH order of the basis (max 12)</p>\n</dd>\n<dt><strong>lambda_lb: float,</strong></dt><dd><p>Laplace-Beltrami regularization weight.</p>\n</dd>\n<dt><strong>dec_alg</strong><span class=\"classifier\">str,</span></dt><dd><p>Spherical deconvolution algorithm. The possible values are Weighted Least Squares (\u2018WLS\u2019),\nPositivity Constraints using CVXPY (\u2018POS\u2019) and the Constraint\nSpherical Deconvolution algorithm (\u2018CSD\u2019). Default is \u2018CSD\u2019.</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">array, shape (N,3),</span></dt><dd><p>sphere points where to enforce positivity when \u2018POS\u2019 or \u2018CSD\u2019\ndec_alg are selected.</p>\n</dd>\n<dt><strong>lambda_csd</strong><span class=\"classifier\">float,</span></dt><dd><p>CSD regularization weight.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb72cc5c16677-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id463\">1</a></span></dt>\n<dd><p>Anderson A. W., \u201cMeasurement of Fiber Orientation Distributions\nUsing High Angular Resolution Diffusion Imaging\u201d, Magnetic\nResonance in Medicine, 2005.</p>\n</dd>\n<dt class=\"label\" id=\"rb72cc5c16677-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Kaden E. et al., \u201cQuantitative Mapping of the Per-Axon Diffusion\nCoefficients in Brain White Matter\u201d, Magnetic Resonance in\nMedicine, 2016.</p>\n</dd>\n<dt class=\"label\" id=\"rb72cc5c16677-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Zucchelli M. et al., \u201cA generalized SMT-based framework for\nDiffusion MRI microstructural model estimation\u201d, MICCAI Workshop\non Computational DIFFUSION MRI (CDMRI), 2017.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>In this example, where the data, gradient table and sphere tessellation\nused for reconstruction are provided, we model the diffusion signal\nwith respect to the FORECAST and compute the fODF, parallel and\nperpendicular diffusivity.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">default_sphere</span><span class=\"p\">,</span> <span class=\"n\">get_3shell_gtab</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">get_3shell_gtab</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.sims.voxel</span> <span class=\"k\">import</span> <span class=\"n\">multi_tensor</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mevals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(([</span><span class=\"mf\">0.0017</span><span class=\"p\">,</span> <span class=\"mf\">0.0003</span><span class=\"p\">,</span> <span class=\"mf\">0.0003</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                   <span class=\"p\">[</span><span class=\"mf\">0.0017</span><span class=\"p\">,</span> <span class=\"mf\">0.0003</span><span class=\"p\">,</span> <span class=\"mf\">0.0003</span><span class=\"p\">]))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">angl</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">sticks</span> <span class=\"o\">=</span> <span class=\"n\">multi_tensor</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">mevals</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">S0</span><span class=\"o\">=</span><span class=\"mf\">100.0</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">angles</span><span class=\"o\">=</span><span class=\"n\">angl</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">fractions</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">snr</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.forecast</span> <span class=\"k\">import</span> <span class=\"n\">ForecastModel</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">ForecastModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">sh_order</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">f_fit</span> <span class=\"o\">=</span> <span class=\"n\">fm</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d_par</span> <span class=\"o\">=</span> <span class=\"n\">f_fit</span><span class=\"o\">.</span><span class=\"n\">dpar</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">d_perp</span> <span class=\"o\">=</span> <span class=\"n\">f_fit</span><span class=\"o\">.</span><span class=\"n\">dperp</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">fodf</span> <span class=\"o\">=</span> <span class=\"n\">f_fit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.ForecastModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.ForecastModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"looseversion\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.LooseVersion\" title=\"dipy.reconst.forecast.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#looseversion\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.forecast.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.forecast.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id467\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfFit\" title=\"dipy.reconst.forecast.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a><a class=\"headerlink\" href=\"#id467\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.OdfFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">OdfFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfFit.odf\" title=\"dipy.reconst.forecast.OdfFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>To be implemented but specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.OdfFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.OdfFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented but specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id468\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfModel\" title=\"dipy.reconst.forecast.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a><a class=\"headerlink\" href=\"#id468\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.forecast.OdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">OdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>An abstract class to be sub-classed by specific odf models</p>\n<p>All odf models should provide a fit method which may take data as it\u2019s\nfirst and only argument.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.forecast.OdfModel.fit\" title=\"dipy.reconst.forecast.OdfModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.OdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.forecast.OdfModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.OdfModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented by specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id469\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id469\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id470\">\n<h3>csdeconv<a class=\"headerlink\" href=\"#id470\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.csdeconv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">csdeconv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dwsignal</em>, <em class=\"sig-param\">X</em>, <em class=\"sig-param\">B_reg</em>, <em class=\"sig-param\">tau=0.1</em>, <em class=\"sig-param\">convergence=50</em>, <em class=\"sig-param\">P=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.csdeconv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constrained-regularized spherical deconvolution (CSD) <a class=\"reference internal\" href=\"#r89c481eb6cb9-1\" id=\"id471\">[1]</a></p>\n<p>Deconvolves the axially symmetric single fiber response function <cite>r_rh</cite> in\nrotational harmonics coefficients from the diffusion weighted signal in\n<cite>dwsignal</cite>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dwsignal</strong><span class=\"classifier\">array</span></dt><dd><p>Diffusion weighted signals to be deconvolved.</p>\n</dd>\n<dt><strong>X</strong><span class=\"classifier\">array</span></dt><dd><p>Prediction matrix which estimates diffusion weighted signals from FOD\ncoefficients.</p>\n</dd>\n<dt><strong>B_reg</strong><span class=\"classifier\">array (N, B)</span></dt><dd><p>SH basis matrix which maps FOD coefficients to FOD values on the\nsurface of the sphere. B_reg should be scaled to account for lambda.</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>Threshold controlling the amplitude below which the corresponding fODF\nis assumed to be zero.  Ideally, tau should be set to zero. However, to\nimprove the stability of the algorithm, tau is set to tau*100 % of the\nmax fODF amplitude (here, 10% by default). This is similar to peak\ndetection where peaks below 0.1 amplitude are usually considered noise\npeaks. Because SDT is based on a q-ball ODF deconvolution, and not\nsignal deconvolution, using the max instead of mean (as in CSD), is\nmore stable.</p>\n</dd>\n<dt><strong>convergence</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to allow the deconvolution to converge.</p>\n</dd>\n<dt><strong>P</strong><span class=\"classifier\">ndarray</span></dt><dd><p>This is an optimization to avoid computing <code class=\"docutils literal notranslate\"><span class=\"pre\">dot(X.T,</span> <span class=\"pre\">X)</span></code> many times.\nIf the same <code class=\"docutils literal notranslate\"><span class=\"pre\">X</span></code> is used many times, <code class=\"docutils literal notranslate\"><span class=\"pre\">P</span></code> can be precomputed and\npassed to this function.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>fodf_sh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>Spherical harmonics coefficients of the constrained-regularized fiber\nODF.</p>\n</dd>\n<dt><strong>num_it</strong><span class=\"classifier\">int</span></dt><dd><p>Number of iterations in the constrained-regularization used for\nconvergence.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This section describes how the fitting of the SH coefficients is done.\nProblem is to minimise per iteration:</p>\n<p><span class=\"math notranslate nohighlight\">\\(F(f_n) = ||Xf_n - S||^2 + \\lambda^2 ||H_{n-1} f_n||^2\\)</span></p>\n<p>Where <span class=\"math notranslate nohighlight\">\\(X\\)</span> maps current FOD SH coefficients <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to DW signals <span class=\"math notranslate nohighlight\">\\(s\\)</span> and\n<span class=\"math notranslate nohighlight\">\\(H_{n-1}\\)</span> maps FOD SH coefficients <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to amplitudes along set of\nnegative directions identified in previous iteration, i.e. the matrix\nformed by the rows of <span class=\"math notranslate nohighlight\">\\(B_{reg}\\)</span> for which <span class=\"math notranslate nohighlight\">\\(Hf_{n-1}&lt;0\\)</span> where <span class=\"math notranslate nohighlight\">\\(B_{reg}\\)</span>\nmaps <span class=\"math notranslate nohighlight\">\\(f_n\\)</span> to FOD amplitude on a sphere.</p>\n<p>Solve by differentiating and setting to zero:</p>\n<p><span class=\"math notranslate nohighlight\">\\(\\Rightarrow \\frac{\\delta F}{\\delta f_n} = 2X^T(Xf_n - S) + 2 \\lambda^2\nH_{n-1}^TH_{n-1}f_n=0\\)</span></p>\n<p>Or:</p>\n<p><span class=\"math notranslate nohighlight\">\\((X^TX + \\lambda^2 H_{n-1}^TH_{n-1})f_n = X^Ts\\)</span></p>\n<p>Define <span class=\"math notranslate nohighlight\">\\(Q = X^TX + \\lambda^2 H_{n-1}^TH_{n-1}\\)</span> , which by construction is a\nsquare positive definite symmetric matrix of size <span class=\"math notranslate nohighlight\">\\(n_{SH} by n_{SH}\\)</span>. If\nneeded, positive definiteness can be enforced with a small minimum norm\nregulariser (helps a lot with poorly conditioned direction sets and/or\nsuperresolution):</p>\n<p><span class=\"math notranslate nohighlight\">\\(Q = X^TX + (\\lambda H_{n-1}^T) (\\lambda H_{n-1}) + \\mu I\\)</span></p>\n<p>Solve <span class=\"math notranslate nohighlight\">\\(Qf_n = X^Ts\\)</span> using Cholesky decomposition:</p>\n<p><span class=\"math notranslate nohighlight\">\\(Q = LL^T\\)</span></p>\n<p>where <span class=\"math notranslate nohighlight\">\\(L\\)</span> is lower triangular. Then problem can be solved by\nback-substitution:</p>\n<p><span class=\"math notranslate nohighlight\">\\(L_y = X^Ts\\)</span></p>\n<p><span class=\"math notranslate nohighlight\">\\(L^Tf_n = y\\)</span></p>\n<p>To speeds things up further, form <span class=\"math notranslate nohighlight\">\\(P = X^TX + \\mu I\\)</span>, and update to form\n<span class=\"math notranslate nohighlight\">\\(Q\\)</span> by rankn update with <span class=\"math notranslate nohighlight\">\\(H_{n-1}\\)</span>. The dipy implementation looks like:</p>\n<blockquote>\n<div><p>form initially <span class=\"math notranslate nohighlight\">\\(P = X^T X + \\mu I\\)</span> and <span class=\"math notranslate nohighlight\">\\(\\lambda B_{reg}\\)</span></p>\n<p>for each voxel: form <span class=\"math notranslate nohighlight\">\\(z = X^Ts\\)</span></p>\n<blockquote>\n<div><p>estimate <span class=\"math notranslate nohighlight\">\\(f_0\\)</span> by solving <span class=\"math notranslate nohighlight\">\\(Pf_0=z\\)</span>. We use a simplified <span class=\"math notranslate nohighlight\">\\(l_{max}=4\\)</span>\nsolution here, but it might not make a big difference.</p>\n<p>Then iterate until no change in rows of <span class=\"math notranslate nohighlight\">\\(H\\)</span> used in <span class=\"math notranslate nohighlight\">\\(H_n\\)</span></p>\n<blockquote>\n<div><p>form <span class=\"math notranslate nohighlight\">\\(H_{n}\\)</span> given <span class=\"math notranslate nohighlight\">\\(f_{n-1}\\)</span></p>\n<p>form <span class=\"math notranslate nohighlight\">\\(Q = P + (\\lambda H_{n-1}^T) (\\lambda H_{n-1}\\)</span>) (this can\nbe done by rankn update, but we currently do not use rankn\nupdate).</p>\n<p>solve <span class=\"math notranslate nohighlight\">\\(Qf_n = z\\)</span> using Cholesky decomposition</p>\n</div></blockquote>\n</div></blockquote>\n</div></blockquote>\n<p>We\u2019d like to thanks Donald Tournier for his help with describing and\nimplementing this algorithm.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r89c481eb6cb9-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id31\">1</a>,<a href=\"#id471\">2</a>)</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the\nfibre orientation distribution in diffusion MRI: Non-negativity\nconstrained super-resolved spherical deconvolution.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"find-signal-means\">\n<h3>find_signal_means<a class=\"headerlink\" href=\"#find-signal-means\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.find_signal_means\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">find_signal_means</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b_unique</em>, <em class=\"sig-param\">data_norm</em>, <em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">rho</em>, <em class=\"sig-param\">lb_matrix</em>, <em class=\"sig-param\">w=0.001</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.find_signal_means\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the mean signal for each shell.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>b_unique</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>unique b-values in a vector excluding zero</p>\n</dd>\n<dt><strong>data_norm</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>normalized diffusion signal</p>\n</dd>\n<dt><strong>bvals</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>the b-values</p>\n</dd>\n<dt><strong>rho</strong><span class=\"classifier\">2d ndarray,</span></dt><dd><p>SH basis matrix for fitting the signal on each shell</p>\n</dd>\n<dt><strong>lb_matrix</strong><span class=\"classifier\">2d ndarray,</span></dt><dd><p>Laplace-Beltrami regularization matrix</p>\n</dd>\n<dt><strong>w</strong><span class=\"classifier\">float,</span></dt><dd><p>weight for the Laplace-Beltrami regularization</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>means</strong><span class=\"classifier\">1d ndarray</span></dt><dd><p>the average of the signal for each b-values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"forecast-error-func\">\n<h3>forecast_error_func<a class=\"headerlink\" href=\"#forecast-error-func\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.forecast_error_func\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">forecast_error_func</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">b_unique</em>, <em class=\"sig-param\">E</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.forecast_error_func\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the difference between the mean signal calculated using\nthe parameter vector x and the average signal E using FORECAST and SMT</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"forecast-matrix\">\n<h3>forecast_matrix<a class=\"headerlink\" href=\"#forecast-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.forecast_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">forecast_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">d_par</em>, <em class=\"sig-param\">d_perp</em>, <em class=\"sig-param\">bvals</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.forecast_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the FORECAST radial matrix</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lb-forecast\">\n<h3>lb_forecast<a class=\"headerlink\" href=\"#lb-forecast\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.lb_forecast\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">lb_forecast</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.lb_forecast\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the Laplace-Beltrami regularization matrix for FORECAST</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"leastsq\">\n<h3>leastsq<a class=\"headerlink\" href=\"#leastsq\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.leastsq\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">leastsq</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em>, <em class=\"sig-param\">x0</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">Dfun=None</em>, <em class=\"sig-param\">full_output=0</em>, <em class=\"sig-param\">col_deriv=0</em>, <em class=\"sig-param\">ftol=1.49012e-08</em>, <em class=\"sig-param\">xtol=1.49012e-08</em>, <em class=\"sig-param\">gtol=0.0</em>, <em class=\"sig-param\">maxfev=0</em>, <em class=\"sig-param\">epsfcn=None</em>, <em class=\"sig-param\">factor=100</em>, <em class=\"sig-param\">diag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.leastsq\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Minimize the sum of squares of a set of equations.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">arg</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n         <span class=\"n\">y</span>\n</pre></div>\n</div>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">callable</span></dt><dd><p>Should take at least one (possibly length N vector) argument and\nreturns M floating point numbers. It must not return NaNs or\nfitting might fail.</p>\n</dd>\n<dt><strong>x0</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The starting estimate for the minimization.</p>\n</dd>\n<dt><strong>args</strong><span class=\"classifier\">tuple, optional</span></dt><dd><p>Any extra arguments to func are placed in this tuple.</p>\n</dd>\n<dt><strong>Dfun</strong><span class=\"classifier\">callable, optional</span></dt><dd><p>A function or method to compute the Jacobian of func with derivatives\nacross the rows. If this is None, the Jacobian will be estimated.</p>\n</dd>\n<dt><strong>full_output</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>non-zero to return all optional outputs.</p>\n</dd>\n<dt><strong>col_deriv</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>non-zero to specify that the Jacobian function computes derivatives\ndown the columns (faster, because there is no transpose operation).</p>\n</dd>\n<dt><strong>ftol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Relative error desired in the sum of squares.</p>\n</dd>\n<dt><strong>xtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Relative error desired in the approximate solution.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Orthogonality desired between the function vector and the columns of\nthe Jacobian.</p>\n</dd>\n<dt><strong>maxfev</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The maximum number of calls to the function. If <cite>Dfun</cite> is provided,\nthen the default <cite>maxfev</cite> is 100*(N+1) where N is the number of elements\nin x0, otherwise the default <cite>maxfev</cite> is 200*(N+1).</p>\n</dd>\n<dt><strong>epsfcn</strong><span class=\"classifier\">float, optional</span></dt><dd><p>A variable used in determining a suitable step length for the forward-\ndifference approximation of the Jacobian (for Dfun=None).\nNormally the actual step length will be sqrt(epsfcn)*x\nIf epsfcn is less than the machine precision, it is assumed that the\nrelative errors are of the order of the machine precision.</p>\n</dd>\n<dt><strong>factor</strong><span class=\"classifier\">float, optional</span></dt><dd><p>A parameter determining the initial step bound\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">factor</span> <span class=\"pre\">*</span> <span class=\"pre\">||</span> <span class=\"pre\">diag</span> <span class=\"pre\">*</span> <span class=\"pre\">x||</span></code>). Should be in interval <code class=\"docutils literal notranslate\"><span class=\"pre\">(0.1,</span> <span class=\"pre\">100)</span></code>.</p>\n</dd>\n<dt><strong>diag</strong><span class=\"classifier\">sequence, optional</span></dt><dd><p>N positive entries that serve as a scale factors for the variables.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>x</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The solution (or the result of the last iteration for an unsuccessful\ncall).</p>\n</dd>\n<dt><strong>cov_x</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The inverse of the Hessian. <cite>fjac</cite> and <cite>ipvt</cite> are used to construct an\nestimate of the Hessian. A value of None indicates a singular matrix,\nwhich means the curvature in parameters <cite>x</cite> is numerically flat. To\nobtain the covariance matrix of the parameters <cite>x</cite>, <cite>cov_x</cite> must be\nmultiplied by the variance of the residuals \u2013 see curve_fit.</p>\n</dd>\n<dt><strong>infodict</strong><span class=\"classifier\">dict</span></dt><dd><p>a dictionary of optional outputs with the keys:</p>\n<dl class=\"simple\">\n<dt><code class=\"docutils literal notranslate\"><span class=\"pre\">nfev</span></code></dt><dd><p>The number of function calls</p>\n</dd>\n<dt><code class=\"docutils literal notranslate\"><span class=\"pre\">fvec</span></code></dt><dd><p>The function evaluated at the output</p>\n</dd>\n<dt><code class=\"docutils literal notranslate\"><span class=\"pre\">fjac</span></code></dt><dd><p>A permutation of the R matrix of a QR\nfactorization of the final approximate\nJacobian matrix, stored column wise.\nTogether with ipvt, the covariance of the\nestimate can be approximated.</p>\n</dd>\n<dt><code class=\"docutils literal notranslate\"><span class=\"pre\">ipvt</span></code></dt><dd><p>An integer array of length N which defines\na permutation matrix, p, such that\nfjac*p = q*r, where r is upper triangular\nwith diagonal elements of nonincreasing\nmagnitude. Column j of p is column ipvt(j)\nof the identity matrix.</p>\n</dd>\n<dt><code class=\"docutils literal notranslate\"><span class=\"pre\">qtf</span></code></dt><dd><p>The vector (transpose(q) * fvec).</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>mesg</strong><span class=\"classifier\">str</span></dt><dd><p>A string message giving information about the cause of failure.</p>\n</dd>\n<dt><strong>ier</strong><span class=\"classifier\">int</span></dt><dd><p>An integer flag. If it is equal to 1, 2, 3 or 4, the solution was\nfound. Otherwise, the solution was not found. In either case, the\noptional output variable \u2018mesg\u2019 gives more information.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">least_squares</span></code></dt><dd><p>Newer interface to solve nonlinear least-squares problems with bounds on the variables. See <code class=\"docutils literal notranslate\"><span class=\"pre\">method=='lm'</span></code> in particular.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>\u201cleastsq\u201d is a wrapper around MINPACK\u2019s lmdif and lmder algorithms.</p>\n<p>cov_x is a Jacobian approximation to the Hessian of the least squares\nobjective function.\nThis approximation assumes that the objective function is based on the\ndifference between some observed target data (ydata) and a (non-linear)\nfunction of the parameters <cite>f(xdata, params)</cite></p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">ydata</span> <span class=\"o\">-</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">xdata</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>so that the objective function is</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>  <span class=\"nb\">min</span>   <span class=\"nb\">sum</span><span class=\"p\">((</span><span class=\"n\">ydata</span> <span class=\"o\">-</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">xdata</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">))</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">params</span>\n</pre></div>\n</div>\n<p>The solution, <cite>x</cite>, is always a 1-D array, regardless of the shape of <cite>x0</cite>,\nor whether <cite>x0</cite> is a scalar.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">leastsq</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">leastsq</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">(array([2.99999999]), 1)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id473\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id473\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"optional-package\">\n<h3>optional_package<a class=\"headerlink\" href=\"#optional-package\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"psi-l\">\n<h3>psi_l<a class=\"headerlink\" href=\"#psi-l\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.psi_l\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">psi_l</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">l</em>, <em class=\"sig-param\">b</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.psi_l\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"id474\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#id474\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"rho-matrix\">\n<h3>rho_matrix<a class=\"headerlink\" href=\"#rho-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.rho_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">rho_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">vecs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.rho_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the SH matrix <span class=\"math notranslate nohighlight\">\\(\\rho\\)</span></p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"warn\">\n<h3>warn<a class=\"headerlink\" href=\"#warn\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.forecast.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.forecast.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.forecast.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"freewatertensorfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit\" title=\"dipy.reconst.fwdti.FreeWaterTensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorFit</span></code></a><a class=\"headerlink\" href=\"#freewatertensorfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">FreeWaterTensorFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.dti.TensorFit\" title=\"dipy.reconst.dti.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dti.TensorFit</span></code></a></p>\n<p>Class for fitting the Free Water Tensor Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit.f\" title=\"dipy.reconst.fwdti.FreeWaterTensorFit.f\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">f</span></code></a></dt><dd><p>Returns the free water diffusion volume fraction f</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit.predict\" title=\"dipy.reconst.fwdti.FreeWaterTensorFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a free water tensor model fit, predict the signal on the vertices of a gradient table</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a FreeWaterTensorFit class instance.\nSince the free water tensor model is an extension of DTI, class\ninstance is defined as subclass of the TensorFit from dti.py</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>model</strong><span class=\"classifier\">FreeWaterTensorModel Class instance</span></dt><dd><p>Class instance containing the free water tensor model for the fit</p>\n</dd>\n<dt><strong>model_params</strong><span class=\"classifier\">ndarray (x, y, z, 13) or (n, 13)</span></dt><dd><p>All parameters estimated from the free water tensor model.\nParameters are ordered as follows:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>The volume fraction of the free water compartment</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9ddc02047d69-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,\nPeterson E.T., Correia, M.M., 2017. [Re] Optimization of a free\nwater elimination two-compartment model for diffusion tensor\nimaging. ReScience volume 3, issue 1, article number 2</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorFit.f\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">f</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit.f\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the free water diffusion volume fraction f</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a free water tensor model fit, predict the signal on the\nvertices of a gradient table</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default: 1 in\nall voxels.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"freewatertensormodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel\" title=\"dipy.reconst.fwdti.FreeWaterTensorModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorModel</span></code></a><a class=\"headerlink\" href=\"#freewatertensormodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">FreeWaterTensorModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='NLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Class for the Free Water Elimination Diffusion Tensor Model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel.fit\" title=\"dipy.reconst.fwdti.FreeWaterTensorModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel.predict\" title=\"dipy.reconst.fwdti.FreeWaterTensorModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(fwdti_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='NLS'</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Free Water Diffusion Tensor Model <a class=\"reference internal\" href=\"#r557833582831-1\" id=\"id476\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:</p>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 for weighted linear least square fit according to <a class=\"reference internal\" href=\"#r557833582831-1\" id=\"id477\">[1]</a></dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">fwdti.wls_iter()</span></code></p>\n</dd>\n<dt>\u2018NLS\u2019 for non-linear least square fit according to <a class=\"reference internal\" href=\"#r557833582831-1\" id=\"id478\">[1]</a></dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">fwdti.nls_iter()</span></code></p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id479\"><span class=\"problematic\" id=\"id480\">*</span></a>args, <a href=\"#id481\"><span class=\"problematic\" id=\"id482\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See fwdti.wls_iter, fwdti.nls_iter for\ndetails</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r557833582831-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id476\">1</a>,<a href=\"#id477\">2</a>,<a href=\"#id478\">3</a>)</span></dt>\n<dd><p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,\nPeterson E.T., Correia, M.M., 2017. [Re] Optimization of a free\nwater elimination two-compartment model for diffusion tensor\nimaging. ReScience volume 3, issue 1, article number 2</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.FreeWaterTensorModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fwdti_params</em>, <em class=\"sig-param\">S0=1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.FreeWaterTensorModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this TensorModel class instance given\nparameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fwdti_params</strong><span class=\"classifier\">(\u2026, 13) ndarray</span></dt><dd><p>The last dimension should have 13 parameters: the 12 tensor\nparameters (3 eigenvalues, followed by the 3 corresponding\neigenvectors) and the free water volume fraction.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id484\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.ReconstModel\" title=\"dipy.reconst.fwdti.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id484\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.fwdti.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id485\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit\" title=\"dipy.reconst.fwdti.TensorFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a><a class=\"headerlink\" href=\"#id485\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.fwdti.TensorFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">TensorFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.directions\" title=\"dipy.reconst.fwdti.TensorFit.directions\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">directions</span></code></a></dt><dd><p>For tracking - return the primary direction in each voxel</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.evals\" title=\"dipy.reconst.fwdti.TensorFit.evals\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evals</span></code></a></dt><dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.evecs\" title=\"dipy.reconst.fwdti.TensorFit.evecs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">evecs</span></code></a></dt><dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.quadratic_form\" title=\"dipy.reconst.fwdti.TensorFit.quadratic_form\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">quadratic_form</span></code></a></dt><dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.ad\" title=\"dipy.reconst.fwdti.TensorFit.ad\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ad</span></code></a>()</p></td>\n<td><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.adc\" title=\"dipy.reconst.fwdti.TensorFit.adc\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">adc</span></code></a>(sphere)</p></td>\n<td><p>Calculate the apparent diffusion coefficient (ADC) in each direction on</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.color_fa\" title=\"dipy.reconst.fwdti.TensorFit.color_fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">color_fa</span></code></a>()</p></td>\n<td><p>Color fractional anisotropy of diffusion tensor</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.fa\" title=\"dipy.reconst.fwdti.TensorFit.fa\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fa</span></code></a>()</p></td>\n<td><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.ga\" title=\"dipy.reconst.fwdti.TensorFit.ga\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ga</span></code></a>()</p></td>\n<td><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.linearity\" title=\"dipy.reconst.fwdti.TensorFit.linearity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">linearity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.md\" title=\"dipy.reconst.fwdti.TensorFit.md\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">md</span></code></a>()</p></td>\n<td><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.mode\" title=\"dipy.reconst.fwdti.TensorFit.mode\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mode</span></code></a>()</p></td>\n<td><p>Tensor mode calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.odf\" title=\"dipy.reconst.fwdti.TensorFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>The diffusion orientation distribution function (dODF).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.planarity\" title=\"dipy.reconst.fwdti.TensorFit.planarity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">planarity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.predict\" title=\"dipy.reconst.fwdti.TensorFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0,\u00a0step])</p></td>\n<td><p>Given a model fit, predict the signal on the vertices of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.rd\" title=\"dipy.reconst.fwdti.TensorFit.rd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rd</span></code></a>()</p></td>\n<td><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.sphericity\" title=\"dipy.reconst.fwdti.TensorFit.sphericity\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sphericity</span></code></a>()</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.fwdti.TensorFit.trace\" title=\"dipy.reconst.fwdti.TensorFit.trace\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code></a>()</p></td>\n<td><p>Trace of the tensor calculated from cached eigenvalues.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 67%\" />\n<col style=\"width: 33%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>lower_triangular</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a TensorFit class instance.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.S0_hat\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">S0_hat</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.S0_hat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.ad\">\n<code class=\"sig-name descname\">ad</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.ad\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Axial diffusivity (AD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ad</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated AD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[AD = \\lambda_1\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.adc\">\n<code class=\"sig-name descname\">adc</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.adc\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><blockquote>\n<div><p>Calculate the apparent diffusion coefficient (ADC) in each direction on\nthe sphere for each voxel in the data</p>\n</div></blockquote>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>adc</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The estimates of the apparent diffusion coefficient in every\ndirection on the input sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>ec{b} Q \nec{b}^T</p>\n<blockquote>\n<div><p>Where Q is the quadratic form of the tensor.</p>\n</div></blockquote>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.color_fa\">\n<code class=\"sig-name descname\">color_fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.color_fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Color fractional anisotropy of diffusion tensor</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.directions\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">directions</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.directions\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>For tracking - return the primary direction in each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.evals\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evals</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.evals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvalues of the tensor as an array</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.evecs\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evecs</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.evecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the eigenvectors of the tensor as an array, columnwise</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.fa\">\n<code class=\"sig-name descname\">fa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.fa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fractional anisotropy (FA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.ga\">\n<code class=\"sig-name descname\">ga</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.ga\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Geodesic anisotropy (GA) calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.linearity\">\n<code class=\"sig-name descname\">linearity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.linearity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>linearity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated linearity of the diffusion tensor <a class=\"reference internal\" href=\"#r543828766ea2-1\" id=\"id486\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Linearity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Linearity =\n\\frac{\\lambda_1-\\lambda_2}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r543828766ea2-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id486\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.lower_triangular\">\n<code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.md\">\n<code class=\"sig-name descname\">md</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.md\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean diffusivity (MD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1+\\lambda_2+\\lambda_3}{3}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.mode\">\n<code class=\"sig-name descname\">mode</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.mode\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Tensor mode calculated from cached eigenvalues.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The diffusion orientation distribution function (dODF). This is an\nestimate of the diffusion distance in each direction</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance.</span></dt><dd><p>The dODF is calculated in the vertices of this input.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The diffusion distance in every direction of the sphere in every\nvoxel in the input data.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This is based on equation 3 in <a class=\"reference internal\" href=\"#rad5a83a2738a-1\" id=\"id488\">[1]</a>. To re-derive it from\nscratch, follow steps in <a class=\"reference internal\" href=\"#rad5a83a2738a-2\" id=\"id489\">[2]</a>, Section 7.9 Equation\n7.24 but with an <span class=\"math notranslate nohighlight\">\\(r^2\\)</span> term in the integral.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rad5a83a2738a-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id488\">1</a></span></dt>\n<dd><p>Aganj, I., Lenglet, C., Sapiro, G., Yacoub, E., Ugurbil,\nK., &amp; Harel, N. (2010). Reconstruction of the orientation\ndistribution function in single- and multiple-shell q-ball imaging\nwithin constant solid angle. Magnetic Resonance in Medicine, 64(2),\n554-566. doi:DOI: 10.1002/mrm.22365</p>\n</dd>\n<dt class=\"label\" id=\"rad5a83a2738a-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id489\">2</a></span></dt>\n<dd><p>Descoteaux, M. (2008). PhD Thesis: High Angular\nResolution Diffusion MRI: from Local Estimation to Segmentation and\nTractography.\n<a class=\"reference external\" href=\"ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf\">ftp://ftp-sop.inria.fr/athena/Publications/PhDs/descoteaux_thesis.pdf</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.planarity\">\n<code class=\"sig-name descname\">planarity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.planarity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#r611cb62d4f6a-1\" id=\"id492\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity =\n\\frac{2 (\\lambda_2 - \\lambda_3)}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r611cb62d4f6a-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id492\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=None</em>, <em class=\"sig-param\">step=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a model fit, predict the signal on the vertices of a sphere</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:\nThe fitted S0 value in all voxels if it was fitted. Otherwise 1 in\nall voxels.</p>\n</dd>\n<dt><strong>step</strong><span class=\"classifier\">int</span></dt><dd><p>The chunk size as a number of voxels. Optional parameter with\ndefault value 10,000.</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. This parameter sets the number of\nvoxels that will be fit at once in each iteration. A larger step\nvalue should speed things up, but it will also take up more memory.\nIt is advisable to keep an eye on memory consumption as this value\nis increased.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:</p>\n<div class=\"math notranslate nohighlight\">\n\\[S(  heta, b) = S_0 * e^{-b ADC}\\]</div>\n<p>Where:\n.. math</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">ADC</span> <span class=\"o\">=</span>       <span class=\"n\">heta</span> <span class=\"n\">Q</span>  <span class=\"n\">heta</span><span class=\"o\">^</span><span class=\"n\">T</span>\n</pre></div>\n</div>\n<p>:math:`       heta` is a unit vector pointing at any direction on the sphere for\nwhich a signal is to be predicted and <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b value provided in\nthe GradientTable input for that direction</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.quadratic_form\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">quadratic_form</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.quadratic_form\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the 3x3 diffusion tensor for each voxel</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.rd\">\n<code class=\"sig-name descname\">rd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.rd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial diffusivity (RD) calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>rd</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated RD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>RD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[RD = \\frac{\\lambda_2 + \\lambda_3}{2}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.sphericity\">\n<code class=\"sig-name descname\">sphericity</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.sphericity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphericity</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated sphericity of the diffusion tensor <a class=\"reference internal\" href=\"#r94ed6cf2a317-1\" id=\"id494\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Sphericity is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[Sphericity = \\frac{3 \\lambda_3}{\\lambda_1+\\lambda_2+\\lambda_3}\\]</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r94ed6cf2a317-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id494\">1</a></span></dt>\n<dd><p>Westin C.-F., Peled S., Gubjartsson H., Kikinis R., Jolesz\nF., \u201cGeometrical diffusion measures for MRI from tensor basis\nanalysis\u201d in Proc. 5th Annual ISMRM, 1997.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.fwdti.TensorFit.trace\">\n<code class=\"sig-name descname\">trace</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.TensorFit.trace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Trace of the tensor calculated from cached eigenvalues.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>trace</strong><span class=\"classifier\">array (V, 1)</span></dt><dd><p>Calculated trace.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The trace is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[trace = \\lambda_1 + \\lambda_2 + \\lambda_3\\]</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id496\">\n<h3>check_multi_b<a class=\"headerlink\" href=\"#id496\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.check_multi_b\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">check_multi_b</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">n_bvals</em>, <em class=\"sig-param\">non_zero=True</em>, <em class=\"sig-param\">bmag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.check_multi_b\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Check if you have enough different b-values in your gradient table</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance.</span></dt><dd></dd>\n<dt><strong>n_bvals</strong><span class=\"classifier\">int</span></dt><dd><p>The number of different b-values you are checking for.</p>\n</dd>\n<dt><strong>non_zero</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to check only non-zero bvalues. In this case, we will require\nat least <cite>n_bvals</cite> <em>non-zero</em> b-values (where non-zero is defined\ndepending on the <cite>gtab</cite> object\u2019s <cite>b0_threshold</cite> attribute)</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude of the b-values used. The function will\nnormalize the b-values relative <span class=\"math notranslate nohighlight\">\\(10^{bmag}\\)</span>. Default: derive this\nvalue from the maximal b-value provided:\n<span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>bool</strong><span class=\"classifier\">Whether there are at least <cite>n_bvals</cite> different b-values in the</span></dt><dd></dd>\n<dt>gradient table used.</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"cholesky-to-lower-triangular\">\n<h3>cholesky_to_lower_triangular<a class=\"headerlink\" href=\"#cholesky-to-lower-triangular\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.cholesky_to_lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">cholesky_to_lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">R</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.cholesky_to_lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert Cholesky decompostion elements to the diffusion tensor elements</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>R</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>Array containing the six Cholesky\u2019s decomposition elements\n(R0, R1, R2, R3, R4, R5) <a class=\"reference internal\" href=\"#r3e5c58668b7e-1\" id=\"id497\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tensor_elements</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor\u2019s lower\ntriangular.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3e5c58668b7e-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id497\">1</a></span></dt>\n<dd><p>Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,\nMeyerand, M.E., 2006. Investigation of anomalous estimates of\ntensor-derived quantities in diffusion tensor imaging. Magnetic\nResonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id499\">\n<h3>decompose_tensor<a class=\"headerlink\" href=\"#id499\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.decompose_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">decompose_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">min_diffusivity=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.decompose_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns eigenvalues and eigenvectors given a diffusion tensor</p>\n<p>Computes tensor eigen decomposition to calculate eigenvalues and\neigenvectors (Basser et al., 1994a).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Hermitian matrix representing a diffusion tensor.</p>\n</dd>\n<dt><strong>min_diffusivity</strong><span class=\"classifier\">float</span></dt><dd><p>Because negative eigenvalues are not physical and small eigenvalues,\nmuch smaller than the diffusion weighting, cause quite a lot of noise\nin metrics such as fa, diffusivity values smaller than\n<cite>min_diffusivity</cite> are replaced with <cite>min_diffusivity</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eigvals</strong><span class=\"classifier\">array (\u2026, 3)</span></dt><dd><p>Eigenvalues from eigen decomposition of the tensor. Negative\neigenvalues are replaced by zero. Sorted from largest to smallest.</p>\n</dd>\n<dt><strong>eigvecs</strong><span class=\"classifier\">array (\u2026, 3, 3)</span></dt><dd><p>Associated eigenvectors from eigen decomposition of the tensor.\nEigenvectors are columnar (e.g. eigvecs[\u2026, :, j] is associated with\neigvals[\u2026, j])</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id500\">\n<h3>design_matrix<a class=\"headerlink\" href=\"#id500\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for DTI weighted least squares or\nleast squares fitting. (Basser et al., 1994a)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">A GradientTable class instance</span></dt><dd></dd>\n<dt><strong>dtype</strong><span class=\"classifier\">string</span></dt><dd><p>Parameter to control the dtype of returned designed matrix</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model\ndesign_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id501\">\n<h3>from_lower_triangular<a class=\"headerlink\" href=\"#id501\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.from_lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">from_lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.from_lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns a tensor given the six unique tensor elements</p>\n<p>Given the six unique tensor elements (in the order: Dxx, Dxy, Dyy, Dxz,\nDyz, Dzz) returns a 3 by 3 tensor. All elements after the sixth are\nignored.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">array_like, (\u2026, &gt;6)</span></dt><dd><p>Unique elements of the tensors</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">ndarray (\u2026, 3, 3)</span></dt><dd><p>3 by 3 tensors</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fwdti-prediction\">\n<h3>fwdti_prediction<a class=\"headerlink\" href=\"#fwdti-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.fwdti_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">fwdti_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1</em>, <em class=\"sig-param\">Diso=0.003</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.fwdti_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Signal prediction given the free water DTI model parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">(\u2026, 13) ndarray</span></dt><dd><p>Model parameters. The last dimension should have the 12 tensor\nparameters (3 eigenvalues, followed by the 3 corresponding\neigenvectors) and the volume fraction of the free water compartment.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n<dt><strong>Diso</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3\n<span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>. Please adjust this value if you are assuming different\nunits of diffusion.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated signal based on the free water DTI model</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:\n<span class=\"math notranslate nohighlight\">\\(S(\\theta, b) = S_0 * [(1-f) * e^{-b ADC} + f * e^{-b D_{iso}]\\)</span>, where\n<span class=\"math notranslate nohighlight\">\\(ADC = \\theta Q \\theta^T\\)</span>, <span class=\"math notranslate nohighlight\">\\(\\theta\\)</span> is a unit vector pointing at any\ndirection on the sphere for which a signal is to be predicted, <span class=\"math notranslate nohighlight\">\\(b\\)</span> is the b\nvalue provided in the GradientTable input for that direction, <span class=\"math notranslate nohighlight\">\\(Q\\)</span> is the\nquadratic form of the tensor determined by the input parameters, <span class=\"math notranslate nohighlight\">\\(f\\)</span> is the\nfree water diffusion compartment, <span class=\"math notranslate nohighlight\">\\(D_{iso}\\)</span> is the free water diffusivity\nwhich is equal to $3 * 10^{-3} mm^{2}s^{-1} <a class=\"reference internal\" href=\"#r20a3e875d073-1\" id=\"id502\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r20a3e875d073-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id502\">1</a></span></dt>\n<dd><p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,\nPeterson E.T., Correia, M.M., 2017. [Re] Optimization of a free\nwater elimination two-compartment model for diffusion tensor\nimaging. ReScience volume 3, issue 1, article number 2</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id504\">\n<h3>lower_triangular<a class=\"headerlink\" href=\"#id504\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.lower_triangular\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">lower_triangular</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor</em>, <em class=\"sig-param\">b0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.lower_triangular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the six lower triangular values of the tensor and a dummy variable\nif b0 is not None</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor</strong><span class=\"classifier\">array_like (\u2026, 3, 3)</span></dt><dd><p>a collection of 3, 3 diffusion tensors</p>\n</dd>\n<dt><strong>b0</strong><span class=\"classifier\">float</span></dt><dd><p>if b0 is not none log(b0) is returned as the dummy variable</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>D</strong><span class=\"classifier\">ndarray</span></dt><dd><p>If b0 is none, then the shape will be (\u2026, 6) otherwise (\u2026, 7)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lower-triangular-to-cholesky\">\n<h3>lower_triangular_to_cholesky<a class=\"headerlink\" href=\"#lower-triangular-to-cholesky\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.lower_triangular_to_cholesky\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">lower_triangular_to_cholesky</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tensor_elements</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.lower_triangular_to_cholesky\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs Cholesky decomposition of the diffusion tensor</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tensor_elements</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>Array containing the six elements of diffusion tensor\u2019s lower\ntriangular.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>cholesky_elements</strong><span class=\"classifier\">array (6,)</span></dt><dd><p>Array containing the six Cholesky\u2019s decomposition elements\n(R0, R1, R2, R3, R4, R5) <a class=\"reference internal\" href=\"#r9884b97dd08e-1\" id=\"id505\">[1]</a>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9884b97dd08e-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id505\">1</a></span></dt>\n<dd><p>Koay, C.G., Carew, J.D., Alexander, A.L., Basser, P.J.,\nMeyerand, M.E., 2006. Investigation of anomalous estimates of\ntensor-derived quantities in diffusion tensor imaging. Magnetic\nResonance in Medicine, 55(4), 930-936. doi:10.1002/mrm.20832</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id507\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id507\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id508\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id508\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nls-fit-tensor\">\n<h3>nls_fit_tensor<a class=\"headerlink\" href=\"#nls-fit-tensor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.nls_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">nls_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">Diso=0.003</em>, <em class=\"sig-param\">mdreg=0.0027</em>, <em class=\"sig-param\">min_signal=1e-06</em>, <em class=\"sig-param\">f_transform=True</em>, <em class=\"sig-param\">cholesky=False</em>, <em class=\"sig-param\">jac=False</em>, <em class=\"sig-param\">weighting=None</em>, <em class=\"sig-param\">sigma=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.nls_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit the water elimination tensor model using the non-linear least-squares.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should\nbe analyzed that has the shape data.shape[:-1]</p>\n</dd>\n<dt><strong>Diso</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3\n<span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>. Please adjust this value if you are assuming different\nunits of diffusion.</p>\n</dd>\n<dt><strong>mdreg</strong><span class=\"classifier\">float, optimal</span></dt><dd><p>DTI\u2019s mean diffusivity regularization threshold. If standard DTI\ndiffusion tensor\u2019s mean diffusivity is almost near the free water\ndiffusion value, the diffusion signal is assumed to be only free water\ndiffusion (i.e. volume fraction will be set to 1 and tissue\u2019s diffusion\nparameters are set to zero). Default md_reg is 2.7e-3 <span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>\n(corresponding to 90% of the free water diffusion value).</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: 1.0e-6.</p>\n</dd>\n<dt><strong>f_transform</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If true, the water volume fractions is converted during the convergence\nprocedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between\n0 and 1.\nDefault: True</p>\n</dd>\n<dt><strong>cholesky</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If true it uses Cholesky decomposition to insure that diffusion tensor\nis positive define.\nDefault: False</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool</span></dt><dd><p>Use the Jacobian? Default: False</p>\n</dd>\n<dt><strong>weighting: str, optional</strong></dt><dd><p>the weighting scheme to use in considering the\nsquared-error. Default behavior is to use uniform weighting. Other\noptions: \u2018sigma\u2019 \u2018gmm\u2019</p>\n</dd>\n<dt><strong>sigma: float, optional</strong></dt><dd><p>If the \u2018sigma\u2019 weighting scheme is used, a value of sigma needs to be\nprovided here. According to <a class=\"reference internal\" href=\"../../examples_built/restore_dti/#chang2005\" id=\"id509\"><span>[Chang2005]</span></a>, a good value to use is\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>fw_params</strong><span class=\"classifier\">ndarray (x, y, z, 13)</span></dt><dd><p>Matrix containing in the dimension the free water model parameters in\nthe following order:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>The volume fraction of the free water compartment</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nls-iter\">\n<h3>nls_iter<a class=\"headerlink\" href=\"#nls-iter\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.nls_iter\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">nls_iter</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">sig</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">Diso=0.003</em>, <em class=\"sig-param\">mdreg=0.0027</em>, <em class=\"sig-param\">min_signal=1e-06</em>, <em class=\"sig-param\">cholesky=False</em>, <em class=\"sig-param\">f_transform=True</em>, <em class=\"sig-param\">jac=False</em>, <em class=\"sig-param\">weighting=None</em>, <em class=\"sig-param\">sigma=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.nls_iter\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies non linear least squares fit of the water free elimination\nmodel to single voxel signals.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>sig</strong><span class=\"classifier\">array (g, )</span></dt><dd><p>Diffusion-weighted signal for a single voxel data.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>Non diffusion weighted signal (i.e. signal for b-value=0).</p>\n</dd>\n<dt><strong>Diso</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3\n<span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>. Please adjust this value if you are assuming different\nunits of diffusion.</p>\n</dd>\n<dt><strong>mdreg</strong><span class=\"classifier\">float, optimal</span></dt><dd><p>DTI\u2019s mean diffusivity regularization threshold. If standard DTI\ndiffusion tensor\u2019s mean diffusivity is almost near the free water\ndiffusion value, the diffusion signal is assumed to be only free water\ndiffusion (i.e. volume fraction will be set to 1 and tissue\u2019s diffusion\nparameters are set to zero). Default md_reg is 2.7e-3 <span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>\n(corresponding to 90% of the free water diffusion value).</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber.</p>\n</dd>\n<dt><strong>cholesky</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If true it uses Cholesky decomposition to insure that diffusion tensor\nis positive define.\nDefault: False</p>\n</dd>\n<dt><strong>f_transform</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If true, the water volume fractions is converted during the convergence\nprocedure to ft = arcsin(2*f - 1) + pi/2, insuring f estimates between\n0 and 1.\nDefault: True</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool</span></dt><dd><p>Use the Jacobian? Default: False</p>\n</dd>\n<dt><strong>weighting: str, optional</strong></dt><dd><p>the weighting scheme to use in considering the\nsquared-error. Default behavior is to use uniform weighting. Other\noptions: \u2018sigma\u2019 \u2018gmm\u2019</p>\n</dd>\n<dt><strong>sigma: float, optional</strong></dt><dd><p>If the \u2018sigma\u2019 weighting scheme is used, a value of sigma needs to be\nprovided here. According to <a class=\"reference internal\" href=\"../../examples_built/restore_dti/#chang2005\" id=\"id510\"><span>[Chang2005]</span></a>, a good value to use is\n1.5267 * std(background_noise), where background_noise is estimated\nfrom some part of the image known to contain no signal (only noise).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>All parameters estimated from the free water tensor model.</dt><dd></dd>\n<dt>Parameters are ordered as follows:</dt><dd><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>The volume fraction of the free water compartment.</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id511\">\n<h3>vec_val_vect<a class=\"headerlink\" href=\"#id511\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.vec_val_vect\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">vec_val_vect</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.vec_val_vect\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Vectorize <cite>vecs</cite>.diag(<cite>vals</cite>).`vecs`.T for last 2 dimensions of <cite>vecs</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">shape (\u2026, M, N) array</span></dt><dd><p>containing tensor in last two dimensions; M, N usually equal to (3, 3)</p>\n</dd>\n<dt><strong>vals</strong><span class=\"classifier\">shape (\u2026, N) array</span></dt><dd><p>diagonal values carried in last dimension, <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> shape above must\nmatch that for <cite>vecs</cite></p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">shape (\u2026, M, M) array</span></dt><dd><p>For all the dimensions ellided by <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code>, loops to get (M, N) <code class=\"docutils literal notranslate\"><span class=\"pre\">vec</span></code>\nmatrix, and (N,) <code class=\"docutils literal notranslate\"><span class=\"pre\">vals</span></code> vector, and calculates\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vec.dot(np.diag(val).dot(vec.T)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-odd\">Raises</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">...</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n<dt><strong>ValueError</strong><span class=\"classifier\">non-matching <code class=\"docutils literal notranslate\"><span class=\"pre\">N</span></code> dimensions of <cite>vecs</cite>, <cite>vals</cite></span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Make a 3D array where the first dimension is only 1</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vec_val_vect</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">vals</span><span class=\"p\">)</span>\n<span class=\"go\">array([[[   9.,   24.,   39.],</span>\n<span class=\"go\">        [  24.,   66.,  108.],</span>\n<span class=\"go\">        [  39.,  108.,  177.]]])</span>\n</pre></div>\n</div>\n<p>That\u2019s the same as the 2D case (apart from the float casting):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">),</span> <span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">))</span>\n<span class=\"go\">array([[  9,  24,  39],</span>\n<span class=\"go\">       [ 24,  66, 108],</span>\n<span class=\"go\">       [ 39, 108, 177]])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id512\">\n<h3>wls_fit_tensor<a class=\"headerlink\" href=\"#id512\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.wls_fit_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">wls_fit_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">Diso=0.003</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">min_signal=1e-06</em>, <em class=\"sig-param\">piterations=3</em>, <em class=\"sig-param\">mdreg=0.0027</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.wls_fit_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes weighted least squares (WLS) fit to calculate self-diffusion\ntensor using a linear regression model <a class=\"reference internal\" href=\"#r78c063b823b9-1\" id=\"id513\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026], g)</span></dt><dd><p>Data or response variables holding the data. Note that the last\ndimension should contain the data. It makes no copies of data.</p>\n</dd>\n<dt><strong>Diso</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Value of the free water isotropic diffusion. Default is set to 3e-3\n<span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>. Please adjust this value if you are assuming different\nunits of diffusion.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should\nbe analyzed that has the shape data.shape[:-1]</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: 1.0e-6.</p>\n</dd>\n<dt><strong>piterations</strong><span class=\"classifier\">inter, optional</span></dt><dd><p>Number of iterations used to refine the precision of f. Default is set\nto 3 corresponding to a precision of 0.01.</p>\n</dd>\n<dt><strong>mdreg</strong><span class=\"classifier\">float, optimal</span></dt><dd><p>DTI\u2019s mean diffusivity regularization threshold. If standard DTI\ndiffusion tensor\u2019s mean diffusivity is almost near the free water\ndiffusion value, the diffusion signal is assumed to be only free water\ndiffusion (i.e. volume fraction will be set to 1 and tissue\u2019s diffusion\nparameters are set to zero). Default md_reg is 2.7e-3 <span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>\n(corresponding to 90% of the free water diffusion value).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>fw_params</strong><span class=\"classifier\">ndarray (x, y, z, 13)</span></dt><dd><p>Matrix containing in the last dimension the free water model parameters\nin the following order:</p>\n<blockquote>\n<div><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>The volume fraction of the free water compartment.</p></li>\n</ol>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r78c063b823b9-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id32\">1</a>,<a href=\"#id513\">2</a>)</span></dt>\n<dd><p>Henriques, R.N., Rokem, A., Garyfallidis, E., St-Jean, S.,\nPeterson E.T., Correia, M.M., 2017. [Re] Optimization of a free\nwater elimination two-compartment model for diffusion tensor\nimaging. ReScience volume 3, issue 1, article number 2</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wls-iter\">\n<h3>wls_iter<a class=\"headerlink\" href=\"#wls-iter\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.fwdti.wls_iter\">\n<code class=\"sig-prename descclassname\">dipy.reconst.fwdti.</code><code class=\"sig-name descname\">wls_iter</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">sig</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">Diso=0.003</em>, <em class=\"sig-param\">mdreg=0.0027</em>, <em class=\"sig-param\">min_signal=1e-06</em>, <em class=\"sig-param\">piterations=3</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.fwdti.wls_iter\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies weighted linear least squares fit of the water free elimination\nmodel to single voxel signals.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g, 7)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients.</p>\n</dd>\n<dt><strong>sig</strong><span class=\"classifier\">array (g, )</span></dt><dd><p>Diffusion-weighted signal for a single voxel data.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>Non diffusion weighted signal (i.e. signal for b-value=0).</p>\n</dd>\n<dt><strong>Diso</strong><span class=\"classifier\">float, optional</span></dt><dd><blockquote>\n<div><p>Value of the free water isotropic diffusion. Default is set to 3e-3\n<span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>. Please adjust this value if you are assuming different\nunits of diffusion.</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>mdreg<span class=\"classifier\">float, optimal</span></dt><dd><p>DTI\u2019s mean diffusivity regularization threshold. If standard DTI\ndiffusion tensor\u2019s mean diffusivity is almost near the free water\ndiffusion value, the diffusion signal is assumed to be only free water\ndiffusion (i.e. volume fraction will be set to 1 and tissue\u2019s diffusion\nparameters are set to zero). Default md_reg is 2.7e-3 <span class=\"math notranslate nohighlight\">\\(mm^{2}.s^{-1}\\)</span>\n(corresponding to 90% of the free water diffusion value).</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: minimal signal in the data provided to <cite>fit</cite>.</p>\n</dd>\n<dt><strong>piterations</strong><span class=\"classifier\">inter, optional</span></dt><dd><p>Number of iterations used to refine the precision of f. Default is set\nto 3 corresponding to a precision of 0.01.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>All parameters estimated from the free water tensor model.</dt><dd></dd>\n<dt>Parameters are ordered as follows:</dt><dd><ol class=\"arabic simple\">\n<li><p>Three diffusion tensor\u2019s eigenvalues</p></li>\n<li><p>Three lines of the eigenvector matrix each containing the\nfirst, second and third coordinates of the eigenvector</p></li>\n<li><p>The volume fraction of the free water compartment</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id515\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.gqi.Cache\" title=\"dipy.reconst.gqi.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id515\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.gqi.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.gqi.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.Cache.cache_clear\" title=\"dipy.reconst.gqi.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.Cache.cache_get\" title=\"dipy.reconst.gqi.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.Cache.cache_set\" title=\"dipy.reconst.gqi.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"generalizedqsamplingfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit\" title=\"dipy.reconst.gqi.GeneralizedQSamplingFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingFit</span></code></a><a class=\"headerlink\" href=\"#generalizedqsamplingfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">GeneralizedQSamplingFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit.odf\" title=\"dipy.reconst.gqi.GeneralizedQSamplingFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>Calculates the discrete ODF for a given discrete sphere.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates PDF and ODF for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>DiffusionSpectrumModel</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>signal values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the discrete ODF for a given discrete sphere.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"generalizedqsamplingmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel\" title=\"dipy.reconst.gqi.GeneralizedQSamplingModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingModel</span></code></a><a class=\"headerlink\" href=\"#generalizedqsamplingmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">GeneralizedQSamplingModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">method='gqi2'</em>, <em class=\"sig-param\">sampling_length=1.2</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel.fit\" title=\"dipy.reconst.gqi.GeneralizedQSamplingModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">method='gqi2'</em>, <em class=\"sig-param\">sampling_length=1.2</em>, <em class=\"sig-param\">normalize_peaks=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized Q-Sampling Imaging <a class=\"reference internal\" href=\"#r92e3dfdc494f-1\" id=\"id516\">[1]</a></p>\n<p>This model has the same assumptions as the DSI method i.e. Cartesian\ngrid sampling in q-space and fast gradient switching.</p>\n<p>Implements equations 2.14 from <a class=\"reference internal\" href=\"#r92e3dfdc494f-2\" id=\"id517\">[2]</a> for standard GQI and equation 2.16\nfrom <a class=\"reference internal\" href=\"#r92e3dfdc494f-2\" id=\"id518\">[2]</a> for GQI2. You can think of GQI2 as an analytical solution of\nthe DSI ODF.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">object,</span></dt><dd><p>GradientTable</p>\n</dd>\n<dt><strong>method</strong><span class=\"classifier\">str,</span></dt><dd><p>\u2018standard\u2019 or \u2018gqi2\u2019</p>\n</dd>\n<dt><strong>sampling_length</strong><span class=\"classifier\">float,</span></dt><dd><p>diffusion sampling length (lambda in eq. 2.14 and 2.16)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.dsi.DiffusionSpectrumModel\" title=\"dipy.reconst.dsi.DiffusionSpectrumModel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dipy.reconst.dsi.DiffusionSpectrumModel</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>As of version 0.9, range of the sampling length in GQI2 has changed\nto match the same scale used in the \u2018standard\u2019 method <a class=\"reference internal\" href=\"#r92e3dfdc494f-1\" id=\"id519\">[1]</a>. This\nmeans that the value of <cite>sampling_length</cite> should be approximately\n1 - 1.3 (see <a class=\"reference internal\" href=\"#r92e3dfdc494f-1\" id=\"id520\">[1]</a>, pg. 1628).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r92e3dfdc494f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id516\">1</a>,<a href=\"#id519\">2</a>,<a href=\"#id520\">3</a>)</span></dt>\n<dd><p>Yeh F-C et al., \u201cGeneralized Q-Sampling Imaging\u201d, IEEE TMI, 2010</p>\n</dd>\n<dt class=\"label\" id=\"r92e3dfdc494f-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id517\">1</a>,<a href=\"#id518\">2</a>)</span></dt>\n<dd><p>Garyfallidis E, \u201cTowards an accurate brain tractography\u201d, PhD</p>\n</dd>\n</dl>\n<p>thesis, University of Cambridge, 2012.</p>\n<p class=\"rubric\">Examples</p>\n<p>Here we create an example where we provide the data, a gradient table\nand a reconstruction sphere and calculate the ODF for the first\nvoxel in the data.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">dsi_voxels</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">dsi_voxels</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.subdivide_octahedron</span> <span class=\"k\">import</span> <span class=\"n\">create_unit_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">create_unit_sphere</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.gqi</span> <span class=\"k\">import</span> <span class=\"n\">GeneralizedQSamplingModel</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gq</span> <span class=\"o\">=</span> <span class=\"n\">GeneralizedQSamplingModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"s1\">&#39;gqi2&#39;</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">voxel_signal</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">odf</span> <span class=\"o\">=</span> <span class=\"n\">gq</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">voxel_signal</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.GeneralizedQSamplingModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.GeneralizedQSamplingModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id523\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfFit\" title=\"dipy.reconst.gqi.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a><a class=\"headerlink\" href=\"#id523\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.gqi.OdfFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">OdfFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfFit.odf\" title=\"dipy.reconst.gqi.OdfFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>To be implemented but specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.OdfFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.OdfFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented but specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id524\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfModel\" title=\"dipy.reconst.gqi.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a><a class=\"headerlink\" href=\"#id524\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.gqi.OdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">OdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>An abstract class to be sub-classed by specific odf models</p>\n<p>All odf models should provide a fit method which may take data as it\u2019s\nfirst and only argument.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.gqi.OdfModel.fit\" title=\"dipy.reconst.gqi.OdfModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.OdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.gqi.OdfModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.OdfModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented by specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"equatorial-maximum\">\n<h3>equatorial_maximum<a class=\"headerlink\" href=\"#equatorial-maximum\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.equatorial_maximum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">equatorial_maximum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">odf</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.equatorial_maximum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"equatorial-zone-vertices\">\n<h3>equatorial_zone_vertices<a class=\"headerlink\" href=\"#equatorial-zone-vertices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.equatorial_zone_vertices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">equatorial_zone_vertices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width=5</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.equatorial_zone_vertices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>finds the \u2018vertices\u2019 in the equatorial zone conjugate\nto \u2018pole\u2019 with width half \u2018width\u2019 degrees</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gfa\">\n<h3>gfa<a class=\"headerlink\" href=\"#gfa\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.gfa\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">gfa</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">samples</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.gfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The general fractional anisotropy of a function evaluated\non the unit sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>samples</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Values of data on the unit sphere.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gfa</strong><span class=\"classifier\">ndarray</span></dt><dd><p>GFA evaluated in each entry of the array, along the last dimension.\nAn <cite>np.nan</cite> is returned for coordinates that contain all-zeros in\n<cite>samples</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The GFA is defined as <a class=\"reference internal\" href=\"#r63839d04855f-1\" id=\"id525\">[1]</a></p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>\\<span class=\"n\">sqrt</span><span class=\"p\">{</span>\\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"n\">n</span> \\<span class=\"n\">sum_i</span><span class=\"p\">{(</span>\\<span class=\"n\">Psi_i</span> <span class=\"o\">-</span> <span class=\"o\">&lt;</span>\\<span class=\"n\">Psi</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"o\">^</span><span class=\"mi\">2</span><span class=\"p\">}}{(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> \\<span class=\"nb\">sum</span><span class=\"p\">{</span>\\<span class=\"n\">Psi_i</span> <span class=\"o\">^</span> <span class=\"mi\">2</span><span class=\"p\">}}}</span>\n</pre></div>\n</div>\n<p>Where <span class=\"math notranslate nohighlight\">\\(\\Psi\\)</span> is an orientation distribution function sampled discretely on\nthe unit sphere and angle brackets denote average over the samples on the\nsphere.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r63839d04855f-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id525\">1</a></span></dt>\n<dd><p>Quality assessment of High Angular Resolution Diffusion Imaging\ndata using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.\nDescoteaux, L.L. Wald. JMRI 33: 1194-1208.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id526\">\n<h3>local_maxima<a class=\"headerlink\" href=\"#id526\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.local_maxima\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">local_maxima</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.local_maxima\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Local maxima of a function evaluated on a discrete set of points.</p>\n<p>If a function is evaluated on some set of points where each pair of\nneighboring points is an edge in edges, find the local maxima.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">array, 1d, dtype=double</span></dt><dd><p>The function evaluated on a set of discrete points.</p>\n</dd>\n<dt><strong>edges</strong><span class=\"classifier\">array (N, 2)</span></dt><dd><p>The set of neighbor relations between the points. Every edge, ie\n<cite>edges[i, :]</cite>, is a pair of neighboring points.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>peak_values</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Value of odf at a maximum point. Peak values is sorted in descending\norder.</p>\n</dd>\n<dt><strong>peak_indices</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Indices of maximum points. Sorted in the same order as <cite>peak_values</cite> so\n<cite>odf[peak_indices[i]] == peak_values[i]</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"../dipy.core/#module-dipy.core.sphere\" title=\"dipy.core.sphere\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dipy.core.sphere</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>A point is a local maximum if it is &gt; at least one neighbor and &gt;= all\nneighbors. If no points meet the above criteria, 1 maximum is returned such\nthat <cite>odf[maximum] == max(odf)</cite>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id527\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id527\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"normalize-qa\">\n<h3>normalize_qa<a class=\"headerlink\" href=\"#normalize-qa\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.normalize_qa\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">normalize_qa</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">qa</em>, <em class=\"sig-param\">max_qa=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.normalize_qa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Normalize quantitative anisotropy.</p>\n<p>Used mostly with GQI rather than GQI2.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>qa</strong><span class=\"classifier\">array, shape (X, Y, Z, N)</span></dt><dd><p>where N is the maximum number of peaks stored</p>\n</dd>\n<dt><strong>max_qa</strong><span class=\"classifier\">float,</span></dt><dd><p>maximum qa value. Usually found in the CSF (corticospinal fluid).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>nqa</strong><span class=\"classifier\">array, shape (x, Y, Z, N)</span></dt><dd><p>normalized quantitative anisotropy</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Normalized quantitative anisotropy has the very useful property\nto be very small near gray matter and background areas. Therefore,\nit can be used to mask out white matter areas.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"npa\">\n<h3>npa<a class=\"headerlink\" href=\"#npa\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.npa\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">npa</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">self</em>, <em class=\"sig-param\">odf</em>, <em class=\"sig-param\">width=5</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.npa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>non-parametric anisotropy</p>\n<p>Nimmo-Smith et al.  ISMRM 2011</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"odf-sum\">\n<h3>odf_sum<a class=\"headerlink\" href=\"#odf-sum\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.odf_sum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">odf_sum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">odf</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.odf_sum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"patch-maximum\">\n<h3>patch_maximum<a class=\"headerlink\" href=\"#patch-maximum\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.patch_maximum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">patch_maximum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">odf</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.patch_maximum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"patch-sum\">\n<h3>patch_sum<a class=\"headerlink\" href=\"#patch-sum\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.patch_sum\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">patch_sum</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">odf</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.patch_sum\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"patch-vertices\">\n<h3>patch_vertices<a class=\"headerlink\" href=\"#patch-vertices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.patch_vertices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">patch_vertices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.patch_vertices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>find \u2018vertices\u2019 within the cone of \u2018width\u2019 degrees around \u2018pole\u2019</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"polar-zone-vertices\">\n<h3>polar_zone_vertices<a class=\"headerlink\" href=\"#polar-zone-vertices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.polar_zone_vertices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">polar_zone_vertices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">pole</em>, <em class=\"sig-param\">width=5</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.polar_zone_vertices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>finds the \u2018vertices\u2019 in the equatorial band around\nthe \u2018pole\u2019 of radius \u2018width\u2019 degrees</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"remove-similar-vertices\">\n<h3>remove_similar_vertices<a class=\"headerlink\" href=\"#remove-similar-vertices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.remove_similar_vertices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">remove_similar_vertices</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.remove_similar_vertices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Remove vertices that are less than <cite>theta</cite> degrees from any other</p>\n<p>Returns vertices that are at least theta degrees from any other vertex.\nVertex v and -v are considered the same so if v and -v are both in\n<cite>vertices</cite> only one is kept. Also if v and w are both in vertices, w must\nbe separated by theta degrees from both v and -v to be unique.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>vertices</strong><span class=\"classifier\">(N, 3) ndarray</span></dt><dd><p>N unit vectors.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum separation between vertices in degrees.</p>\n</dd>\n<dt><strong>return_mapping</strong><span class=\"classifier\">{False, True}, optional</span></dt><dd><p>If True, return <cite>mapping</cite> as well as <cite>vertices</cite> and maybe <cite>indices</cite>\n(see below).</p>\n</dd>\n<dt><strong>return_indices</strong><span class=\"classifier\">{False, True}, optional</span></dt><dd><p>If True, return <cite>indices</cite> as well as <cite>vertices</cite> and maybe <cite>mapping</cite>\n(see below).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>unique_vertices</strong><span class=\"classifier\">(M, 3) ndarray</span></dt><dd><p>Vertices sufficiently separated from one another.</p>\n</dd>\n<dt><strong>mapping</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>For each element <code class=\"docutils literal notranslate\"><span class=\"pre\">vertices[i]</span></code> (<span class=\"math notranslate nohighlight\">\\(i \\in 0..N-1\\)</span>), the index <span class=\"math notranslate nohighlight\">\\(j\\)</span> to a\nvertex in <cite>unique_vertices</cite> that is less than <cite>theta</cite> degrees from\n<code class=\"docutils literal notranslate\"><span class=\"pre\">vertices[i]</span></code>.  Only returned if <cite>return_mapping</cite> is True.</p>\n</dd>\n<dt><strong>indices</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p><cite>indices</cite> gives the reverse of <cite>mapping</cite>.  For each element\n<code class=\"docutils literal notranslate\"><span class=\"pre\">unique_vertices[j]</span></code> (<span class=\"math notranslate nohighlight\">\\(j \\in 0..M-1\\)</span>), the index <span class=\"math notranslate nohighlight\">\\(i\\)</span> to a vertex in\n<cite>vertices</cite> that is less than <cite>theta</cite> degrees from\n<code class=\"docutils literal notranslate\"><span class=\"pre\">unique_vertices[j]</span></code>.  If there is more than one element of\n<cite>vertices</cite> that is less than theta degrees from <cite>unique_vertices[j]</cite>,\nreturn the first (lowest index) matching value.  Only return if\n<cite>return_indices</cite> is True.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"squared-radial-component\">\n<h3>squared_radial_component<a class=\"headerlink\" href=\"#squared-radial-component\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.squared_radial_component\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">squared_radial_component</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">tol=0.01</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.squared_radial_component\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Part of the GQI2 integral</p>\n<p>Eq.8 in the referenced paper by Yeh et al. 2010</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"triple-odf-maxima\">\n<h3>triple_odf_maxima<a class=\"headerlink\" href=\"#triple-odf-maxima\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.triple_odf_maxima\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">triple_odf_maxima</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vertices</em>, <em class=\"sig-param\">odf</em>, <em class=\"sig-param\">width</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.triple_odf_maxima\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"upper-hemi-map\">\n<h3>upper_hemi_map<a class=\"headerlink\" href=\"#upper-hemi-map\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.gqi.upper_hemi_map\">\n<code class=\"sig-prename descclassname\">dipy.reconst.gqi.</code><code class=\"sig-name descname\">upper_hemi_map</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">v</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.gqi.upper_hemi_map\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>maps a 3-vector into the z-upper hemisphere</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivimfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimFit\" title=\"dipy.reconst.ivim.IvimFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimFit</span></code></a><a class=\"headerlink\" href=\"#ivimfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.ivim.IvimFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">IvimFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>D</strong></dt><dd></dd>\n<dt><strong>D_star</strong></dt><dd></dd>\n<dt><strong>S0_predicted</strong></dt><dd></dd>\n<dt><strong>perfusion_fraction</strong></dt><dd></dd>\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimFit.predict\" title=\"dipy.reconst.ivim.IvimFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a model fit, predict the signal.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a IvimFit class instance.\nParameters\n\u2014\u2014\u2014-\nmodel : Model class\nmodel_params : array</p>\n<blockquote>\n<div><p>The parameters of the model. In this case it is an\narray of ivim parameters. If the fitting is done\nfor multi_voxel data, the multi_voxel decorator will\nrun the fitting on all the voxels and model_params\nwill be an array of the dimensions (data[:-1], 4),\ni.e., there will be 4 parameters for each of the voxels.</p>\n</div></blockquote>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.D\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">D</code><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.D\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.D_star\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">D_star</code><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.D_star\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.S0_predicted\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">S0_predicted</code><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.S0_predicted\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.perfusion_fraction\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">perfusion_fraction</code><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.perfusion_fraction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a model fit, predict the signal.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>S0 value here is not necessary and will not be used to predict the\nsignal. It has been added to conform to the structure of the\npredict method in multi_voxel which requires a keyword argument S0.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>The signal values predicted for this model using its parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivimmodeltrr\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR\" title=\"dipy.reconst.ivim.IvimModelTRR\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimModelTRR</span></code></a><a class=\"headerlink\" href=\"#ivimmodeltrr\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">IvimModelTRR</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab, split_b_D=400.0, split_b_S0=200.0, bounds=None, two_stage=True, tol=1e-15, x_scale=[1000.0, 0.1, 0.001, 0.0001], gtol=1e-15, ftol=1e-15, eps=1e-15, maxiter=1000</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Ivim model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star\" title=\"dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_f_D_star</span></code></a>(params_f_D_star,\u00a0data,\u00a0S0,\u00a0D)</p></td>\n<td><p>Estimate f and D_star using the values of all the other parameters obtained from a linear fit.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit\" title=\"dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">estimate_linear_fit</span></code></a>(data,\u00a0split_b[,\u00a0less_than])</p></td>\n<td><p>Estimate a linear fit by taking log of data.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR.fit\" title=\"dipy.reconst.ivim.IvimModelTRR.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelTRR.predict\" title=\"dipy.reconst.ivim.IvimModelTRR.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(ivim_params,\u00a0gtab[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this IvimModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab, split_b_D=400.0, split_b_S0=200.0, bounds=None, two_stage=True, tol=1e-15, x_scale=[1000.0, 0.1, 0.001, 0.0001], gtol=1e-15, ftol=1e-15, eps=1e-15, maxiter=1000</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IVIM model.</p>\n<p>The IVIM model assumes that biological tissue includes a volume\nfraction \u2018f\u2019 of water flowing with a pseudo-diffusion coefficient\nD* and a fraction (1-f) of static (diffusion only), intra and\nextracellular water, with a diffusion coefficient D. In this model\nthe echo attenuation of a signal in a single voxel can be written as</p>\n<blockquote>\n<div><div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<p>S(b) = S_0[f*e^{(-b*D*)} + (1-f)e^{(-b*D)}]</p>\n<p>Where:\n.. math:</p>\n<p>S_0, f, D* and D are the IVIM parameters.</p>\n</div></blockquote>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues</p>\n</dd>\n<dt><strong>split_b_D</strong><span class=\"classifier\">float, optional</span></dt><dd><p>The b-value to split the data on for two-stage fit. This will be\nused while estimating the value of D. The assumption is that at\nhigher b values the effects of perfusion is less and hence the\nsignal can be approximated as a mono-exponential decay.\ndefault : 400.</p>\n</dd>\n<dt><strong>split_b_S0</strong><span class=\"classifier\">float, optional</span></dt><dd><p>The b-value to split the data on for two-stage fit for estimation\nof S0 and initial guess for D_star. The assumption here is that\nat low bvalues the effects of perfusion are more.\ndefault : 200.</p>\n</dd>\n<dt><strong>bounds</strong><span class=\"classifier\">tuple of arrays with 4 elements, optional</span></dt><dd><p>Bounds to constrain the fitted model parameters. This is only\nsupported for Scipy version &gt; 0.17. When using a older Scipy\nversion, this function will raise an error if bounds are different\nfrom None. This parameter is also used to fill nan values for out\nof bounds parameters in the <cite>IvimFit</cite> class using the method\nfill_na. default : ([0., 0., 0., 0.], [np.inf, .3, 1., 1.])</p>\n</dd>\n<dt><strong>two_stage</strong><span class=\"classifier\">bool</span></dt><dd><p>Argument to specify whether to perform a non-linear fitting of all\nparameters after the linear fitting by splitting the data based on\nbvalues. This gives more accurate parameters but takes more time.\nThe linear fit can be used to get a quick estimation of the\nparameters. default : False</p>\n</dd>\n<dt><strong>tol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Tolerance for convergence of minimization.\ndefault : 1e-15</p>\n</dd>\n<dt><strong>x_scale</strong><span class=\"classifier\">array, optional</span></dt><dd><p>Scaling for the parameters. This is passed to <cite>least_squares</cite> which\nis only available for Scipy version &gt; 0.17.\ndefault: [1000, 0.01, 0.001, 0.0001]</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Tolerance for termination by the norm of the gradient.\ndefault : 1e-15</p>\n</dd>\n<dt><strong>ftol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Tolerance for termination by the change of the cost function.\ndefault : 1e-15</p>\n</dd>\n<dt><strong>eps</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Step size used for numerical approximation of the jacobian.\ndefault : 1e-15</p>\n</dd>\n<dt><strong>maxiter</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum number of iterations to perform.\ndefault : 1000</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r63a79b031be7-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Le Bihan, Denis, et al. \u201cSeparation of diffusion and perfusion\nin intravoxel incoherent motion MR imaging.\u201d Radiology 168.2\n(1988): 497-505.</p>\n</dd>\n<dt class=\"label\" id=\"r63a79b031be7-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Federau, Christian, et al. \u201cQuantitative measurement of brain\nperfusion with intravoxel incoherent motion MR imaging.\u201d\nRadiology 265.3 (2012): 874-881.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star\">\n<code class=\"sig-name descname\">estimate_f_D_star</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params_f_D_star</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR.estimate_f_D_star\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Estimate f and D_star using the values of all the other parameters\nobtained from a linear fit.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params_f_D_star: array</strong></dt><dd><p>An array containing the value of f and D_star.</p>\n</dd>\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>Array containing the actual signal values.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>\n</dd>\n<dt><strong>D</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>f</strong><span class=\"classifier\">float</span></dt><dd><p>Perfusion fraction estimated from the fit.</p>\n</dd>\n<dt>D_star :</dt><dd><p>The value of D_star estimated from the fit.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit\">\n<code class=\"sig-name descname\">estimate_linear_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">split_b</em>, <em class=\"sig-param\">less_than=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR.estimate_linear_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Estimate a linear fit by taking log of data.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>An array containing the data to be fit</p>\n</dd>\n<dt><strong>split_b</strong><span class=\"classifier\">float</span></dt><dd><p>The b value to split the data</p>\n</dd>\n<dt><strong>less_than</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, splitting occurs for bvalues less than split_b</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>The estimated S0 value. (intercept)</p>\n</dd>\n<dt><strong>D</strong><span class=\"classifier\">float</span></dt><dd><p>The estimated value of D.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelTRR.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ivim_params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelTRR.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this IvimModel class instance given parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ivim_params</strong><span class=\"classifier\">array</span></dt><dd><p>The ivim parameters as an array [S0, f, D_star and D]</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This has been added just for consistency with the existing\nAPI. Unlike other models, IVIM predicts S0 and this is over written\nby the S0 value in params.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>ivim_signal</strong><span class=\"classifier\">array</span></dt><dd><p>The predicted IVIM signal using given parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivimmodelvp\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP\" title=\"dipy.reconst.ivim.IvimModelVP\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimModelVP</span></code></a><a class=\"headerlink\" href=\"#ivimmodelvp\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">IvimModelVP</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">bounds=None</em>, <em class=\"sig-param\">maxiter=10</em>, <em class=\"sig-param\">xtol=1e-08</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.cvx_fit\" title=\"dipy.reconst.ivim.IvimModelVP.cvx_fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cvx_fit</span></code></a>(signal,\u00a0phi)</p></td>\n<td><p>Performs the constrained search for the linear parameters <cite>f</cite> after the estimation of <cite>x</cite> is done.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.fit\" title=\"dipy.reconst.ivim.IvimModelVP.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one\" title=\"dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ivim_mix_cost_one</span></code></a>(phi,\u00a0signal)</p></td>\n<td><p>Constructs the objective for the :func: <cite>stoc_search_cost</cite>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.nlls_cost\" title=\"dipy.reconst.ivim.IvimModelVP.nlls_cost\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nlls_cost</span></code></a>(x_f,\u00a0signal)</p></td>\n<td><p>Cost function for the least square problem.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.phi\" title=\"dipy.reconst.ivim.IvimModelVP.phi\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">phi</span></code></a>(x)</p></td>\n<td><p>Creates a structure for the combining the diffusion and pseudo- diffusion by multipling with the bvals and then exponentiating each of the two components for fitting as per the IVIM- two compartment model.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.stoc_search_cost\" title=\"dipy.reconst.ivim.IvimModelVP.stoc_search_cost\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">stoc_search_cost</span></code></a>(x,\u00a0signal)</p></td>\n<td><p>Cost function for differential evolution algorithm.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f\" title=\"dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">x_and_f_to_x_f</span></code></a>(x,\u00a0f)</p></td>\n<td><p>Combines the array of parameters \u2018x\u2019 and \u2018f\u2019 into x_f for performing NLLS on the final stage of optimization.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f\" title=\"dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">x_f_to_x_and_f</span></code></a>(x_f)</p></td>\n<td><p>Splits the array of parameters in x_f to \u2018x\u2019 and \u2018f\u2019 for performing a search on the both of them independently using the Trust Region Method.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">bounds=None</em>, <em class=\"sig-param\">maxiter=10</em>, <em class=\"sig-param\">xtol=1e-08</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IvimModelVP class.</p>\n<p>The IVIM model assumes that biological tissue includes a volume\nfraction \u2018f\u2019 of water flowing with a pseudo-diffusion coefficient\nD* and a fraction (1-f: treated as a separate fraction in the variable\nprojection method) of static (diffusion only), intra and\nextracellular water, with a diffusion coefficient D. In this model\nthe echo attenuation of a signal in a single voxel can be written as</p>\n<blockquote>\n<div><div class=\"math notranslate nohighlight\">\n\\[\\]</div>\n<p>S(b) = S_0*[f*e^{(-b*D*)} + (1-f)e^{(-b*D)}]</p>\n<p>Where:\n.. math:</p>\n<p>S_0, f, D* and D are the IVIM parameters.</p>\n</div></blockquote>\n<dl class=\"simple\">\n<dt>maxiter: int, optional</dt><dd><p>Maximum number of iterations for the Differential Evolution in\nSciPy.\ndefault : 10</p>\n</dd>\n<dt>xtol<span class=\"classifier\">float, optional</span></dt><dd><p>Tolerance for convergence of minimization.\ndefault : 1e-8</p>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re451c010033d-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Le Bihan, Denis, et al. \u201cSeparation of diffusion and perfusion\nin intravoxel incoherent motion MR imaging.\u201d Radiology 168.2\n(1988): 497-505.</p>\n</dd>\n<dt class=\"label\" id=\"re451c010033d-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Federau, Christian, et al. \u201cQuantitative measurement of brain\nperfusion with intravoxel incoherent motion MR imaging.\u201d\nRadiology 265.3 (2012): 874-881.</p>\n</dd>\n<dt class=\"label\" id=\"re451c010033d-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fadnavis, Shreyas et.al. \u201cMicroLearn: Framework for machine\nlearning, reconstruction, optimization and microstructure\nmodeling, Proceedings of: International Society of Magnetic\nResonance in Medicine (ISMRM), Montreal, Canada, 2019.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.cvx_fit\">\n<code class=\"sig-name descname\">cvx_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">signal</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.cvx_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Performs the constrained search for the linear parameters <cite>f</cite> after\nthe estimation of <cite>x</cite> is done. Estimation of the linear parameters <cite>f</cite>\nis a constrained linear least-squares optimization problem solved by\nusing a convex optimizer from cvxpy. The IVIM equation contains two\nparameters that depend on the same volume fraction. Both are estimated\nas separately in the convex optimizer.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>Returns an array calculated from :func: <cite>phi</cite>.</p>\n</dd>\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>The signal values measured for this model.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>f1, f2 (volume fractions)</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>cost function for differential evolution algorithm:</p>\n<div class=\"math notranslate nohighlight\">\n\\[minimize(norm((signal)- (phi*f)))\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one\">\n<code class=\"sig-name descname\">ivim_mix_cost_one</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">phi</em>, <em class=\"sig-param\">signal</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.ivim_mix_cost_one\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs the objective for the :func: <cite>stoc_search_cost</cite>.</p>\n<p>First calculates the Moore-Penrose inverse of the input <cite>phi</cite> and takes\na dot product with the measured signal. The result obtained is again\nmultiplied with <cite>phi</cite> to complete the projection of the variable into\na transformed space. (see <a class=\"reference internal\" href=\"#re0bc14693ccf-1\" id=\"id533\">[1]</a> and <a class=\"reference internal\" href=\"#re0bc14693ccf-2\" id=\"id534\">[2]</a> for thorough discussion on\nVariable Projections and relevant cost functions).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>Returns an array calculated from :func: <cite>Phi</cite>.</p>\n</dd>\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>The signal values measured for this model.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>(signal -  S)^T(signal -  S)</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>to make cost function for Differential Evolution algorithm:\n.. math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"p\">(</span><span class=\"n\">signal</span> <span class=\"o\">-</span>  <span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">^</span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">signal</span> <span class=\"o\">-</span>  <span class=\"n\">S</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re0bc14693ccf-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id533\">1</a></span></dt>\n<dd><p>Fadnavis, Shreyas et.al. \u201cMicroLearn: Framework for machine\nlearning, reconstruction, optimization and microstructure\nmodeling, Proceedings of: International Society of Magnetic\nResonance in Medicine (ISMRM), Montreal, Canada, 2019.</p>\n</dd>\n<dt class=\"label\" id=\"re0bc14693ccf-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id534\">2</a></span></dt>\n<dd><p>Farooq, Hamza, et al. \u201cMicrostructure Imaging of Crossing (MIX)\nWhite Matter Fibers from diffusion MRI.\u201d Scientific reports 6\n(2016).</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.nlls_cost\">\n<code class=\"sig-name descname\">nlls_cost</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x_f</em>, <em class=\"sig-param\">signal</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.nlls_cost\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Cost function for the least square problem. The cost function is used\nin the Least Squares function of SciPy in :func: <cite>fit</cite>. It guarantees\nthat stopping point of the algorithm is at least a stationary point\nwith reduction in the the number of iterations required by the\ndifferential evolution optimizer.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x_f</strong><span class=\"classifier\">array</span></dt><dd><p>Contains the parameters \u2018x\u2019 and \u2018f\u2019 combines in the same array.</p>\n</dd>\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>The signal values measured for this model.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>sum{(signal -  phi*f)^2}</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>cost function for the least square problem.</p>\n<div class=\"math notranslate nohighlight\">\n\\[sum{(signal -  phi*f)^2}\\]</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.phi\">\n<code class=\"sig-name descname\">phi</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.phi\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Creates a structure for the combining the diffusion and pseudo-\ndiffusion by multipling with the bvals and then exponentiating each of\nthe two components for fitting as per the IVIM- two compartment model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>exp_phi1</strong><span class=\"classifier\">array</span></dt><dd><p>Combined array of parameters perfusion/pseudo-diffusion\nand diffusion parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.stoc_search_cost\">\n<code class=\"sig-name descname\">stoc_search_cost</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">signal</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.stoc_search_cost\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Cost function for differential evolution algorithm. Performs a\nstochastic search for the non-linear parameters \u2018x\u2019. The objective\nfuntion is calculated in the :func: <cite>ivim_mix_cost_one</cite>. The function\nconstructs the parameters using :func: <cite>phi</cite>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array</span></dt><dd><p>input from the Differential Evolution optimizer.</p>\n</dd>\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>The signal values measured for this model.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"field-list simple\">\n<dt class=\"field-odd\">func</dt>\n<dd class=\"field-odd\"><p><cite>ivim_mix_cost_one</cite>\n..</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f\">\n<code class=\"sig-name descname\">x_and_f_to_x_f</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">f</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.x_and_f_to_x_f\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Combines the array of parameters \u2018x\u2019 and \u2018f\u2019 into x_f for performing\nNLLS on the final stage of optimization.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x, f</strong><span class=\"classifier\">array</span></dt><dd><p>Splitted parameters into two separate arrays</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>x_f</strong><span class=\"classifier\">array</span></dt><dd><p>Combined array of parameters \u2018x\u2019 and \u2018f\u2019 parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f\">\n<code class=\"sig-name descname\">x_f_to_x_and_f</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x_f</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModelVP.x_f_to_x_and_f\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Splits the array of parameters in x_f to \u2018x\u2019 and \u2018f\u2019 for performing\na search on the both of them independently using the Trust Region\nMethod.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x_f</strong><span class=\"classifier\">array</span></dt><dd><p>Combined array of parameters \u2018x\u2019 and \u2018f\u2019 parameters.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>x, f</strong><span class=\"classifier\">array</span></dt><dd><p>Splitted parameters into two separate arrays</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id537\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.ivim.LooseVersion\" title=\"dipy.reconst.ivim.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#id537\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.ivim.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.ivim.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.ivim.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id538\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.ivim.ReconstModel\" title=\"dipy.reconst.ivim.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id538\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.ivim.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.ivim.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivimmodel\">\n<h3>IvimModel<a class=\"headerlink\" href=\"#ivimmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.IvimModel\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">IvimModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='trr'</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.IvimModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Selector function to switch between the 2-stage Trust-Region Reflective\nbased NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the\nVariable Projections based fitting method: <cite>varpro</cite>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fit_method</strong><span class=\"classifier\">string, optional</span></dt><dd><p>The value fit_method can either be \u2018trr\u2019 or \u2018varpro\u2019.\ndefault : trr</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"differential-evolution\">\n<h3>differential_evolution<a class=\"headerlink\" href=\"#differential-evolution\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.differential_evolution\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">differential_evolution</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em>, <em class=\"sig-param\">bounds</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">strategy='best1bin'</em>, <em class=\"sig-param\">maxiter=1000</em>, <em class=\"sig-param\">popsize=15</em>, <em class=\"sig-param\">tol=0.01</em>, <em class=\"sig-param\">mutation=(0.5</em>, <em class=\"sig-param\">1)</em>, <em class=\"sig-param\">recombination=0.7</em>, <em class=\"sig-param\">seed=None</em>, <em class=\"sig-param\">callback=None</em>, <em class=\"sig-param\">disp=False</em>, <em class=\"sig-param\">polish=True</em>, <em class=\"sig-param\">init='latinhypercube'</em>, <em class=\"sig-param\">atol=0</em>, <em class=\"sig-param\">updating='immediate'</em>, <em class=\"sig-param\">workers=1</em>, <em class=\"sig-param\">constraints=()</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.differential_evolution\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Finds the global minimum of a multivariate function.</p>\n<p>Differential Evolution is stochastic in nature (does not use gradient\nmethods) to find the minimum, and can search large areas of candidate\nspace, but often requires larger numbers of function evaluations than\nconventional gradient-based techniques.</p>\n<p>The algorithm is due to Storn and Price <a class=\"reference internal\" href=\"#r3bf15ca5114c-1\" id=\"id539\">[1]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>func</strong><span class=\"classifier\">callable</span></dt><dd><p>The objective function to be minimized. Must be in the form\n<code class=\"docutils literal notranslate\"><span class=\"pre\">f(x,</span> <span class=\"pre\">*args)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> is the argument in the form of a 1-D array\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">args</span></code> is a  tuple of any additional fixed parameters needed to\ncompletely specify the function.</p>\n</dd>\n<dt><strong>bounds</strong><span class=\"classifier\">sequence or <cite>Bounds</cite>, optional</span></dt><dd><p>Bounds for variables. There are two ways to specify the bounds:\n1. Instance of <cite>Bounds</cite> class.\n2. <code class=\"docutils literal notranslate\"><span class=\"pre\">(min,</span> <span class=\"pre\">max)</span></code> pairs for each element in <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>, defining the finite\nlower and upper bounds for the optimizing argument of <cite>func</cite>. It is\nrequired to have <code class=\"docutils literal notranslate\"><span class=\"pre\">len(bounds)</span> <span class=\"pre\">==</span> <span class=\"pre\">len(x)</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">len(bounds)</span></code> is used\nto determine the number of parameters in <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>.</p>\n</dd>\n<dt><strong>args</strong><span class=\"classifier\">tuple, optional</span></dt><dd><p>Any additional fixed parameters needed to\ncompletely specify the objective function.</p>\n</dd>\n<dt><strong>strategy</strong><span class=\"classifier\">str, optional</span></dt><dd><p>The differential evolution strategy to use. Should be one of:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018best1bin\u2019</p></li>\n<li><p>\u2018best1exp\u2019</p></li>\n<li><p>\u2018rand1exp\u2019</p></li>\n<li><p>\u2018randtobest1exp\u2019</p></li>\n<li><p>\u2018currenttobest1exp\u2019</p></li>\n<li><p>\u2018best2exp\u2019</p></li>\n<li><p>\u2018rand2exp\u2019</p></li>\n<li><p>\u2018randtobest1bin\u2019</p></li>\n<li><p>\u2018currenttobest1bin\u2019</p></li>\n<li><p>\u2018best2bin\u2019</p></li>\n<li><p>\u2018rand2bin\u2019</p></li>\n<li><p>\u2018rand1bin\u2019</p></li>\n</ul>\n</div></blockquote>\n<p>The default is \u2018best1bin\u2019.</p>\n</dd>\n<dt><strong>maxiter</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The maximum number of generations over which the entire population is\nevolved. The maximum number of function evaluations (with no polishing)\nis: <code class=\"docutils literal notranslate\"><span class=\"pre\">(maxiter</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">popsize</span> <span class=\"pre\">*</span> <span class=\"pre\">len(x)</span></code></p>\n</dd>\n<dt><strong>popsize</strong><span class=\"classifier\">int, optional</span></dt><dd><p>A multiplier for setting the total population size. The population has\n<code class=\"docutils literal notranslate\"><span class=\"pre\">popsize</span> <span class=\"pre\">*</span> <span class=\"pre\">len(x)</span></code> individuals (unless the initial population is\nsupplied via the <cite>init</cite> keyword).</p>\n</dd>\n<dt><strong>tol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Relative tolerance for convergence, the solving stops when\n<code class=\"docutils literal notranslate\"><span class=\"pre\">np.std(pop)</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">atol</span> <span class=\"pre\">+</span> <span class=\"pre\">tol</span> <span class=\"pre\">*</span> <span class=\"pre\">np.abs(np.mean(population_energies))</span></code>,\nwhere and <cite>atol</cite> and <cite>tol</cite> are the absolute and relative tolerance\nrespectively.</p>\n</dd>\n<dt><strong>mutation</strong><span class=\"classifier\">float or tuple(float, float), optional</span></dt><dd><p>The mutation constant. In the literature this is also known as\ndifferential weight, being denoted by F.\nIf specified as a float it should be in the range [0, 2].\nIf specified as a tuple <code class=\"docutils literal notranslate\"><span class=\"pre\">(min,</span> <span class=\"pre\">max)</span></code> dithering is employed. Dithering\nrandomly changes the mutation constant on a generation by generation\nbasis. The mutation constant for that generation is taken from\n<code class=\"docutils literal notranslate\"><span class=\"pre\">U[min,</span> <span class=\"pre\">max)</span></code>. Dithering can help speed convergence significantly.\nIncreasing the mutation constant increases the search radius, but will\nslow down convergence.</p>\n</dd>\n<dt><strong>recombination</strong><span class=\"classifier\">float, optional</span></dt><dd><p>The recombination constant, should be in the range [0, 1]. In the\nliterature this is also known as the crossover probability, being\ndenoted by CR. Increasing this value allows a larger number of mutants\nto progress into the next generation, but at the risk of population\nstability.</p>\n</dd>\n<dt><strong>seed</strong><span class=\"classifier\">{int, <cite>~np.random.RandomState</cite>, <cite>~np.random.Generator</cite>}, optional</span></dt><dd><p>If <cite>seed</cite> is not specified the <cite>~np.random.RandomState</cite> singleton is\nused.\nIf <cite>seed</cite> is an int, a new <code class=\"docutils literal notranslate\"><span class=\"pre\">RandomState</span></code> instance is used,\nseeded with seed.\nIf <cite>seed</cite> is already a <code class=\"docutils literal notranslate\"><span class=\"pre\">RandomState</span></code> or a <code class=\"docutils literal notranslate\"><span class=\"pre\">Generator</span></code> instance,\nthen that object is used.\nSpecify <cite>seed</cite> for repeatable minimizations.</p>\n</dd>\n<dt><strong>disp</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Prints the evaluated <cite>func</cite> at every iteration.</p>\n</dd>\n<dt><strong>callback</strong><span class=\"classifier\">callable, <cite>callback(xk, convergence=val)</cite>, optional</span></dt><dd><p>A function to follow the progress of the minimization. <code class=\"docutils literal notranslate\"><span class=\"pre\">xk</span></code> is\nthe current value of <code class=\"docutils literal notranslate\"><span class=\"pre\">x0</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">val</span></code> represents the fractional\nvalue of the population convergence.  When <code class=\"docutils literal notranslate\"><span class=\"pre\">val</span></code> is greater than one\nthe function halts. If callback returns <cite>True</cite>, then the minimization\nis halted (any polishing is still carried out).</p>\n</dd>\n<dt><strong>polish</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True (default), then <cite>scipy.optimize.minimize</cite> with the <cite>L-BFGS-B</cite>\nmethod is used to polish the best population member at the end, which\ncan improve the minimization slightly. If a constrained problem is\nbeing studied then the <cite>trust-constr</cite> method is used instead.</p>\n</dd>\n<dt><strong>init</strong><span class=\"classifier\">str or array-like, optional</span></dt><dd><p>Specify which type of population initialization is performed. Should be\none of:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018latinhypercube\u2019</p></li>\n<li><p>\u2018random\u2019</p></li>\n<li><p>array specifying the initial population. The array should have\nshape <code class=\"docutils literal notranslate\"><span class=\"pre\">(M,</span> <span class=\"pre\">len(x))</span></code>, where M is the total population size and\nlen(x) is the number of parameters.\n<cite>init</cite> is clipped to <cite>bounds</cite> before use.</p></li>\n</ul>\n</div></blockquote>\n<p>The default is \u2018latinhypercube\u2019. Latin Hypercube sampling tries to\nmaximize coverage of the available parameter space. \u2018random\u2019\ninitializes the population randomly - this has the drawback that\nclustering can occur, preventing the whole of parameter space being\ncovered. Use of an array to specify a population subset could be used,\nfor example, to create a tight bunch of initial guesses in an location\nwhere the solution is known to exist, thereby reducing time for\nconvergence.</p>\n</dd>\n<dt><strong>atol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Absolute tolerance for convergence, the solving stops when\n<code class=\"docutils literal notranslate\"><span class=\"pre\">np.std(pop)</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">atol</span> <span class=\"pre\">+</span> <span class=\"pre\">tol</span> <span class=\"pre\">*</span> <span class=\"pre\">np.abs(np.mean(population_energies))</span></code>,\nwhere and <cite>atol</cite> and <cite>tol</cite> are the absolute and relative tolerance\nrespectively.</p>\n</dd>\n<dt><strong>updating</strong><span class=\"classifier\">{\u2018immediate\u2019, \u2018deferred\u2019}, optional</span></dt><dd><p>If <code class=\"docutils literal notranslate\"><span class=\"pre\">'immediate'</span></code>, the best solution vector is continuously updated\nwithin a single generation <a class=\"reference internal\" href=\"#r3bf15ca5114c-4\" id=\"id540\">[4]</a>. This can lead to faster convergence as\ntrial vectors can take advantage of continuous improvements in the best\nsolution.\nWith <code class=\"docutils literal notranslate\"><span class=\"pre\">'deferred'</span></code>, the best solution vector is updated once per\ngeneration. Only <code class=\"docutils literal notranslate\"><span class=\"pre\">'deferred'</span></code> is compatible with parallelization, and\nthe <cite>workers</cite> keyword can over-ride this option.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.2.0.</span></p>\n</div>\n</dd>\n<dt><strong>workers</strong><span class=\"classifier\">int or map-like callable, optional</span></dt><dd><p>If <cite>workers</cite> is an int the population is subdivided into <cite>workers</cite>\nsections and evaluated in parallel\n(uses <cite>multiprocessing.Pool &lt;multiprocessing&gt;</cite>).\nSupply -1 to use all available CPU cores.\nAlternatively supply a map-like callable, such as\n<cite>multiprocessing.Pool.map</cite> for evaluating the population in parallel.\nThis evaluation is carried out as <code class=\"docutils literal notranslate\"><span class=\"pre\">workers(func,</span> <span class=\"pre\">iterable)</span></code>.\nThis option will override the <cite>updating</cite> keyword to\n<code class=\"docutils literal notranslate\"><span class=\"pre\">updating='deferred'</span></code> if <code class=\"docutils literal notranslate\"><span class=\"pre\">workers</span> <span class=\"pre\">!=</span> <span class=\"pre\">1</span></code>.\nRequires that <cite>func</cite> be pickleable.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.2.0.</span></p>\n</div>\n</dd>\n<dt><strong>constraints</strong><span class=\"classifier\">{NonLinearConstraint, LinearConstraint, Bounds}</span></dt><dd><p>Constraints on the solver, over and above those applied by the <cite>bounds</cite>\nkwd. Uses the approach by Lampinen <a class=\"reference internal\" href=\"#r3bf15ca5114c-5\" id=\"id541\">[5]</a>.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.4.0.</span></p>\n</div>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>res</strong><span class=\"classifier\">OptimizeResult</span></dt><dd><p>The optimization result represented as a <cite>OptimizeResult</cite> object.\nImportant attributes are: <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> the solution array, <code class=\"docutils literal notranslate\"><span class=\"pre\">success</span></code> a\nBoolean flag indicating if the optimizer exited successfully and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">message</span></code> which describes the cause of the termination. See\n<cite>OptimizeResult</cite> for a description of other attributes. If <cite>polish</cite>\nwas employed, and a lower minimum was obtained by the polishing, then\nOptimizeResult also contains the <code class=\"docutils literal notranslate\"><span class=\"pre\">jac</span></code> attribute.\nIf the eventual solution does not satisfy the applied constraints\n<code class=\"docutils literal notranslate\"><span class=\"pre\">success</span></code> will be <cite>False</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Differential evolution is a stochastic population based method that is\nuseful for global optimization problems. At each pass through the population\nthe algorithm mutates each candidate solution by mixing with other candidate\nsolutions to create a trial candidate. There are several strategies <a class=\"reference internal\" href=\"#r3bf15ca5114c-2\" id=\"id542\">[2]</a> for\ncreating trial candidates, which suit some problems more than others. The\n\u2018best1bin\u2019 strategy is a good starting point for many systems. In this\nstrategy two members of the population are randomly chosen. Their difference\nis used to mutate the best member (the \u2018best\u2019 in \u2018best1bin\u2019), <span class=\"math notranslate nohighlight\">\\(b_0\\)</span>,\nso far:</p>\n<div class=\"math notranslate nohighlight\">\n\\[b' = b_0 + mutation * (population[rand0] - population[rand1])\\]</div>\n<p>A trial vector is then constructed. Starting with a randomly chosen ith\nparameter the trial is sequentially filled (in modulo) with parameters from\n<code class=\"docutils literal notranslate\"><span class=\"pre\">b'</span></code> or the original candidate. The choice of whether to use <code class=\"docutils literal notranslate\"><span class=\"pre\">b'</span></code> or the\noriginal candidate is made with a binomial distribution (the \u2018bin\u2019 in\n\u2018best1bin\u2019) - a random number in [0, 1) is generated. If this number is\nless than the <cite>recombination</cite> constant then the parameter is loaded from\n<code class=\"docutils literal notranslate\"><span class=\"pre\">b'</span></code>, otherwise it is loaded from the original candidate. The final\nparameter is always loaded from <code class=\"docutils literal notranslate\"><span class=\"pre\">b'</span></code>. Once the trial candidate is built\nits fitness is assessed. If the trial is better than the original candidate\nthen it takes its place. If it is also better than the best overall\ncandidate it also replaces that.\nTo improve your chances of finding a global minimum use higher <cite>popsize</cite>\nvalues, with higher <cite>mutation</cite> and (dithering), but lower <cite>recombination</cite>\nvalues. This has the effect of widening the search radius, but slowing\nconvergence.\nBy default the best solution vector is updated continuously within a single\niteration (<code class=\"docutils literal notranslate\"><span class=\"pre\">updating='immediate'</span></code>). This is a modification <a class=\"reference internal\" href=\"#r3bf15ca5114c-4\" id=\"id543\">[4]</a> of the\noriginal differential evolution algorithm which can lead to faster\nconvergence as trial vectors can immediately benefit from improved\nsolutions. To use the original Storn and Price behaviour, updating the best\nsolution once per iteration, set <code class=\"docutils literal notranslate\"><span class=\"pre\">updating='deferred'</span></code>.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 0.15.0.</span></p>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3bf15ca5114c-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id539\">1</a></span></dt>\n<dd><p>Storn, R and Price, K, Differential Evolution - a Simple and\nEfficient Heuristic for Global Optimization over Continuous Spaces,\nJournal of Global Optimization, 1997, 11, 341 - 359.</p>\n</dd>\n<dt class=\"label\" id=\"r3bf15ca5114c-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id542\">2</a></span></dt>\n<dd><p><a class=\"reference external\" href=\"http://www1.icsi.berkeley.edu/~storn/code.html\">http://www1.icsi.berkeley.edu/~storn/code.html</a></p>\n</dd>\n<dt class=\"label\" id=\"r3bf15ca5114c-3\"><span class=\"brackets\">3</span></dt>\n<dd><p><a class=\"reference external\" href=\"http://en.wikipedia.org/wiki/Differential_evolution\">http://en.wikipedia.org/wiki/Differential_evolution</a></p>\n</dd>\n<dt class=\"label\" id=\"r3bf15ca5114c-4\"><span class=\"brackets\">4</span><span class=\"fn-backref\">(<a href=\"#id540\">1</a>,<a href=\"#id543\">2</a>)</span></dt>\n<dd><p>Wormington, M., Panaccione, C., Matney, K. M., Bowen, D. K., -\nCharacterization of structures from X-ray scattering data using\ngenetic algorithms, Phil. Trans. R. Soc. Lond. A, 1999, 357,\n2827-2848</p>\n</dd>\n<dt class=\"label\" id=\"r3bf15ca5114c-5\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id541\">5</a></span></dt>\n<dd><p>Lampinen, J., A constraint handling approach for the differential\nevolution algorithm. Proceedings of the 2002 Congress on\nEvolutionary Computation. CEC\u201902 (Cat. No. 02TH8600). Vol. 2. IEEE,\n2002.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Let us consider the problem of minimizing the Rosenbrock function. This\nfunction is implemented in <cite>rosen</cite> in <cite>scipy.optimize</cite>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">rosen</span><span class=\"p\">,</span> <span class=\"n\">differential_evolution</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bounds</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">differential_evolution</span><span class=\"p\">(</span><span class=\"n\">rosen</span><span class=\"p\">,</span> <span class=\"n\">bounds</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">fun</span>\n<span class=\"go\">(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)</span>\n</pre></div>\n</div>\n<p>Now repeat, but with parallelization.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bounds</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">differential_evolution</span><span class=\"p\">(</span><span class=\"n\">rosen</span><span class=\"p\">,</span> <span class=\"n\">bounds</span><span class=\"p\">,</span> <span class=\"n\">updating</span><span class=\"o\">=</span><span class=\"s1\">&#39;deferred&#39;</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                                <span class=\"n\">workers</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">fun</span>\n<span class=\"go\">(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19)</span>\n</pre></div>\n</div>\n<p>Let\u2019s try and do a constrained minimization</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">NonlinearConstraint</span><span class=\"p\">,</span> <span class=\"n\">Bounds</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">constr_f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># the sum of x[0] and x[1] must be less than 1.9</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">nlc</span> <span class=\"o\">=</span> <span class=\"n\">NonlinearConstraint</span><span class=\"p\">(</span><span class=\"n\">constr_f</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inf</span><span class=\"p\">,</span> <span class=\"mf\">1.9</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># specify limits using a `Bounds` object.</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bounds</span> <span class=\"o\">=</span> <span class=\"n\">Bounds</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"mf\">2.</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">differential_evolution</span><span class=\"p\">(</span><span class=\"n\">rosen</span><span class=\"p\">,</span> <span class=\"n\">bounds</span><span class=\"p\">,</span> <span class=\"n\">constraints</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">nlc</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>                                <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">fun</span>\n<span class=\"go\">(array([0.96633867, 0.93363577]), 0.0011361355854792312)</span>\n</pre></div>\n</div>\n<p>Next find the minimum of the Ackley function\n(<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Test_functions_for_optimization\">https://en.wikipedia.org/wiki/Test_functions_for_optimization</a>).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">differential_evolution</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">ackley</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">arg1</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mf\">0.2</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">**</span> <span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"gp\">... </span>    <span class=\"n\">arg2</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mf\">2.</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mf\">2.</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mf\">20.</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">arg2</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mf\">20.</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">e</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bounds</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)]</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">differential_evolution</span><span class=\"p\">(</span><span class=\"n\">ackley</span><span class=\"p\">,</span> <span class=\"n\">bounds</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">fun</span>\n<span class=\"go\">(array([ 0.,  0.]), 4.4408920985006262e-16)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"f-d-star-error\">\n<h3>f_D_star_error<a class=\"headerlink\" href=\"#f-d-star-error\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.f_D_star_error\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">f_D_star_error</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">signal</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.f_D_star_error\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Error function used to fit f and D_star keeping S0 and D fixed</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">array</span></dt><dd><p>The value of f and D_star.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>\n</dd>\n<dt><strong>signal</strong><span class=\"classifier\">array</span></dt><dd><p>Array containing the actual signal values.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>\n</dd>\n<dt><strong>D</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>residual</strong><span class=\"classifier\">array</span></dt><dd><p>An array containing the difference of actual and estimated signal.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"f-d-star-prediction\">\n<h3>f_D_star_prediction<a class=\"headerlink\" href=\"#f-d-star-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.f_D_star_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">f_D_star_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">D</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.f_D_star_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Function used to predict IVIM signal when S0 and D are known\nby considering f and D_star as the unknown parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">array</span></dt><dd><p>The value of f and D_star.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters S0 obtained from a linear fit.</p>\n</dd>\n<dt><strong>D</strong><span class=\"classifier\">float</span></dt><dd><p>The parameters D obtained from a linear fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivim-model-selector\">\n<h3>ivim_model_selector<a class=\"headerlink\" href=\"#ivim-model-selector\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.ivim_model_selector\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">ivim_model_selector</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='trr'</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.ivim_model_selector\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Selector function to switch between the 2-stage Trust-Region Reflective\nbased NLLS fitting method (also containing the linear fit): <cite>trr</cite> and the\nVariable Projections based fitting method: <cite>varpro</cite>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>fit_method</strong><span class=\"classifier\">string, optional</span></dt><dd><p>The value fit_method can either be \u2018trr\u2019 or \u2018varpro\u2019.\ndefault : trr</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"ivim-prediction\">\n<h3>ivim_prediction<a class=\"headerlink\" href=\"#ivim-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.ivim_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">ivim_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.ivim_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The Intravoxel incoherent motion (IVIM) model function.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">array</span></dt><dd><p>An array of IVIM parameters - [S0, f, D_star, D].</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd><p>Gradient directions and bvalues.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float, optional</span></dt><dd><p>This has been added just for consistency with the existing\nAPI. Unlike other models, IVIM predicts S0 and this is over written\nby the S0 value in params.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">array</span></dt><dd><p>An array containing the IVIM signal estimated using given parameters.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"least-squares\">\n<h3>least_squares<a class=\"headerlink\" href=\"#least-squares\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.least_squares\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">least_squares</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fun</em>, <em class=\"sig-param\">x0</em>, <em class=\"sig-param\">jac='2-point'</em>, <em class=\"sig-param\">bounds=(-inf</em>, <em class=\"sig-param\">inf)</em>, <em class=\"sig-param\">method='trf'</em>, <em class=\"sig-param\">ftol=1e-08</em>, <em class=\"sig-param\">xtol=1e-08</em>, <em class=\"sig-param\">gtol=1e-08</em>, <em class=\"sig-param\">x_scale=1.0</em>, <em class=\"sig-param\">loss='linear'</em>, <em class=\"sig-param\">f_scale=1.0</em>, <em class=\"sig-param\">diff_step=None</em>, <em class=\"sig-param\">tr_solver=None</em>, <em class=\"sig-param\">tr_options={}</em>, <em class=\"sig-param\">jac_sparsity=None</em>, <em class=\"sig-param\">max_nfev=None</em>, <em class=\"sig-param\">verbose=0</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">kwargs={}</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.least_squares\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Solve a nonlinear least-squares problem with bounds on the variables.</p>\n<p>Given the residuals f(x) (an m-D real function of n real\nvariables) and the loss function rho(s) (a scalar function), <cite>least_squares</cite>\nfinds a local minimum of the cost function F(x):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">minimize</span> <span class=\"n\">F</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">rho</span><span class=\"p\">(</span><span class=\"n\">f_i</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">m</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">subject</span> <span class=\"n\">to</span> <span class=\"n\">lb</span> <span class=\"o\">&lt;=</span> <span class=\"n\">x</span> <span class=\"o\">&lt;=</span> <span class=\"n\">ub</span>\n</pre></div>\n</div>\n<p>The purpose of the loss function rho(s) is to reduce the influence of\noutliers on the solution.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>fun</strong><span class=\"classifier\">callable</span></dt><dd><p>Function which computes the vector of residuals, with the signature\n<code class=\"docutils literal notranslate\"><span class=\"pre\">fun(x,</span> <span class=\"pre\">*args,</span> <span class=\"pre\">**kwargs)</span></code>, i.e., the minimization proceeds with\nrespect to its first argument. The argument <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> passed to this\nfunction is an ndarray of shape (n,) (never a scalar, even for n=1).\nIt must allocate and return a 1-D array_like of shape (m,) or a scalar.\nIf the argument <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> is complex or the function <code class=\"docutils literal notranslate\"><span class=\"pre\">fun</span></code> returns\ncomplex residuals, it must be wrapped in a real function of real\narguments, as shown at the end of the Examples section.</p>\n</dd>\n<dt><strong>x0</strong><span class=\"classifier\">array_like with shape (n,) or float</span></dt><dd><p>Initial guess on independent variables. If float, it will be treated\nas a 1-D array with one element.</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">{\u20182-point\u2019, \u20183-point\u2019, \u2018cs\u2019, callable}, optional</span></dt><dd><p>Method of computing the Jacobian matrix (an m-by-n matrix, where\nelement (i, j) is the partial derivative of f[i] with respect to\nx[j]). The keywords select a finite difference scheme for numerical\nestimation. The scheme \u20183-point\u2019 is more accurate, but requires\ntwice as many operations as \u20182-point\u2019 (default). The scheme \u2018cs\u2019\nuses complex steps, and while potentially the most accurate, it is\napplicable only when <cite>fun</cite> correctly handles complex inputs and\ncan be analytically continued to the complex plane. Method \u2018lm\u2019\nalways uses the \u20182-point\u2019 scheme. If callable, it is used as\n<code class=\"docutils literal notranslate\"><span class=\"pre\">jac(x,</span> <span class=\"pre\">*args,</span> <span class=\"pre\">**kwargs)</span></code> and should return a good approximation\n(or the exact value) for the Jacobian as an array_like (np.atleast_2d\nis applied), a sparse matrix or a <cite>scipy.sparse.linalg.LinearOperator</cite>.</p>\n</dd>\n<dt><strong>bounds</strong><span class=\"classifier\">2-tuple of array_like, optional</span></dt><dd><p>Lower and upper bounds on independent variables. Defaults to no bounds.\nEach array must match the size of <cite>x0</cite> or be a scalar, in the latter\ncase a bound will be the same for all variables. Use <code class=\"docutils literal notranslate\"><span class=\"pre\">np.inf</span></code> with\nan appropriate sign to disable bounds on all or some variables.</p>\n</dd>\n<dt><strong>method</strong><span class=\"classifier\">{\u2018trf\u2019, \u2018dogbox\u2019, \u2018lm\u2019}, optional</span></dt><dd><p>Algorithm to perform minimization.</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018trf\u2019 : Trust Region Reflective algorithm, particularly suitable\nfor large sparse problems with bounds. Generally robust method.</p></li>\n<li><p>\u2018dogbox\u2019 : dogleg algorithm with rectangular trust regions,\ntypical use case is small problems with bounds. Not recommended\nfor problems with rank-deficient Jacobian.</p></li>\n<li><p>\u2018lm\u2019 : Levenberg-Marquardt algorithm as implemented in MINPACK.\nDoesn\u2019t handle bounds and sparse Jacobians. Usually the most\nefficient method for small unconstrained problems.</p></li>\n</ul>\n</div></blockquote>\n<p>Default is \u2018trf\u2019. See Notes for more information.</p>\n</dd>\n<dt><strong>ftol</strong><span class=\"classifier\">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the cost function. Default\nis 1e-8. The optimization process is stopped when <code class=\"docutils literal notranslate\"><span class=\"pre\">dF</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">ftol</span> <span class=\"pre\">*</span> <span class=\"pre\">F</span></code>,\nand there was an adequate agreement between a local quadratic model and\nthe true model in the last step. If None, the termination by this\ncondition is disabled.</p>\n</dd>\n<dt><strong>xtol</strong><span class=\"classifier\">float or None, optional</span></dt><dd><p>Tolerance for termination by the change of the independent variables.\nDefault is 1e-8. The exact condition depends on the <cite>method</cite> used:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>For \u2018trf\u2019 and \u2018dogbox\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">norm(dx)</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">xtol</span> <span class=\"pre\">*</span> <span class=\"pre\">(xtol</span> <span class=\"pre\">+</span> <span class=\"pre\">norm(x))</span></code>.</p></li>\n<li><p>For \u2018lm\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">Delta</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">xtol</span> <span class=\"pre\">*</span> <span class=\"pre\">norm(xs)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">Delta</span></code> is\na trust-region radius and <code class=\"docutils literal notranslate\"><span class=\"pre\">xs</span></code> is the value of <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>\nscaled according to <cite>x_scale</cite> parameter (see below).</p></li>\n</ul>\n</div></blockquote>\n<p>If None, the termination by this condition is disabled.</p>\n</dd>\n<dt><strong>gtol</strong><span class=\"classifier\">float or None, optional</span></dt><dd><p>Tolerance for termination by the norm of the gradient. Default is 1e-8.\nThe exact condition depends on a <cite>method</cite> used:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>For \u2018trf\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">norm(g_scaled,</span> <span class=\"pre\">ord=np.inf)</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">gtol</span></code>, where\n<code class=\"docutils literal notranslate\"><span class=\"pre\">g_scaled</span></code> is the value of the gradient scaled to account for\nthe presence of the bounds <a class=\"reference internal\" href=\"#r1786fd6832dd-stir\" id=\"id549\">[STIR]</a>.</p></li>\n<li><p>For \u2018dogbox\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">norm(g_free,</span> <span class=\"pre\">ord=np.inf)</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">gtol</span></code>, where\n<code class=\"docutils literal notranslate\"><span class=\"pre\">g_free</span></code> is the gradient with respect to the variables which\nare not in the optimal state on the boundary.</p></li>\n<li><p>For \u2018lm\u2019 : the maximum absolute value of the cosine of angles\nbetween columns of the Jacobian and the residual vector is less\nthan <cite>gtol</cite>, or the residual vector is zero.</p></li>\n</ul>\n</div></blockquote>\n<p>If None, the termination by this condition is disabled.</p>\n</dd>\n<dt><strong>x_scale</strong><span class=\"classifier\">array_like or \u2018jac\u2019, optional</span></dt><dd><p>Characteristic scale of each variable. Setting <cite>x_scale</cite> is equivalent\nto reformulating the problem in scaled variables <code class=\"docutils literal notranslate\"><span class=\"pre\">xs</span> <span class=\"pre\">=</span> <span class=\"pre\">x</span> <span class=\"pre\">/</span> <span class=\"pre\">x_scale</span></code>.\nAn alternative view is that the size of a trust region along jth\ndimension is proportional to <code class=\"docutils literal notranslate\"><span class=\"pre\">x_scale[j]</span></code>. Improved convergence may\nbe achieved by setting <cite>x_scale</cite> such that a step of a given size\nalong any of the scaled variables has a similar effect on the cost\nfunction. If set to \u2018jac\u2019, the scale is iteratively updated using the\ninverse norms of the columns of the Jacobian matrix (as described in\n<a class=\"reference internal\" href=\"#r1786fd6832dd-jjmore\" id=\"id550\">[JJMore]</a>).</p>\n</dd>\n<dt><strong>loss</strong><span class=\"classifier\">str or callable, optional</span></dt><dd><p>Determines the loss function. The following keyword values are allowed:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018linear\u2019 (default) : <code class=\"docutils literal notranslate\"><span class=\"pre\">rho(z)</span> <span class=\"pre\">=</span> <span class=\"pre\">z</span></code>. Gives a standard\nleast-squares problem.</p></li>\n<li><p>\u2018soft_l1\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">rho(z)</span> <span class=\"pre\">=</span> <span class=\"pre\">2</span> <span class=\"pre\">*</span> <span class=\"pre\">((1</span> <span class=\"pre\">+</span> <span class=\"pre\">z)**0.5</span> <span class=\"pre\">-</span> <span class=\"pre\">1)</span></code>. The smooth\napproximation of l1 (absolute value) loss. Usually a good\nchoice for robust least squares.</p></li>\n<li><p>\u2018huber\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">rho(z)</span> <span class=\"pre\">=</span> <span class=\"pre\">z</span> <span class=\"pre\">if</span> <span class=\"pre\">z</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">1</span> <span class=\"pre\">else</span> <span class=\"pre\">2*z**0.5</span> <span class=\"pre\">-</span> <span class=\"pre\">1</span></code>. Works\nsimilarly to \u2018soft_l1\u2019.</p></li>\n<li><p>\u2018cauchy\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">rho(z)</span> <span class=\"pre\">=</span> <span class=\"pre\">ln(1</span> <span class=\"pre\">+</span> <span class=\"pre\">z)</span></code>. Severely weakens outliers\ninfluence, but may cause difficulties in optimization process.</p></li>\n<li><p>\u2018arctan\u2019 : <code class=\"docutils literal notranslate\"><span class=\"pre\">rho(z)</span> <span class=\"pre\">=</span> <span class=\"pre\">arctan(z)</span></code>. Limits a maximum loss on\na single residual, has properties similar to \u2018cauchy\u2019.</p></li>\n</ul>\n</div></blockquote>\n<p>If callable, it must take a 1-D ndarray <code class=\"docutils literal notranslate\"><span class=\"pre\">z=f**2</span></code> and return an\narray_like with shape (3, m) where row 0 contains function values,\nrow 1 contains first derivatives and row 2 contains second\nderivatives. Method \u2018lm\u2019 supports only \u2018linear\u2019 loss.</p>\n</dd>\n<dt><strong>f_scale</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Value of soft margin between inlier and outlier residuals, default\nis 1.0. The loss function is evaluated as follows\n<code class=\"docutils literal notranslate\"><span class=\"pre\">rho_(f**2)</span> <span class=\"pre\">=</span> <span class=\"pre\">C**2</span> <span class=\"pre\">*</span> <span class=\"pre\">rho(f**2</span> <span class=\"pre\">/</span> <span class=\"pre\">C**2)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">C</span></code> is <cite>f_scale</cite>,\nand <code class=\"docutils literal notranslate\"><span class=\"pre\">rho</span></code> is determined by <cite>loss</cite> parameter. This parameter has\nno effect with <code class=\"docutils literal notranslate\"><span class=\"pre\">loss='linear'</span></code>, but for other <cite>loss</cite> values it is\nof crucial importance.</p>\n</dd>\n<dt><strong>max_nfev</strong><span class=\"classifier\">None or int, optional</span></dt><dd><p>Maximum number of function evaluations before the termination.\nIf None (default), the value is chosen automatically:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>For \u2018trf\u2019 and \u2018dogbox\u2019 : 100 * n.</p></li>\n<li><p>For \u2018lm\u2019 :  100 * n if <cite>jac</cite> is callable and 100 * n * (n + 1)\notherwise (because \u2018lm\u2019 counts function calls in Jacobian\nestimation).</p></li>\n</ul>\n</div></blockquote>\n</dd>\n<dt><strong>diff_step</strong><span class=\"classifier\">None or array_like, optional</span></dt><dd><p>Determines the relative step size for the finite difference\napproximation of the Jacobian. The actual step is computed as\n<code class=\"docutils literal notranslate\"><span class=\"pre\">x</span> <span class=\"pre\">*</span> <span class=\"pre\">diff_step</span></code>. If None (default), then <cite>diff_step</cite> is taken to be\na conventional \u201coptimal\u201d power of machine epsilon for the finite\ndifference scheme used <a class=\"reference internal\" href=\"#r1786fd6832dd-nr\" id=\"id551\">[NR]</a>.</p>\n</dd>\n<dt><strong>tr_solver</strong><span class=\"classifier\">{None, \u2018exact\u2019, \u2018lsmr\u2019}, optional</span></dt><dd><p>Method for solving trust-region subproblems, relevant only for \u2018trf\u2019\nand \u2018dogbox\u2019 methods.</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018exact\u2019 is suitable for not very large problems with dense\nJacobian matrices. The computational complexity per iteration is\ncomparable to a singular value decomposition of the Jacobian\nmatrix.</p></li>\n<li><p>\u2018lsmr\u2019 is suitable for problems with sparse and large Jacobian\nmatrices. It uses the iterative procedure\n<cite>scipy.sparse.linalg.lsmr</cite> for finding a solution of a linear\nleast-squares problem and only requires matrix-vector product\nevaluations.</p></li>\n</ul>\n</div></blockquote>\n<p>If None (default), the solver is chosen based on the type of Jacobian\nreturned on the first iteration.</p>\n</dd>\n<dt><strong>tr_options</strong><span class=\"classifier\">dict, optional</span></dt><dd><p>Keyword options passed to trust-region solver.</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">tr_solver='exact'</span></code>: <cite>tr_options</cite> are ignored.</p></li>\n<li><p><code class=\"docutils literal notranslate\"><span class=\"pre\">tr_solver='lsmr'</span></code>: options for <cite>scipy.sparse.linalg.lsmr</cite>.\nAdditionally,  <code class=\"docutils literal notranslate\"><span class=\"pre\">method='trf'</span></code> supports  \u2018regularize\u2019 option\n(bool, default is True), which adds a regularization term to the\nnormal equation, which improves convergence if the Jacobian is\nrank-deficient <a class=\"reference internal\" href=\"#r1786fd6832dd-byrd\" id=\"id552\">[Byrd]</a> (eq. 3.4).</p></li>\n</ul>\n</div></blockquote>\n</dd>\n<dt><strong>jac_sparsity</strong><span class=\"classifier\">{None, array_like, sparse matrix}, optional</span></dt><dd><p>Defines the sparsity structure of the Jacobian matrix for finite\ndifference estimation, its shape must be (m, n). If the Jacobian has\nonly few non-zero elements in <em>each</em> row, providing the sparsity\nstructure will greatly speed up the computations <a class=\"reference internal\" href=\"#r1786fd6832dd-curtis\" id=\"id553\">[Curtis]</a>. A zero\nentry means that a corresponding element in the Jacobian is identically\nzero. If provided, forces the use of \u2018lsmr\u2019 trust-region solver.\nIf None (default), then dense differencing will be used. Has no effect\nfor \u2018lm\u2019 method.</p>\n</dd>\n<dt><strong>verbose</strong><span class=\"classifier\">{0, 1, 2}, optional</span></dt><dd><p>Level of algorithm\u2019s verbosity:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>0 (default) : work silently.</p></li>\n<li><p>1 : display a termination report.</p></li>\n<li><p>2 : display progress during iterations (not supported by \u2018lm\u2019\nmethod).</p></li>\n</ul>\n</div></blockquote>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">tuple and dict, optional</span></dt><dd><p>Additional arguments passed to <cite>fun</cite> and <cite>jac</cite>. Both empty by default.\nThe calling signature is <code class=\"docutils literal notranslate\"><span class=\"pre\">fun(x,</span> <span class=\"pre\">*args,</span> <span class=\"pre\">**kwargs)</span></code> and the same for\n<cite>jac</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><cite>OptimizeResult</cite> with the following fields defined:</dt><dd></dd>\n<dt><strong>x</strong><span class=\"classifier\">ndarray, shape (n,)</span></dt><dd><p>Solution found.</p>\n</dd>\n<dt><strong>cost</strong><span class=\"classifier\">float</span></dt><dd><p>Value of the cost function at the solution.</p>\n</dd>\n<dt><strong>fun</strong><span class=\"classifier\">ndarray, shape (m,)</span></dt><dd><p>Vector of residuals at the solution.</p>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">ndarray, sparse matrix or LinearOperator, shape (m, n)</span></dt><dd><p>Modified Jacobian matrix at the solution, in the sense that J^T J\nis a Gauss-Newton approximation of the Hessian of the cost function.\nThe type is the same as the one used by the algorithm.</p>\n</dd>\n<dt><strong>grad</strong><span class=\"classifier\">ndarray, shape (m,)</span></dt><dd><p>Gradient of the cost function at the solution.</p>\n</dd>\n<dt><strong>optimality</strong><span class=\"classifier\">float</span></dt><dd><p>First-order optimality measure. In unconstrained problems, it is always\nthe uniform norm of the gradient. In constrained problems, it is the\nquantity which was compared with <cite>gtol</cite> during iterations.</p>\n</dd>\n<dt><strong>active_mask</strong><span class=\"classifier\">ndarray of int, shape (n,)</span></dt><dd><p>Each component shows whether a corresponding constraint is active\n(that is, whether a variable is at the bound):</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>0 : a constraint is not active.</p></li>\n<li><p>-1 : a lower bound is active.</p></li>\n<li><p>1 : an upper bound is active.</p></li>\n</ul>\n</div></blockquote>\n<p>Might be somewhat arbitrary for \u2018trf\u2019 method as it generates a sequence\nof strictly feasible iterates and <cite>active_mask</cite> is determined within a\ntolerance threshold.</p>\n</dd>\n<dt><strong>nfev</strong><span class=\"classifier\">int</span></dt><dd><p>Number of function evaluations done. Methods \u2018trf\u2019 and \u2018dogbox\u2019 do not\ncount function calls for numerical Jacobian approximation, as opposed\nto \u2018lm\u2019 method.</p>\n</dd>\n<dt><strong>njev</strong><span class=\"classifier\">int or None</span></dt><dd><p>Number of Jacobian evaluations done. If numerical Jacobian\napproximation is used in \u2018lm\u2019 method, it is set to None.</p>\n</dd>\n<dt><strong>status</strong><span class=\"classifier\">int</span></dt><dd><p>The reason for algorithm termination:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>-1 : improper input parameters status returned from MINPACK.</p></li>\n<li><p>0 : the maximum number of function evaluations is exceeded.</p></li>\n<li><p>1 : <cite>gtol</cite> termination condition is satisfied.</p></li>\n<li><p>2 : <cite>ftol</cite> termination condition is satisfied.</p></li>\n<li><p>3 : <cite>xtol</cite> termination condition is satisfied.</p></li>\n<li><p>4 : Both <cite>ftol</cite> and <cite>xtol</cite> termination conditions are satisfied.</p></li>\n</ul>\n</div></blockquote>\n</dd>\n<dt><strong>message</strong><span class=\"classifier\">str</span></dt><dd><p>Verbal description of the termination reason.</p>\n</dd>\n<dt><strong>success</strong><span class=\"classifier\">bool</span></dt><dd><p>True if one of the convergence criteria is satisfied (<cite>status</cite> &gt; 0).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">leastsq</span></code></dt><dd><p>A legacy wrapper for the MINPACK implementation of the Levenberg-Marquadt algorithm.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">curve_fit</span></code></dt><dd><p>Least-squares minimization applied to a curve-fitting problem.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>Method \u2018lm\u2019 (Levenberg-Marquardt) calls a wrapper over least-squares\nalgorithms implemented in MINPACK (lmder, lmdif). It runs the\nLevenberg-Marquardt algorithm formulated as a trust-region type algorithm.\nThe implementation is based on paper <a class=\"reference internal\" href=\"#r1786fd6832dd-jjmore\" id=\"id554\">[JJMore]</a>, it is very robust and\nefficient with a lot of smart tricks. It should be your first choice\nfor unconstrained problems. Note that it doesn\u2019t support bounds. Also,\nit doesn\u2019t work when m &lt; n.</p>\n<p>Method \u2018trf\u2019 (Trust Region Reflective) is motivated by the process of\nsolving a system of equations, which constitute the first-order optimality\ncondition for a bound-constrained minimization problem as formulated in\n<a class=\"reference internal\" href=\"#r1786fd6832dd-stir\" id=\"id555\">[STIR]</a>. The algorithm iteratively solves trust-region subproblems\naugmented by a special diagonal quadratic term and with trust-region shape\ndetermined by the distance from the bounds and the direction of the\ngradient. This enhancements help to avoid making steps directly into bounds\nand efficiently explore the whole space of variables. To further improve\nconvergence, the algorithm considers search directions reflected from the\nbounds. To obey theoretical requirements, the algorithm keeps iterates\nstrictly feasible. With dense Jacobians trust-region subproblems are\nsolved by an exact method very similar to the one described in <a class=\"reference internal\" href=\"#r1786fd6832dd-jjmore\" id=\"id556\">[JJMore]</a>\n(and implemented in MINPACK). The difference from the MINPACK\nimplementation is that a singular value decomposition of a Jacobian\nmatrix is done once per iteration, instead of a QR decomposition and series\nof Givens rotation eliminations. For large sparse Jacobians a 2-D subspace\napproach of solving trust-region subproblems is used <a class=\"reference internal\" href=\"#r1786fd6832dd-stir\" id=\"id557\">[STIR]</a>, <a class=\"reference internal\" href=\"#r1786fd6832dd-byrd\" id=\"id558\">[Byrd]</a>.\nThe subspace is spanned by a scaled gradient and an approximate\nGauss-Newton solution delivered by <cite>scipy.sparse.linalg.lsmr</cite>. When no\nconstraints are imposed the algorithm is very similar to MINPACK and has\ngenerally comparable performance. The algorithm works quite robust in\nunbounded and bounded problems, thus it is chosen as a default algorithm.</p>\n<p>Method \u2018dogbox\u2019 operates in a trust-region framework, but considers\nrectangular trust regions as opposed to conventional ellipsoids <a class=\"reference internal\" href=\"#r1786fd6832dd-voglis\" id=\"id559\">[Voglis]</a>.\nThe intersection of a current trust region and initial bounds is again\nrectangular, so on each iteration a quadratic minimization problem subject\nto bound constraints is solved approximately by Powell\u2019s dogleg method\n<a class=\"reference internal\" href=\"#r1786fd6832dd-numopt\" id=\"id560\">[NumOpt]</a>. The required Gauss-Newton step can be computed exactly for\ndense Jacobians or approximately by <cite>scipy.sparse.linalg.lsmr</cite> for large\nsparse Jacobians. The algorithm is likely to exhibit slow convergence when\nthe rank of Jacobian is less than the number of variables. The algorithm\noften outperforms \u2018trf\u2019 in bounded problems with a small number of\nvariables.</p>\n<p>Robust loss functions are implemented as described in <a class=\"reference internal\" href=\"#r1786fd6832dd-ba\" id=\"id561\">[BA]</a>. The idea\nis to modify a residual vector and a Jacobian matrix on each iteration\nsuch that computed gradient and Gauss-Newton Hessian approximation match\nthe true gradient and Hessian approximation of the cost function. Then\nthe algorithm proceeds in a normal way, i.e., robust loss functions are\nimplemented as a simple wrapper over standard least-squares algorithms.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 0.17.0.</span></p>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1786fd6832dd-stir\"><span class=\"brackets\">STIR</span><span class=\"fn-backref\">(<a href=\"#id549\">1</a>,<a href=\"#id555\">2</a>,<a href=\"#id557\">3</a>)</span></dt>\n<dd><p>M. A. Branch, T. F. Coleman, and Y. Li, \u201cA Subspace, Interior,\nand Conjugate Gradient Method for Large-Scale Bound-Constrained\nMinimization Problems,\u201d SIAM Journal on Scientific Computing,\nVol. 21, Number 1, pp 1-23, 1999.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-nr\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id551\">NR</a></span></dt>\n<dd><p>William H. Press et. al., \u201cNumerical Recipes. The Art of Scientific\nComputing. 3rd edition\u201d, Sec. 5.7.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-byrd\"><span class=\"brackets\">Byrd</span><span class=\"fn-backref\">(<a href=\"#id552\">1</a>,<a href=\"#id558\">2</a>)</span></dt>\n<dd><p>R. H. Byrd, R. B. Schnabel and G. A. Shultz, \u201cApproximate\nsolution of the trust region problem by minimization over\ntwo-dimensional subspaces\u201d, Math. Programming, 40, pp. 247-263,\n1988.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-curtis\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id553\">Curtis</a></span></dt>\n<dd><p>A. Curtis, M. J. D. Powell, and J. Reid, \u201cOn the estimation of\nsparse Jacobian matrices\u201d, Journal of the Institute of\nMathematics and its Applications, 13, pp. 117-120, 1974.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-jjmore\"><span class=\"brackets\">JJMore</span><span class=\"fn-backref\">(<a href=\"#id550\">1</a>,<a href=\"#id554\">2</a>,<a href=\"#id556\">3</a>)</span></dt>\n<dd><p>J. J. More, \u201cThe Levenberg-Marquardt Algorithm: Implementation\nand Theory,\u201d Numerical Analysis, ed. G. A. Watson, Lecture\nNotes in Mathematics 630, Springer Verlag, pp. 105-116, 1977.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-voglis\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id559\">Voglis</a></span></dt>\n<dd><p>C. Voglis and I. E. Lagaris, \u201cA Rectangular Trust Region\nDogleg Approach for Unconstrained and Bound Constrained\nNonlinear Optimization\u201d, WSEAS International Conference on\nApplied Mathematics, Corfu, Greece, 2004.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-numopt\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id560\">NumOpt</a></span></dt>\n<dd><p>J. Nocedal and S. J. Wright, \u201cNumerical optimization,\n2nd edition\u201d, Chapter 4.</p>\n</dd>\n<dt class=\"label\" id=\"r1786fd6832dd-ba\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id561\">BA</a></span></dt>\n<dd><p>B. Triggs et. al., \u201cBundle Adjustment - A Modern Synthesis\u201d,\nProceedings of the International Workshop on Vision Algorithms:\nTheory and Practice, pp. 298-372, 1999.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>In this example we find a minimum of the Rosenbrock function without bounds\non independent variables.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">fun_rosenbrock</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">10</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])])</span>\n</pre></div>\n</div>\n<p>Notice that we only provide the vector of the residuals. The algorithm\nconstructs the cost function as a sum of squares of the residuals, which\ngives the Rosenbrock function. The exact minimum is at <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span> <span class=\"pre\">=</span> <span class=\"pre\">[1.0,</span> <span class=\"pre\">1.0]</span></code>.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">least_squares</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x0_rosenbrock</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_1</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun_rosenbrock</span><span class=\"p\">,</span> <span class=\"n\">x0_rosenbrock</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_1</span><span class=\"o\">.</span><span class=\"n\">x</span>\n<span class=\"go\">array([ 1.,  1.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_1</span><span class=\"o\">.</span><span class=\"n\">cost</span>\n<span class=\"go\">9.8669242910846867e-30</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_1</span><span class=\"o\">.</span><span class=\"n\">optimality</span>\n<span class=\"go\">8.8928864934219529e-14</span>\n</pre></div>\n</div>\n<p>We now constrain the variables, in such a way that the previous solution\nbecomes infeasible. Specifically, we require that <code class=\"docutils literal notranslate\"><span class=\"pre\">x[1]</span> <span class=\"pre\">&gt;=</span> <span class=\"pre\">1.5</span></code>, and\n<code class=\"docutils literal notranslate\"><span class=\"pre\">x[0]</span></code> left unconstrained. To this end, we specify the <cite>bounds</cite> parameter\nto <cite>least_squares</cite> in the form <code class=\"docutils literal notranslate\"><span class=\"pre\">bounds=([-np.inf,</span> <span class=\"pre\">1.5],</span> <span class=\"pre\">np.inf)</span></code>.</p>\n<p>We also provide the analytic Jacobian:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">jac_rosenbrock</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span>\n<span class=\"gp\">... </span>        <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">20</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mi\">10</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>        <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]])</span>\n</pre></div>\n</div>\n<p>Putting this all together, we see that the new solution lies on the bound:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_2</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun_rosenbrock</span><span class=\"p\">,</span> <span class=\"n\">x0_rosenbrock</span><span class=\"p\">,</span> <span class=\"n\">jac_rosenbrock</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                      <span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"p\">([</span><span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inf</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">],</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inf</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_2</span><span class=\"o\">.</span><span class=\"n\">x</span>\n<span class=\"go\">array([ 1.22437075,  1.5       ])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_2</span><span class=\"o\">.</span><span class=\"n\">cost</span>\n<span class=\"go\">0.025213093946805685</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_2</span><span class=\"o\">.</span><span class=\"n\">optimality</span>\n<span class=\"go\">1.5885401433157753e-07</span>\n</pre></div>\n</div>\n<p>Now we solve a system of equations (i.e., the cost function should be zero\nat a minimum) for a Broyden tridiagonal vector-valued function of 100000\nvariables:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">fun_broyden</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span> <span class=\"o\">-=</span> <span class=\"n\">x</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"gp\">... </span>    <span class=\"n\">f</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">f</span>\n</pre></div>\n</div>\n<p>The corresponding Jacobian matrix is sparse. We tell the algorithm to\nestimate it by finite differences and provide the sparsity structure of\nJacobian to significantly speed up this process.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.sparse</span> <span class=\"k\">import</span> <span class=\"n\">lil_matrix</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">sparsity_broyden</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">sparsity</span> <span class=\"o\">=</span> <span class=\"n\">lil_matrix</span><span class=\"p\">((</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">sparsity</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">sparsity</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">sparsity</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">sparsity</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">100000</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x0_broyden</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_3</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun_broyden</span><span class=\"p\">,</span> <span class=\"n\">x0_broyden</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                      <span class=\"n\">jac_sparsity</span><span class=\"o\">=</span><span class=\"n\">sparsity_broyden</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_3</span><span class=\"o\">.</span><span class=\"n\">cost</span>\n<span class=\"go\">4.5687069299604613e-23</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_3</span><span class=\"o\">.</span><span class=\"n\">optimality</span>\n<span class=\"go\">1.1650454296851518e-11</span>\n</pre></div>\n</div>\n<p>Let\u2019s also solve a curve fitting problem using robust loss function to\ntake care of outliers in the data. Define the model function as\n<code class=\"docutils literal notranslate\"><span class=\"pre\">y</span> <span class=\"pre\">=</span> <span class=\"pre\">a</span> <span class=\"pre\">+</span> <span class=\"pre\">b</span> <span class=\"pre\">*</span> <span class=\"pre\">exp(c</span> <span class=\"pre\">*</span> <span class=\"pre\">t)</span></code>, where t is a predictor variable, y is an\nobservation and a, b, c are parameters to estimate.</p>\n<p>First, define the function which generates the data with noise and\noutliers, define the model parameters, and generate data:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">n_outliers</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">t</span> <span class=\"o\">*</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">... </span>    <span class=\"n\">rnd</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"n\">random_state</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">noise</span> <span class=\"o\">*</span> <span class=\"n\">rnd</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">outliers</span> <span class=\"o\">=</span> <span class=\"n\">rnd</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"n\">n_outliers</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>    <span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">outliers</span><span class=\"p\">]</span> <span class=\"o\">*=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">y</span> <span class=\"o\">+</span> <span class=\"n\">error</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t_min</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t_max</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">n_points</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t_train</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"n\">t_min</span><span class=\"p\">,</span> <span class=\"n\">t_max</span><span class=\"p\">,</span> <span class=\"n\">n_points</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y_train</span> <span class=\"o\">=</span> <span class=\"n\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t_train</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">noise</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">n_outliers</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Define function for computing residuals and initial estimate of\nparameters.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">y</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>Compute a standard least-squares solution:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_lsq</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">t_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>Now compute two solutions with two different robust loss functions. The\nparameter <cite>f_scale</cite> is set to 0.1, meaning that inlier residuals should\nnot significantly exceed 0.1 (the noise level used).</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_soft_l1</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">loss</span><span class=\"o\">=</span><span class=\"s1\">&#39;soft_l1&#39;</span><span class=\"p\">,</span> <span class=\"n\">f_scale</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                            <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">t_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_log</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">loss</span><span class=\"o\">=</span><span class=\"s1\">&#39;cauchy&#39;</span><span class=\"p\">,</span> <span class=\"n\">f_scale</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                        <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">t_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n<p>And, finally, plot all the curves. We see that by selecting an appropriate\n<cite>loss</cite>  we can get estimates close to optimal even in the presence of\nstrong outliers. But keep in mind that generally it is recommended to try\n\u2018soft_l1\u2019 or \u2018huber\u2019 losses first (if at all necessary) as the other two\noptions may cause difficulties in optimization process.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">t_test</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"n\">t_min</span><span class=\"p\">,</span> <span class=\"n\">t_max</span><span class=\"p\">,</span> <span class=\"n\">n_points</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y_true</span> <span class=\"o\">=</span> <span class=\"n\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y_lsq</span> <span class=\"o\">=</span> <span class=\"n\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">res_lsq</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y_soft_l1</span> <span class=\"o\">=</span> <span class=\"n\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">res_soft_l1</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y_log</span> <span class=\"o\">=</span> <span class=\"n\">gen_data</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">res_log</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">,</span> <span class=\"s1\">&#39;o&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"n\">y_true</span><span class=\"p\">,</span> <span class=\"s1\">&#39;k&#39;</span><span class=\"p\">,</span> <span class=\"n\">linewidth</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;true&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"n\">y_lsq</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear loss&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"n\">y_soft_l1</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;soft_l1 loss&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t_test</span><span class=\"p\">,</span> <span class=\"n\">y_log</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;cauchy loss&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s2\">&quot;t&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s2\">&quot;y&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>In the next example, we show how complex-valued residual functions of\ncomplex variables can be optimized with <code class=\"docutils literal notranslate\"><span class=\"pre\">least_squares()</span></code>. Consider the\nfollowing function:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">z</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mf\">0.5</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span><span class=\"n\">j</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>We wrap it into a function of real variables that returns real residuals\nby simply handling the real and imaginary parts as independent variables:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">f_wrap</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">fx</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"n\">j</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">fx</span><span class=\"o\">.</span><span class=\"n\">real</span><span class=\"p\">,</span> <span class=\"n\">fx</span><span class=\"o\">.</span><span class=\"n\">imag</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>Thus, instead of the original m-D complex function of n complex\nvariables we optimize a 2m-D real function of 2n real variables:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.optimize</span> <span class=\"k\">import</span> <span class=\"n\">least_squares</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">res_wrapped</span> <span class=\"o\">=</span> <span class=\"n\">least_squares</span><span class=\"p\">(</span><span class=\"n\">f_wrap</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">),</span> <span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">res_wrapped</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">res_wrapped</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"mi\">1</span><span class=\"n\">j</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">z</span>\n<span class=\"go\">(0.49999999999925893+0.49999999999925893j)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id570\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id570\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id571\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id571\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.ivim.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.ivim.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.ivim.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id572\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Cache\" title=\"dipy.reconst.mapmri.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id572\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Cache.cache_clear\" title=\"dipy.reconst.mapmri.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Cache.cache_get\" title=\"dipy.reconst.mapmri.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Cache.cache_set\" title=\"dipy.reconst.mapmri.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id573\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.LooseVersion\" title=\"dipy.reconst.mapmri.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#id573\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.mapmri.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmrifit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit\" title=\"dipy.reconst.mapmri.MapmriFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MapmriFit</span></code></a><a class=\"headerlink\" href=\"#mapmrifit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">MapmriFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">mapmri_coef</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">lopt</em>, <em class=\"sig-param\">errorcode=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_R\" title=\"dipy.reconst.mapmri.MapmriFit.mapmri_R\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_R</span></code></a></dt><dd><p>The MAPMRI rotation matrix</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_coeff\" title=\"dipy.reconst.mapmri.MapmriFit.mapmri_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_coeff</span></code></a></dt><dd><p>The MAPMRI coefficients</p>\n</dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_mu\" title=\"dipy.reconst.mapmri.MapmriFit.mapmri_mu\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mapmri_mu</span></code></a></dt><dd><p>The MAPMRI scale factors</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.fitted_signal\" title=\"dipy.reconst.mapmri.MapmriFit.fitted_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fitted_signal</span></code></a>([gtab])</p></td>\n<td><p>Recovers the fitted signal for the given gradient table.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.msd\" title=\"dipy.reconst.mapmri.MapmriFit.msd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd</span></code></a>()</p></td>\n<td><p>Calculates the analytical Mean Squared Displacement (MSD).</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.ng\" title=\"dipy.reconst.mapmri.MapmriFit.ng\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ng</span></code></a>()</p></td>\n<td><p>Calculates the analytical non-Gaussiannity (NG) <a class=\"reference internal\" href=\"#re70676512d8d-1\" id=\"id574\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.ng_parallel\" title=\"dipy.reconst.mapmri.MapmriFit.ng_parallel\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ng_parallel</span></code></a>()</p></td>\n<td><p>Calculates the analytical parallel non-Gaussiannity (NG) <a class=\"reference internal\" href=\"#rb5d84eec88ee-1\" id=\"id575\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.ng_perpendicular\" title=\"dipy.reconst.mapmri.MapmriFit.ng_perpendicular\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ng_perpendicular</span></code></a>()</p></td>\n<td><p>Calculates the analytical perpendicular non-Gaussiannity (NG) <a class=\"reference internal\" href=\"#r24ee8ed2a494-1\" id=\"id576\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal\" title=\"dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">norm_of_laplacian_signal</span></code></a>()</p></td>\n<td><p>Calculates the norm of the laplacian of the fitted signal <span id=\"id577\">[Rf7f23918a7e7-1]</span>.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.odf\" title=\"dipy.reconst.mapmri.MapmriFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere[,\u00a0s])</p></td>\n<td><p>Calculates the analytical Orientation Distribution Function (ODF) from the signal <a class=\"reference internal\" href=\"#r7702701833a7-1\" id=\"id578\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.odf_sh\" title=\"dipy.reconst.mapmri.MapmriFit.odf_sh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_sh</span></code></a>([s])</p></td>\n<td><p>Calculates the real analytical odf for a given discrete sphere.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.pdf\" title=\"dipy.reconst.mapmri.MapmriFit.pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf</span></code></a>(r_points)</p></td>\n<td><p>Diffusion propagator on a given set of real points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.predict\" title=\"dipy.reconst.mapmri.MapmriFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(qvals_or_gtab[,\u00a0S0])</p></td>\n<td><p>Recovers the reconstructed signal for any qvalue array or gradient table.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.qiv\" title=\"dipy.reconst.mapmri.MapmriFit.qiv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qiv</span></code></a>()</p></td>\n<td><p>Calculates the analytical Q-space Inverse Variance (QIV).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.rtap\" title=\"dipy.reconst.mapmri.MapmriFit.rtap\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtap</span></code></a>()</p></td>\n<td><p>Calculates the analytical return to the axis probability (RTAP) <a class=\"reference internal\" href=\"#r6f4b363492da-1\" id=\"id579\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.rtop\" title=\"dipy.reconst.mapmri.MapmriFit.rtop\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop</span></code></a>()</p></td>\n<td><p>Calculates the analytical return to the origin probability (RTOP) <a class=\"reference internal\" href=\"#re6f1062fb760-1\" id=\"id580\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriFit.rtpp\" title=\"dipy.reconst.mapmri.MapmriFit.rtpp\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtpp</span></code></a>()</p></td>\n<td><p>Calculates the analytical return to the plane probability (RTPP) <a class=\"reference internal\" href=\"#rf9cced748cc9-1\" id=\"id581\">[1]</a> eq.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">mapmri_coef</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">lopt</em>, <em class=\"sig-param\">errorcode=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates diffusion properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>AnalyticalModel</p>\n</dd>\n<dt><strong>mapmri_coef</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>mapmri coefficients</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>scale parameters vector for x, y and z</p>\n</dd>\n<dt><strong>R</strong><span class=\"classifier\">array, shape (3,3)</span></dt><dd><p>rotation matrix</p>\n</dd>\n<dt><strong>lopt</strong><span class=\"classifier\">float,</span></dt><dd><p>regularization weight used for laplacian regularization</p>\n</dd>\n<dt><strong>errorcode</strong><span class=\"classifier\">int</span></dt><dd><p>provides information on whether errors occurred in the fitting\nof each voxel. 0 means no problem, 1 means a LinAlgError\noccurred when trying to invert the design matrix. 2 means the\npositivity constraint was unable to solve the problem. 3 means\nthat after positivity constraint failed, also matrix inversion\nfailed.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.fitted_signal\">\n<code class=\"sig-name descname\">fitted_signal</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.fitted_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Recovers the fitted signal for the given gradient table. If no gradient\ntable is given it recovers the signal for the gtab of the model object.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.mapmri_R\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">mapmri_R</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_R\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The MAPMRI rotation matrix</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.mapmri_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">mapmri_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The MAPMRI coefficients</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.mapmri_mu\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">mapmri_mu</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.mapmri_mu\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The MAPMRI scale factors</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.msd\">\n<code class=\"sig-name descname\">msd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.msd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Mean Squared Displacement (MSD).\nIt is defined as the Laplacian of the origin of the estimated signal\n<a class=\"reference internal\" href=\"#r53ed4361a122-1\" id=\"id582\">[1]</a>. The analytical formula for the MAP-MRI basis was derived in <span id=\"id583\">[R53ed4361a122-2]</span>\neq. (C13, D1).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r53ed4361a122-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id582\">1</a></span></dt>\n<dd><p>Cheng, J., 2014. Estimation and Processing of Ensemble Average</p>\n</dd>\n</dl>\n<p>Propagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.ng\">\n<code class=\"sig-name descname\">ng</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.ng\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical non-Gaussiannity (NG) <a class=\"reference internal\" href=\"#re70676512d8d-1\" id=\"id586\">[1]</a>.\nFor the NG to be meaningful the mapmri scale factors must be\nestimated only on data representing Gaussian diffusion of spins, i.e.,\nbvals smaller than about 2000 s/mm^2 <a class=\"reference internal\" href=\"#re70676512d8d-2\" id=\"id587\">[2]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re70676512d8d-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id574\">1</a>,<a href=\"#id586\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re70676512d8d-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id587\">2</a></span></dt>\n<dd><p>Avram et al. \u201cClinical feasibility of using mean apparent</p>\n</dd>\n</dl>\n<p>propagator (MAP) MRI to characterize brain tissue microstructure\u201d.\nNeuroImage 2015, in press.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.ng_parallel\">\n<code class=\"sig-name descname\">ng_parallel</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.ng_parallel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical parallel non-Gaussiannity (NG) <a class=\"reference internal\" href=\"#rb5d84eec88ee-1\" id=\"id590\">[1]</a>.\nFor the NG to be meaningful the mapmri scale factors must be\nestimated only on data representing Gaussian diffusion of spins, i.e.,\nbvals smaller than about 2000 s/mm^2 <a class=\"reference internal\" href=\"#rb5d84eec88ee-2\" id=\"id591\">[2]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb5d84eec88ee-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id575\">1</a>,<a href=\"#id590\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb5d84eec88ee-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id591\">2</a></span></dt>\n<dd><p>Avram et al. \u201cClinical feasibility of using mean apparent</p>\n</dd>\n</dl>\n<p>propagator (MAP) MRI to characterize brain tissue microstructure\u201d.\nNeuroImage 2015, in press.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.ng_perpendicular\">\n<code class=\"sig-name descname\">ng_perpendicular</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.ng_perpendicular\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical perpendicular non-Gaussiannity (NG)\n<a class=\"reference internal\" href=\"#r24ee8ed2a494-1\" id=\"id594\">[1]</a>. For the NG to be meaningful the mapmri scale factors must be\nestimated only on data representing Gaussian diffusion of spins, i.e.,\nbvals smaller than about 2000 s/mm^2 <a class=\"reference internal\" href=\"#r24ee8ed2a494-2\" id=\"id595\">[2]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r24ee8ed2a494-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id576\">1</a>,<a href=\"#id594\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r24ee8ed2a494-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id595\">2</a></span></dt>\n<dd><p>Avram et al. \u201cClinical feasibility of using mean apparent</p>\n</dd>\n</dl>\n<p>propagator (MAP) MRI to characterize brain tissue microstructure\u201d.\nNeuroImage 2015, in press.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal\">\n<code class=\"sig-name descname\">norm_of_laplacian_signal</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.norm_of_laplacian_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the norm of the laplacian of the fitted signal <span id=\"id598\">[Rf7f23918a7e7-1]</span>.\nThis information could be useful to assess if the extrapolation of the\nfitted signal contains spurious oscillations. A high laplacian may\nindicate that these are present, and any q-space indices that\nuse integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,\nQIV).</p>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">s=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Orientation Distribution Function (ODF)\nfrom the signal <a class=\"reference internal\" href=\"#r7702701833a7-1\" id=\"id600\">[1]</a> Eq. (32).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r7702701833a7-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id578\">1</a>,<a href=\"#id600\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.odf_sh\">\n<code class=\"sig-name descname\">odf_sh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">s=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.odf_sh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the real analytical odf for a given discrete sphere.\nComputes the design matrix of the ODF for the given sphere vertices\nand radial moment <a class=\"reference internal\" href=\"#r8a6380cda485-1\" id=\"id602\">[1]</a> eq. (32). The radial moment s acts as a\nsharpening method. The analytical equation for the spherical ODF basis\nis given in <a href=\"#id986\"><span class=\"problematic\" id=\"id603\">[2]_</span></a> eq. (C8).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8a6380cda485-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id602\">1</a></span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.pdf\">\n<code class=\"sig-name descname\">pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_points</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion propagator on a given set of real points.\nif the array r_points is non writeable, then intermediate\nresults are cached for faster recalculation</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">qvals_or_gtab</em>, <em class=\"sig-param\">S0=100.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Recovers the reconstructed signal for any qvalue array or\ngradient table.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.qiv\">\n<code class=\"sig-name descname\">qiv</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.qiv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Q-space Inverse Variance (QIV).\nIt is defined as the inverse of the Laplacian of the origin of the\nestimated propagator <a class=\"reference internal\" href=\"#rd3765a80e128-1\" id=\"id606\">[1]</a> eq. (22). The analytical formula for the\nMAP-MRI basis was derived in <span id=\"id607\">[Rd3765a80e128-2]</span> eq. (C14, D2).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd3765a80e128-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id606\">1</a></span></dt>\n<dd><p>Hosseinbor et al. \u201cBessel fourier orientation reconstruction</p>\n</dd>\n</dl>\n<p>(bfor): An analytical diffusion propagator reconstruction for hybrid\ndiffusion imaging and computation of q-space indices. NeuroImage 64,\n2013, 650-670.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.rtap\">\n<code class=\"sig-name descname\">rtap</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.rtap\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the axis probability (RTAP)\n<a class=\"reference internal\" href=\"#r6f4b363492da-1\" id=\"id610\">[1]</a> eq. (40, 44a). The analytical formula for the isotropic MAP-MRI\nbasis was derived in <span id=\"id611\">[R6f4b363492da-2]</span> eq. (C11).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6f4b363492da-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id579\">1</a>,<a href=\"#id610\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.rtop\">\n<code class=\"sig-name descname\">rtop</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.rtop\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the origin probability (RTOP)\n<a class=\"reference internal\" href=\"#re6f1062fb760-1\" id=\"id614\">[1]</a> eq. (36, 43). The analytical formula for the isotropic MAP-MRI\nbasis was derived in <span id=\"id615\">[Re6f1062fb760-2]</span> eq. (C11).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re6f1062fb760-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id580\">1</a>,<a href=\"#id614\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriFit.rtpp\">\n<code class=\"sig-name descname\">rtpp</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriFit.rtpp\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the plane probability (RTPP)\n<a class=\"reference internal\" href=\"#rf9cced748cc9-1\" id=\"id618\">[1]</a> eq. (42). The analytical formula for the isotropic MAP-MRI\nbasis was derived in <span id=\"id619\">[Rf9cced748cc9-2]</span> eq. (C11).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf9cced748cc9-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id581\">1</a>,<a href=\"#id618\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmrimodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriModel\" title=\"dipy.reconst.mapmri.MapmriModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MapmriModel</span></code></a><a class=\"headerlink\" href=\"#mapmrimodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.MapmriModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">MapmriModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">laplacian_regularization=True</em>, <em class=\"sig-param\">laplacian_weighting=0.2</em>, <em class=\"sig-param\">positivity_constraint=False</em>, <em class=\"sig-param\">pos_grid=15</em>, <em class=\"sig-param\">pos_radius='adaptive'</em>, <em class=\"sig-param\">anisotropic_scaling=True</em>, <em class=\"sig-param\">eigenvalue_threshold=0.0001</em>, <em class=\"sig-param\">bval_threshold=inf</em>, <em class=\"sig-param\">dti_scale_estimation=True</em>, <em class=\"sig-param\">static_diffusivity=0.0007</em>, <em class=\"sig-param\">cvxpy_solver=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>Mean Apparent Propagator MRI (MAPMRI) <a class=\"reference internal\" href=\"#rb71d87403e8f-1\" id=\"id622\">[1]</a> of the diffusion signal.</p>\n<p>The main idea is to model the diffusion signal as a linear combination of\nthe continuous functions presented in <a class=\"reference internal\" href=\"#rb71d87403e8f-2\" id=\"id623\">[2]</a> but extending it in three\ndimensions.\nThe main difference with the SHORE proposed in <a class=\"reference internal\" href=\"#rb71d87403e8f-3\" id=\"id624\">[3]</a> is that MAPMRI 3D\nextension is provided using a set of three basis functions for the radial\npart, one for the signal along x, one for y and one for z, while <a class=\"reference internal\" href=\"#rb71d87403e8f-3\" id=\"id625\">[3]</a>\nuses one basis function to model the radial part and real Spherical\nHarmonics to model the angular part.\nFrom the MAPMRI coefficients is possible to use the analytical formulae\nto estimate the ODF.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb71d87403e8f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id33\">1</a>,<a href=\"#id622\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id623\">2</a></span></dt>\n<dd><p>Ozarslan E. et al., \u201cSimple harmonic oscillator based reconstruction\nand estimation for one-dimensional q-space magnetic resonance\n1D-SHORE)\u201d, eapoc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-3\"><span class=\"brackets\">3</span><span class=\"fn-backref\">(<a href=\"#id624\">1</a>,<a href=\"#id625\">2</a>)</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and ODF\nestimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cMAPL: Tissue microstructure estimation\nusing Laplacian-regularized MAP-MRI and its application to HCP\ndata.\u201d NeuroImage (2016).</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-5\"><span class=\"brackets\">5</span></dt>\n<dd><p>Cheng, J., 2014. Estimation and Processing of Ensemble Average\nPropagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-6\"><span class=\"brackets\">6</span></dt>\n<dd><p>Hosseinbor et al. \u201cBessel fourier orientation reconstruction\n(bfor): An analytical diffusion propagator reconstruction for hybrid\ndiffusion imaging and computation of q-space indices\u201d. NeuroImage\n64, 2013, 650-670.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-7\"><span class=\"brackets\">7</span></dt>\n<dd><p>Craven et al. \u201cSmoothing Noisy Data with Spline Functions.\u201d\nNUMER MATH 31.4 (1978): 377-403.</p>\n</dd>\n<dt class=\"label\" id=\"rb71d87403e8f-8\"><span class=\"brackets\">8</span></dt>\n<dd><p>Avram et al. \u201cClinical feasibility of using mean apparent\npropagator (MAP) MRI to characterize brain tissue microstructure\u201d.\nNeuroImage 2015, in press.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.MapmriModel.fit\" title=\"dipy.reconst.mapmri.MapmriModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">laplacian_regularization=True</em>, <em class=\"sig-param\">laplacian_weighting=0.2</em>, <em class=\"sig-param\">positivity_constraint=False</em>, <em class=\"sig-param\">pos_grid=15</em>, <em class=\"sig-param\">pos_radius='adaptive'</em>, <em class=\"sig-param\">anisotropic_scaling=True</em>, <em class=\"sig-param\">eigenvalue_threshold=0.0001</em>, <em class=\"sig-param\">bval_threshold=inf</em>, <em class=\"sig-param\">dti_scale_estimation=True</em>, <em class=\"sig-param\">static_diffusivity=0.0007</em>, <em class=\"sig-param\">cvxpy_solver=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Analytical and continuous modeling of the diffusion signal with\nrespect to the MAPMRI basis <a class=\"reference internal\" href=\"#r667c7fc64c9d-1\" id=\"id634\">[1]</a>.</p>\n<p>The main idea is to model the diffusion signal as a linear combination\nof the continuous functions presented in <a class=\"reference internal\" href=\"#r667c7fc64c9d-2\" id=\"id635\">[2]</a> but extending it in three\ndimensions.</p>\n<p>The main difference with the SHORE proposed in <a class=\"reference internal\" href=\"#r667c7fc64c9d-3\" id=\"id636\">[3]</a> is that MAPMRI 3D\nextension is provided using a set of three basis functions for the\nradial part, one for the signal along x, one for y and one for z, while\n<a class=\"reference internal\" href=\"#r667c7fc64c9d-3\" id=\"id637\">[3]</a> uses one basis function to model the radial part and real\nSpherical Harmonics to model the angular part.</p>\n<p>From the MAPMRI coefficients it is possible to estimate various\nq-space indices, the PDF and the ODF.</p>\n<p>The fitting procedure can be constrained using the positivity\nconstraint proposed in <a class=\"reference internal\" href=\"#r667c7fc64c9d-1\" id=\"id638\">[1]</a> and/or the laplacian regularization\nproposed in <a class=\"reference internal\" href=\"#r667c7fc64c9d-4\" id=\"id639\">[4]</a>.</p>\n<p>For the estimation of q-space indices we recommend using the \u2018regular\u2019\nanisotropic implementation of MAPMRI. However, it has been shown that\nthe ODF estimation in this implementation has a bias which\n\u2018squeezes together\u2019 the ODF peaks when there is a crossing at an angle\nsmaller than 90 degrees <a class=\"reference internal\" href=\"#r667c7fc64c9d-4\" id=\"id640\">[4]</a>. When you want to estimate ODFs for\ntractography we therefore recommend using the isotropic implementation\n(which is equivalent to <a class=\"reference internal\" href=\"#r667c7fc64c9d-3\" id=\"id641\">[3]</a>).</p>\n<p>The switch between isotropic and anisotropic can be easily made through\nthe anisotropic_scaling option.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class.\nthe gradient table has to include b0-images.</p>\n</dd>\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>laplacian_regularization: bool,</strong></dt><dd><p>Regularize using the Laplacian of the MAP-MRI basis.</p>\n</dd>\n<dt><strong>laplacian_weighting: string or scalar,</strong></dt><dd><p>The string \u2018GCV\u2019 makes it use generalized cross-validation to find\nthe regularization weight [4]. A scalar sets the regularization\nweight to that value and an array will make it selected the\noptimal weight from the values in the array.</p>\n</dd>\n<dt><strong>positivity_constraint</strong><span class=\"classifier\">bool,</span></dt><dd><p>Constrain the propagator to be positive.</p>\n</dd>\n<dt><strong>pos_grid</strong><span class=\"classifier\">integer,</span></dt><dd><p>The number of points in the grid that is used in the positivity\nconstraint.</p>\n</dd>\n<dt><strong>pos_radius</strong><span class=\"classifier\">float or string,</span></dt><dd><p>If set to a float, the maximum distance the the positivity\nconstraint constrains to posivity is that value. If set to\n<a href=\"#id642\"><span class=\"problematic\" id=\"id643\">`</span></a>adaptive\u2019, the maximum distance is dependent on the estimated\ntissue diffusivity.</p>\n</dd>\n<dt><strong>anisotropic_scaling</strong><span class=\"classifier\">bool,</span></dt><dd><p>If True, uses the standard anisotropic MAP-MRI basis. If False,\nuses the isotropic MAP-MRI basis (equal to 3D-SHORE).</p>\n</dd>\n<dt><strong>eigenvalue_threshold</strong><span class=\"classifier\">float,</span></dt><dd><p>Sets the minimum of the tensor eigenvalues in order to avoid\nstability problem.</p>\n</dd>\n<dt><strong>bval_threshold</strong><span class=\"classifier\">float,</span></dt><dd><p>Sets the b-value threshold to be used in the scale factor\nestimation. In order for the estimated non-Gaussianity to have\nmeaning this value should set to a lower value (b&lt;2000 s/mm^2)\nsuch that the scale factors are estimated on signal points that\nreasonably represent the spins at Gaussian diffusion.</p>\n</dd>\n<dt><strong>dti_scale_estimation</strong><span class=\"classifier\">bool,</span></dt><dd><p>Whether or not DTI fitting is used to estimate the isotropic scale\nfactor for isotropic MAP-MRI.\nWhen set to False the algorithm presets the isotropic tissue\ndiffusivity to static_diffusivity. This vastly increases fitting\nspeed but at the cost of slightly reduced fitting quality. Can\nstill be used in combination with regularization and constraints.</p>\n</dd>\n<dt><strong>static_diffusivity</strong><span class=\"classifier\">float,</span></dt><dd><p>the tissue diffusivity that is used when dti_scale_estimation is\nset to False. The default is that of typical white matter\nD=0.7e-3 _[5].</p>\n</dd>\n<dt><strong>cvxpy_solver</strong><span class=\"classifier\">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint\nwith a particular cvxpy solver. See <a class=\"reference external\" href=\"http://www.cvxpy.org/\">http://www.cvxpy.org/</a> for\ndetails.\nDefault: None (cvxpy chooses its own solver)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r667c7fc64c9d-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id634\">1</a>,<a href=\"#id638\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"r667c7fc64c9d-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id635\">2</a></span></dt>\n<dd><p>Ozarslan E. et al., \u201cSimple harmonic oscillator based\nreconstruction and estimation for one-dimensional q-space\nmagnetic resonance 1D-SHORE)\u201d, Proc Intl Soc Mag Reson Med,\nvol. 16, p. 35., 2008.</p>\n</dd>\n<dt class=\"label\" id=\"r667c7fc64c9d-3\"><span class=\"brackets\">3</span><span class=\"fn-backref\">(<a href=\"#id636\">1</a>,<a href=\"#id637\">2</a>,<a href=\"#id641\">3</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cSimple harmonic oscillator based\nreconstruction and estimation for three-dimensional q-space\nmri\u201d, ISMRM 2009.</p>\n</dd>\n<dt class=\"label\" id=\"r667c7fc64c9d-4\"><span class=\"brackets\">4</span><span class=\"fn-backref\">(<a href=\"#id639\">1</a>,<a href=\"#id640\">2</a>)</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cMAPL: Tissue microstructure estimation\nusing Laplacian-regularized MAP-MRI and its application to HCP\ndata.\u201d NeuroImage (2016).</p>\n</dd>\n<dt class=\"label\" id=\"r667c7fc64c9d-5\"><span class=\"brackets\">5</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and ODF\nestimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>In this example, where the data, gradient table and sphere tessellation\nused for reconstruction are provided, we model the diffusion signal\nwith respect to the SHORE basis and compute the real and analytical\nODF.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">import</span> <span class=\"n\">dsi_voxels</span><span class=\"p\">,</span> <span class=\"n\">default_sphere</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">gtab_</span> <span class=\"o\">=</span> <span class=\"n\">dsi_voxels</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">gtab_</span><span class=\"o\">.</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">gtab_</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                      <span class=\"n\">b0_threshold</span><span class=\"o\">=</span><span class=\"n\">gtab_</span><span class=\"o\">.</span><span class=\"n\">bvals</span><span class=\"o\">.</span><span class=\"n\">min</span><span class=\"p\">())</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.sims.voxel</span> <span class=\"k\">import</span> <span class=\"n\">sticks_and_ball</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">golden_directions</span> <span class=\"o\">=</span> <span class=\"n\">sticks_and_ball</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">0.0015</span><span class=\"p\">,</span> <span class=\"n\">S0</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                                          <span class=\"n\">angles</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span>\n<span class=\"gp\">... </span>                                                  <span class=\"p\">(</span><span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)],</span>\n<span class=\"gp\">... </span>                                          <span class=\"n\">fractions</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                                          <span class=\"n\">snr</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.mapmri</span> <span class=\"k\">import</span> <span class=\"n\">MapmriModel</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">radial_order</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">map_model</span> <span class=\"o\">=</span> <span class=\"n\">MapmriModel</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">radial_order</span><span class=\"o\">=</span><span class=\"n\">radial_order</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mapfit</span> <span class=\"o\">=</span> <span class=\"n\">map_model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">odf</span> <span class=\"o\">=</span> <span class=\"n\">mapfit</span><span class=\"o\">.</span><span class=\"n\">odf</span><span class=\"p\">(</span><span class=\"n\">default_sphere</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.MapmriModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.MapmriModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"optimizer\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.Optimizer\" title=\"dipy.reconst.mapmri.Optimizer\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Optimizer</span></code></a><a class=\"headerlink\" href=\"#optimizer\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.Optimizer\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">Optimizer</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fun</em>, <em class=\"sig-param\">x0</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">method='L-BFGS-B'</em>, <em class=\"sig-param\">jac=None</em>, <em class=\"sig-param\">hess=None</em>, <em class=\"sig-param\">hessp=None</em>, <em class=\"sig-param\">bounds=None</em>, <em class=\"sig-param\">constraints=()</em>, <em class=\"sig-param\">tol=None</em>, <em class=\"sig-param\">callback=None</em>, <em class=\"sig-param\">options=None</em>, <em class=\"sig-param\">evolution=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evolution</strong></dt><dd></dd>\n<dt><strong>fopt</strong></dt><dd></dd>\n<dt><strong>message</strong></dt><dd></dd>\n<dt><strong>nfev</strong></dt><dd></dd>\n<dt><strong>nit</strong></dt><dd></dd>\n<dt><strong>xopt</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 63%\" />\n<col style=\"width: 37%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>print_summary</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">fun</em>, <em class=\"sig-param\">x0</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">method='L-BFGS-B'</em>, <em class=\"sig-param\">jac=None</em>, <em class=\"sig-param\">hess=None</em>, <em class=\"sig-param\">hessp=None</em>, <em class=\"sig-param\">bounds=None</em>, <em class=\"sig-param\">constraints=()</em>, <em class=\"sig-param\">tol=None</em>, <em class=\"sig-param\">callback=None</em>, <em class=\"sig-param\">options=None</em>, <em class=\"sig-param\">evolution=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A class for handling minimization of scalar function of one or more\nvariables.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>fun</strong><span class=\"classifier\">callable</span></dt><dd><p>Objective function.</p>\n</dd>\n<dt><strong>x0</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Initial guess.</p>\n</dd>\n<dt><strong>args</strong><span class=\"classifier\">tuple, optional</span></dt><dd><p>Extra arguments passed to the objective function and its\nderivatives (Jacobian, Hessian).</p>\n</dd>\n<dt><strong>method</strong><span class=\"classifier\">str, optional</span></dt><dd><p>Type of solver.  Should be one of</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li><p>\u2018Nelder-Mead\u2019</p></li>\n<li><p>\u2018Powell\u2019</p></li>\n<li><p>\u2018CG\u2019</p></li>\n<li><p>\u2018BFGS\u2019</p></li>\n<li><p>\u2018Newton-CG\u2019</p></li>\n<li><p>\u2018Anneal\u2019</p></li>\n<li><p>\u2018L-BFGS-B\u2019</p></li>\n<li><p>\u2018TNC\u2019</p></li>\n<li><p>\u2018COBYLA\u2019</p></li>\n<li><p>\u2018SLSQP\u2019</p></li>\n<li><p>\u2018dogleg\u2019</p></li>\n<li><p>\u2018trust-ncg\u2019</p></li>\n</ul>\n</div></blockquote>\n</dd>\n<dt><strong>jac</strong><span class=\"classifier\">bool or callable, optional</span></dt><dd><p>Jacobian of objective function. Only for CG, BFGS, Newton-CG,\ndogleg, trust-ncg.\nIf <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the\nvalue of Jacobian along with the objective function. If False, the\nJacobian will be estimated numerically.\n<cite>jac</cite> can also be a callable returning the Jacobian of the\nobjective. In this case, it must accept the same arguments\nas <cite>fun</cite>.</p>\n</dd>\n<dt><strong>hess, hessp</strong><span class=\"classifier\">callable, optional</span></dt><dd><p>Hessian of objective function or Hessian of objective function\ntimes an arbitrary vector p.  Only for Newton-CG,\ndogleg, trust-ncg.\nOnly one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is\nprovided, then <cite>hessp</cite> will be ignored.  If neither <cite>hess</cite> nor\n<cite>hessp</cite> is provided, then the hessian product will be approximated\nusing finite differences on <cite>jac</cite>. <cite>hessp</cite> must compute the Hessian\ntimes an arbitrary vector.</p>\n</dd>\n<dt><strong>bounds</strong><span class=\"classifier\">sequence, optional</span></dt><dd><p>Bounds for variables (only for L-BFGS-B, TNC and SLSQP).\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(min,</span> <span class=\"pre\">max)</span></code> pairs for each element in <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>, defining\nthe bounds on that parameter. Use None for one of <code class=\"docutils literal notranslate\"><span class=\"pre\">min</span></code> or\n<code class=\"docutils literal notranslate\"><span class=\"pre\">max</span></code> when there is no bound in that direction.</p>\n</dd>\n<dt><strong>constraints</strong><span class=\"classifier\">dict or sequence of dict, optional</span></dt><dd><p>Constraints definition (only for COBYLA and SLSQP).\nEach constraint is defined in a dictionary with fields:</p>\n<blockquote>\n<div><dl class=\"simple\">\n<dt>type<span class=\"classifier\">str</span></dt><dd><p>Constraint type: \u2018eq\u2019 for equality, \u2018ineq\u2019 for inequality.</p>\n</dd>\n<dt>fun<span class=\"classifier\">callable</span></dt><dd><p>The function defining the constraint.</p>\n</dd>\n<dt>jac<span class=\"classifier\">callable, optional</span></dt><dd><p>The Jacobian of <cite>fun</cite> (only for SLSQP).</p>\n</dd>\n<dt>args<span class=\"classifier\">sequence, optional</span></dt><dd><p>Extra arguments to be passed to the function and Jacobian.</p>\n</dd>\n</dl>\n</div></blockquote>\n<p>Equality constraint means that the constraint function result is to\nbe zero whereas inequality means that it is to be non-negative.\nNote that COBYLA only supports inequality constraints.</p>\n</dd>\n<dt><strong>tol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Tolerance for termination. For detailed control, use\nsolver-specific options.</p>\n</dd>\n<dt><strong>callback</strong><span class=\"classifier\">callable, optional</span></dt><dd><p>Called after each iteration, as <code class=\"docutils literal notranslate\"><span class=\"pre\">callback(xk)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">xk</span></code> is\nthe current parameter vector. Only available using Scipy &gt;= 0.12.</p>\n</dd>\n<dt><strong>options</strong><span class=\"classifier\">dict, optional</span></dt><dd><p>A dictionary of solver options. All methods accept the following\ngeneric options:</p>\n<blockquote>\n<div><dl class=\"simple\">\n<dt>maxiter<span class=\"classifier\">int</span></dt><dd><p>Maximum number of iterations to perform.</p>\n</dd>\n<dt>disp<span class=\"classifier\">bool</span></dt><dd><p>Set to True to print convergence messages.</p>\n</dd>\n</dl>\n</div></blockquote>\n<p>For method-specific options, see\n<cite>show_options(\u2018minimize\u2019, method)</cite>.</p>\n</dd>\n<dt><strong>evolution</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>save history of x for each iteration. Only available using Scipy\n&gt;= 0.12.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.optimize.minimize</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.evolution\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">evolution</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.evolution\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.fopt\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">fopt</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.fopt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.message\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">message</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.message\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.nfev\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">nfev</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.nfev\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.nit\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">nit</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.nit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.print_summary\">\n<code class=\"sig-name descname\">print_summary</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.print_summary\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.Optimizer.xopt\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">xopt</code><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.Optimizer.xopt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id649\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.ReconstFit\" title=\"dipy.reconst.mapmri.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a><a class=\"headerlink\" href=\"#id649\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.ReconstFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">ReconstFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.ReconstFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class which holds the fit result of ReconstModel</p>\n<p>For example that could be holding FA or GFA etc.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.ReconstFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.ReconstFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id650\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mapmri.ReconstModel\" title=\"dipy.reconst.mapmri.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id650\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mapmri.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mapmri.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"b-mat\">\n<h3>b_mat<a class=\"headerlink\" href=\"#b-mat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.b_mat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">b_mat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">index_matrix</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.b_mat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the B coefficients from <a class=\"reference internal\" href=\"#rcb3260c94f80-1\" id=\"id651\">[1]</a> Eq. (27).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>index_matrix</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>B</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>B coefficients for the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcb3260c94f80-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id34\">1</a>,<a href=\"#id651\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"b-mat-isotropic\">\n<h3>b_mat_isotropic<a class=\"headerlink\" href=\"#b-mat-isotropic\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.b_mat_isotropic\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">b_mat_isotropic</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">index_matrix</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.b_mat_isotropic\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the isotropic B coefficients from <a class=\"reference internal\" href=\"#r21c472b0c767-1\" id=\"id653\">[1]</a> Fig 8.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>index_matrix</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>ordering of the isotropic basis in j, l, m</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>B</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>B coefficients for the isotropic basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r21c472b0c767-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id35\">1</a>,<a href=\"#id653\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"binomialfloat\">\n<h3>binomialfloat<a class=\"headerlink\" href=\"#binomialfloat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.binomialfloat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">binomialfloat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">k</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.binomialfloat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Custom Binomial function</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id655\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id655\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"create-rspace\">\n<h3>create_rspace<a class=\"headerlink\" href=\"#create-rspace\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.create_rspace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">create_rspace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gridsize</em>, <em class=\"sig-param\">radius_max</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.create_rspace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Create the real space table, that contains the points in which\nto compute the pdf.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gridsize</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>\n</dd>\n<dt><strong>radius_max</strong><span class=\"classifier\">float</span></dt><dd><p>maximal radius in which compute the propagator</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>tab</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"delta\">\n<h3>delta<a class=\"headerlink\" href=\"#delta\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.delta\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">delta</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">m</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.delta\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"factorial2\">\n<h3>factorial2<a class=\"headerlink\" href=\"#factorial2\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.factorial2\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">factorial2</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">exact=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.factorial2\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Double factorial.</p>\n<p>This is the factorial with every second value skipped.  E.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">7!!</span> <span class=\"pre\">=</span> <span class=\"pre\">7</span> <span class=\"pre\">*</span> <span class=\"pre\">5</span>\n<span class=\"pre\">*</span> <span class=\"pre\">3</span> <span class=\"pre\">*</span> <span class=\"pre\">1</span></code>.  It can be approximated numerically as:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd\n    = 2**(n/2) * (n/2)!                           n even\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int or array_like</span></dt><dd><p>Calculate <code class=\"docutils literal notranslate\"><span class=\"pre\">n!!</span></code>.  Arrays are only supported with <cite>exact</cite> set\nto False.  If <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0</span></code>, the return value is 0.</p>\n</dd>\n<dt><strong>exact</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>The result can be approximated rapidly using the gamma-formula\nabove (default).  If <cite>exact</cite> is set to True, calculate the\nanswer exactly using integer arithmetic.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>nff</strong><span class=\"classifier\">float or int</span></dt><dd><p>Double factorial of <cite>n</cite>, as an int or a float depending on\n<cite>exact</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.special</span> <span class=\"k\">import</span> <span class=\"n\">factorial2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial2</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">array(105.00000000000001)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial2</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">105</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gcv-cost-function\">\n<h3>gcv_cost_function<a class=\"headerlink\" href=\"#gcv-cost-function\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.gcv_cost_function\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">gcv_cost_function</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">weight</em>, <em class=\"sig-param\">args</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.gcv_cost_function\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The GCV cost function that is iterated [4].</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"generalized-crossvalidation\">\n<h3>generalized_crossvalidation<a class=\"headerlink\" href=\"#generalized-crossvalidation\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.generalized_crossvalidation\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">generalized_crossvalidation</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">M</em>, <em class=\"sig-param\">LR</em>, <em class=\"sig-param\">gcv_startpoint=0.05</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.generalized_crossvalidation\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized Cross Validation Function <span id=\"id656\">[Rb690cd738504-1]</span> eq. (15).</p>\n<p>Finds optimal regularization weight based on generalized cross-validation.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array (N),</span></dt><dd><p>data array</p>\n</dd>\n<dt><strong>M</strong><span class=\"classifier\">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>\n</dd>\n<dt><strong>LR</strong><span class=\"classifier\">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>\n</dd>\n<dt><strong>gcv_startpoint</strong><span class=\"classifier\">float</span></dt><dd><p>startpoint for the gcv optimization</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>optimal_lambda</strong><span class=\"classifier\">float,</span></dt><dd><p>optimal regularization weight</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"generalized-crossvalidation-array\">\n<h3>generalized_crossvalidation_array<a class=\"headerlink\" href=\"#generalized-crossvalidation-array\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.generalized_crossvalidation_array\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">generalized_crossvalidation_array</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">M</em>, <em class=\"sig-param\">LR</em>, <em class=\"sig-param\">weights_array=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.generalized_crossvalidation_array\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized Cross Validation Function <a class=\"footnote-reference brackets\" href=\"#id444\" id=\"id658\">1</a> eq. (15).</p>\n<p>Here weights_array is a numpy array with all values that should be\nconsidered in the GCV. It will run through the weights until the cost\nfunction starts to increase, then stop and take the last value as the\noptimum weight.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array (N),</span></dt><dd><p>Basis order matrix</p>\n</dd>\n<dt><strong>M</strong><span class=\"classifier\">matrix, shape (N, Ncoef)</span></dt><dd><p>mapmri observation matrix</p>\n</dd>\n<dt><strong>LR</strong><span class=\"classifier\">matrix, shape (N_coef, N_coef)</span></dt><dd><p>regularization matrix</p>\n</dd>\n<dt><strong>weights_array</strong><span class=\"classifier\">array (N_of_weights)</span></dt><dd><p>array of optional regularization weights</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"genlaguerre\">\n<h3>genlaguerre<a class=\"headerlink\" href=\"#genlaguerre\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.genlaguerre\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">genlaguerre</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">alpha</em>, <em class=\"sig-param\">monic=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.genlaguerre\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized (associated) Laguerre polynomial.</p>\n<p>Defined to be the solution of</p>\n<div class=\"math notranslate nohighlight\">\n\\[x\\frac{d^2}{dx^2}L_n^{(\\alpha)}\n  + (\\alpha + 1 - x)\\frac{d}{dx}L_n^{(\\alpha)}\n  + nL_n^{(\\alpha)} = 0,\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\alpha &gt; -1\\)</span>; <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span> is a polynomial\nof degree <span class=\"math notranslate nohighlight\">\\(n\\)</span>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int</span></dt><dd><p>Degree of the polynomial.</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float</span></dt><dd><p>Parameter, must be greater than -1.</p>\n</dd>\n<dt><strong>monic</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If <cite>True</cite>, scale the leading coefficient to be 1. Default is\n<cite>False</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>L</strong><span class=\"classifier\">orthopoly1d</span></dt><dd><p>Generalized Laguerre polynomial.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">laguerre</span></code></dt><dd><p>Laguerre polynomial.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>For fixed <span class=\"math notranslate nohighlight\">\\(\\alpha\\)</span>, the polynomials <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span>\nare orthogonal over <span class=\"math notranslate nohighlight\">\\([0, \\infty)\\)</span> with weight function\n<span class=\"math notranslate nohighlight\">\\(e^{-x}x^\\alpha\\)</span>.</p>\n<p>The Laguerre polynomials are the special case where <span class=\"math notranslate nohighlight\">\\(\\alpha\n= 0\\)</span>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id659\">\n<h3>gradient_table<a class=\"headerlink\" href=\"#id659\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.gradient_table\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">gradient_table</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bvecs=None</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">atol=0.01</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.gradient_table\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A general function for creating diffusion MR gradients.</p>\n<p>It reads, loads and prepares scanner parameters like the b-values and\nb-vectors so that they can be useful during the reconstruction process.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">can be any of the four options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</p></li>\n<li><p>a path for the file which contains an array like the above (1).</p></li>\n<li><p>an array of shape (N, 4) or (4, N). Then this parameter is\nconsidered to be a b-table which contains both bvals and bvecs. In\nthis case the next parameter is skipped.</p></li>\n<li><p>a path for the file which contains an array like the one at (3).</p></li>\n</ol>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">can be any of two options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>\n<li><p>a path for the file which contains an array like the previous.</p></li>\n</ol>\n</dd>\n<dt><strong>big_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse separation time in seconds (default None)</p>\n</dd>\n<dt><strong>small_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse duration time in seconds (default None)</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n<dt><strong>atol</strong><span class=\"classifier\">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>\n</dd>\n<dt><strong>btens</strong><span class=\"classifier\">can be any of three options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>a string specifying the shape of the encoding tensor for all volumes\nin data. Options: \u2018LTE\u2019, \u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to\nlinear, planar, spherical, and \u201ccigar-shaped\u201d tensor encoding.\nTensors are rotated so that linear and cigar tensors are aligned\nwith the corresponding gradient direction and the planar tensor\u2019s\nnormal is aligned with the corresponding gradient direction.\nMagnitude is scaled to match the b-value.</p></li>\n<li><p>an array of strings of shape (N,), (N, 1), or (1, N) specifying\nencoding tensor shape for each volume separately. N corresponds to\nthe number volumes in data. Options for elements in array: \u2018LTE\u2019,\n\u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to linear, planar, spherical, and\n\u201ccigar-shaped\u201d tensor encoding. Tensors are rotated so that linear\nand cigar tensors are aligned with the corresponding gradient\ndirection and the planar tensor\u2019s normal is aligned with the\ncorresponding gradient direction. Magnitude is scaled to match the\nb-value.</p></li>\n<li><p>an array of shape (N,3,3) specifying the b-tensor of each volume\nexactly. N corresponds to the number volumes in data. No rotation or\nscaling is performed.</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<ol class=\"arabic simple\">\n<li><p>Often b0s (b-values which correspond to images without diffusion\nweighting) have 0 values however in some cases the scanner cannot\nprovide b0s of an exact 0 value and it gives a bit higher values\ne.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>\n<li><p>We assume that the minimum number of b-values is 7.</p></li>\n<li><p>B-vectors should be unit vectors.</p></li>\n</ol>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sq2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"hermite\">\n<h3>hermite<a class=\"headerlink\" href=\"#hermite\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.hermite\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">hermite</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">monic=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.hermite\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Physicist\u2019s Hermite polynomial.</p>\n<p>Defined by</p>\n<div class=\"math notranslate nohighlight\">\n\\[H_n(x) = (-1)^ne^{x^2}\\frac{d^n}{dx^n}e^{-x^2};\\]</div>\n<p><span class=\"math notranslate nohighlight\">\\(H_n\\)</span> is a polynomial of degree <span class=\"math notranslate nohighlight\">\\(n\\)</span>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int</span></dt><dd><p>Degree of the polynomial.</p>\n</dd>\n<dt><strong>monic</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If <cite>True</cite>, scale the leading coefficient to be 1. Default is\n<cite>False</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>H</strong><span class=\"classifier\">orthopoly1d</span></dt><dd><p>Hermite polynomial.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The polynomials <span class=\"math notranslate nohighlight\">\\(H_n\\)</span> are orthogonal over <span class=\"math notranslate nohighlight\">\\((-\\infty,\n\\infty)\\)</span> with weight function <span class=\"math notranslate nohighlight\">\\(e^{-x^2}\\)</span>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"isotropic-scale-factor\">\n<h3>isotropic_scale_factor<a class=\"headerlink\" href=\"#isotropic-scale-factor\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.isotropic_scale_factor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">isotropic_scale_factor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">mu_squared</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.isotropic_scale_factor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Estimated isotropic scaling factor _[1] Eq. (49).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>mu_squared</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>squared scale factors of mapmri basis in x, y, z</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>u0</strong><span class=\"classifier\">float</span></dt><dd><p>closest isotropic scale factor for the isotropic basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd2ef405bbccd-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"map-laplace-s\">\n<h3>map_laplace_s<a class=\"headerlink\" href=\"#map-laplace-s\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.map_laplace_s\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">map_laplace_s</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">m</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.map_laplace_s\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>R(m,n) static matrix for Laplacian regularization <span id=\"id661\">[R932dd40ca52e-1]</span> eq. (11).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n, m</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">float</span></dt><dd><p>Analytical integral of <span class=\"math notranslate nohighlight\">\\(\\phi_n''(q) * \\phi_m''(q)\\)</span></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"map-laplace-t\">\n<h3>map_laplace_t<a class=\"headerlink\" href=\"#map-laplace-t\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.map_laplace_t\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">map_laplace_t</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">m</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.map_laplace_t\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>L(m, n) static matrix for Laplacian regularization <span id=\"id663\">[Reb78d789d6c4-1]</span> eq. (12).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n, m</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>T</strong><span class=\"classifier\">float</span></dt><dd><p>Analytical integral of <span class=\"math notranslate nohighlight\">\\(\\phi_n(q) * \\phi_m''(q)\\)</span></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"map-laplace-u\">\n<h3>map_laplace_u<a class=\"headerlink\" href=\"#map-laplace-u\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.map_laplace_u\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">map_laplace_u</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">m</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.map_laplace_u\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>S(n, m) static matrix for Laplacian regularization <span id=\"id665\">[Rb93dd9dab8c9-1]</span> eq. (13).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n, m</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>basis order of the MAP-MRI basis in different directions</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>U</strong><span class=\"classifier\">float,</span></dt><dd><p>Analytical integral of <span class=\"math notranslate nohighlight\">\\(\\phi_n(q) * \\phi_m(q)\\)</span></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-stu-reg-matrices\">\n<h3>mapmri_STU_reg_matrices<a class=\"headerlink\" href=\"#mapmri-stu-reg-matrices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_STU_reg_matrices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_STU_reg_matrices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_STU_reg_matrices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generate the static portions of the Laplacian regularization matrix\naccording to <span id=\"id667\">[R1d585103467a-1]</span> eq. (11, 12, 13).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S, T, U</strong><span class=\"classifier\">Matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-index-matrix\">\n<h3>mapmri_index_matrix<a class=\"headerlink\" href=\"#mapmri-index-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_index_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_index_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_index_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the indices for the MAPMRI <a class=\"reference internal\" href=\"#rb85ba44932df-1\" id=\"id669\">[1]</a> basis in x, y and z.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial order of MAPMRI basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>index_matrix</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb85ba44932df-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id42\">1</a>,<a href=\"#id669\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-k-mu-dependent\">\n<h3>mapmri_isotropic_K_mu_dependent<a class=\"headerlink\" href=\"#mapmri-isotropic-k-mu-dependent\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_K_mu_dependent</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">rgrad</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_K_mu_dependent\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mu dependent part of M. Same trick as with M.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-k-mu-independent\">\n<h3>mapmri_isotropic_K_mu_independent<a class=\"headerlink\" href=\"#mapmri-isotropic-k-mu-independent\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_K_mu_independent</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">rgrad</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_K_mu_independent\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mu independent part of K. Same trick as with M.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-m-mu-dependent\">\n<h3>mapmri_isotropic_M_mu_dependent<a class=\"headerlink\" href=\"#mapmri-isotropic-m-mu-dependent\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_M_mu_dependent</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">qval</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_M_mu_dependent\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computed the mu dependent part of the signal design matrix.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-m-mu-independent\">\n<h3>mapmri_isotropic_M_mu_independent<a class=\"headerlink\" href=\"#mapmri-isotropic-m-mu-independent\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_M_mu_independent</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">q</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_M_mu_independent\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computed the mu independent part of the signal design matrix.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-index-matrix\">\n<h3>mapmri_isotropic_index_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-index-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_index_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_index_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_index_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the indices for the isotropic MAPMRI basis <a class=\"reference internal\" href=\"#rc015c0dc1977-1\" id=\"id671\">[1]</a> Fig 8.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial order of isotropic MAPMRI basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>index_matrix</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>ordering of the basis in x, y, z</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc015c0dc1977-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id43\">1</a>,<a href=\"#id671\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-laplacian-reg-matrix\">\n<h3>mapmri_isotropic_laplacian_reg_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-laplacian-reg-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_laplacian_reg_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the Laplacian regularization matrix for MAP-MRI\u2019s isotropic\nimplementation <span id=\"id673\">[R156f27ca005f-1]</span> eq. (C7).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>LR</strong><span class=\"classifier\">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-laplacian-reg-matrix-from-index-matrix\">\n<h3>mapmri_isotropic_laplacian_reg_matrix_from_index_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">mu</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_laplacian_reg_matrix_from_index_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the Laplacian regularization matrix for MAP-MRI\u2019s isotropic\nimplementation <span id=\"id675\">[Rdcc29394f577-1]</span> eq. (C7).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ind_mat</strong><span class=\"classifier\">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>LR</strong><span class=\"classifier\">Matrix, shape (N_coef, N_coef)</span></dt><dd><p>Laplacian regularization matrix</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-odf-matrix\">\n<h3>mapmri_isotropic_odf_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-odf-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_odf_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_odf_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">s</em>, <em class=\"sig-param\">vertices</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_odf_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the isotropic MAPMRI ODF matrix <a class=\"reference internal\" href=\"#rf7e027186c88-1\" id=\"id677\">[1]</a> Eq. 32 but for the\nisotropic propagator in <a class=\"reference internal\" href=\"#rf7e027186c88-1\" id=\"id678\">[1]</a> eq. (60). Analytical derivation in\n<span id=\"id679\">[Rf7e027186c88-2]</span> eq. (C8).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>\n</dd>\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n<dt><strong>vertices</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf_mat</strong><span class=\"classifier\">Matrix, shape (N_vertices, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to discrete sphere function</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf7e027186c88-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id46\">1</a>,<a href=\"#id677\">2</a>,<a href=\"#id678\">3</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-odf-sh-matrix\">\n<h3>mapmri_isotropic_odf_sh_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-odf-sh-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_odf_sh_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">s</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_odf_sh_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the isotropic MAPMRI ODF matrix <a class=\"reference internal\" href=\"#r18e181ea8d0c-1\" id=\"id682\">[1]</a> Eq. 32 for the isotropic\npropagator in <a class=\"reference internal\" href=\"#r18e181ea8d0c-1\" id=\"id683\">[1]</a> eq. (60). Here we do not compute the sphere function but\nthe spherical harmonics by only integrating the radial part of the\npropagator. We use the same derivation of the ODF in the isotropic\nimplementation as in <span id=\"id684\">[R18e181ea8d0c-2]</span> eq. (C8).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the isotropic MAP-MRI basis</p>\n</dd>\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf_sh_mat</strong><span class=\"classifier\">Matrix, shape (N_sh_coef, N_mapmri_coef)</span></dt><dd><p>ODF design matrix to spherical harmonics</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r18e181ea8d0c-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id47\">1</a>,<a href=\"#id682\">2</a>,<a href=\"#id683\">3</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-phi-matrix\">\n<h3>mapmri_isotropic_phi_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-phi-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_phi_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_phi_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">q</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_phi_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Three dimensional isotropic MAPMRI signal basis function from <a class=\"reference internal\" href=\"#r7485962ae8ea-1\" id=\"id687\">[1]</a>\nEq. (61).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>\n</dd>\n<dt><strong>q</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r7485962ae8ea-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id48\">1</a>,<a href=\"#id687\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-psi-matrix\">\n<h3>mapmri_isotropic_psi_matrix<a class=\"headerlink\" href=\"#mapmri-isotropic-psi-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_psi_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_psi_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">rgrad</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_psi_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Three dimensional isotropic MAPMRI propagator basis function from <a class=\"reference internal\" href=\"#r77a51da75e29-1\" id=\"id689\">[1]</a>\nEq. (61).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>radial order of the mapmri basis.</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>positive isotropic scale factor of the basis</p>\n</dd>\n<dt><strong>rgrad</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r77a51da75e29-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id49\">1</a>,<a href=\"#id689\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-radial-pdf-basis\">\n<h3>mapmri_isotropic_radial_pdf_basis<a class=\"headerlink\" href=\"#mapmri-isotropic-radial-pdf-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_radial_pdf_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">r</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_radial_pdf_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial part of the isotropic 1D-SHORE propagator basis <a class=\"reference internal\" href=\"#r889cbb1a52b7-1\" id=\"id691\">[1]</a> eq. (61).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>j</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>\n</dd>\n<dt><strong>l</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>the spherical harmonic order</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the basis</p>\n</dd>\n<dt><strong>r</strong><span class=\"classifier\">float,</span></dt><dd><p>points in the r-space in which evaluate the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r889cbb1a52b7-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id50\">1</a>,<a href=\"#id691\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-isotropic-radial-signal-basis\">\n<h3>mapmri_isotropic_radial_signal_basis<a class=\"headerlink\" href=\"#mapmri-isotropic-radial-signal-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_isotropic_radial_signal_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">qval</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_isotropic_radial_signal_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Radial part of the isotropic 1D-SHORE signal basis <a class=\"reference internal\" href=\"#r87b99f9c6ca2-1\" id=\"id693\">[1]</a> eq. (61).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>j</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>a positive integer related to the radial order</p>\n</dd>\n<dt><strong>l</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>the spherical harmonic order</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float,</span></dt><dd><p>isotropic scale factor of the basis</p>\n</dd>\n<dt><strong>qval</strong><span class=\"classifier\">float,</span></dt><dd><p>points in the q-space in which evaluate the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r87b99f9c6ca2-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id51\">1</a>,<a href=\"#id693\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-laplacian-reg-matrix\">\n<h3>mapmri_laplacian_reg_matrix<a class=\"headerlink\" href=\"#mapmri-laplacian-reg-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_laplacian_reg_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_laplacian_reg_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">S_mat</em>, <em class=\"sig-param\">T_mat</em>, <em class=\"sig-param\">U_mat</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_laplacian_reg_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Put the Laplacian regularization matrix together <span id=\"id695\">[Rc66aaccd07c1-1]</span> eq. (10).</p>\n<p>The static parts in S, T and U are multiplied and divided by the\nvoxel-specific scale factors.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ind_mat</strong><span class=\"classifier\">matrix (N_coef, 3),</span></dt><dd><p>Basis order matrix</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>\n</dd>\n<dt><strong>S, T, U</strong><span class=\"classifier\">matrices, shape (N_coef,N_coef)</span></dt><dd><p>Regularization submatrices</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>LR</strong><span class=\"classifier\">matrix (N_coef, N_coef),</span></dt><dd><p>Voxel-specific Laplacian regularization matrix</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<p>using Laplacian-regularized MAP-MRI and its application to HCP data.\u201d\nNeuroImage (2016).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-odf-matrix\">\n<h3>mapmri_odf_matrix<a class=\"headerlink\" href=\"#mapmri-odf-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_odf_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_odf_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">s</em>, <em class=\"sig-param\">vertices</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_odf_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the MAPMRI ODF matrix <a class=\"reference internal\" href=\"#re26b9b8173e7-1\" id=\"id697\">[1]</a>  Eq. (33).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>\n</dd>\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n<dt><strong>vertices</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points of the sphere shell in the r-space in which evaluate the ODF</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re26b9b8173e7-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id53\">1</a>,<a href=\"#id697\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-phi-1d\">\n<h3>mapmri_phi_1d<a class=\"headerlink\" href=\"#mapmri-phi-1d\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_phi_1d\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_phi_1d</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">mu</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_phi_1d\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>One dimensional MAPMRI basis function from <a class=\"reference internal\" href=\"#r76e82749e6a0-1\" id=\"id699\">[1]</a> Eq. (4).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>order of the basis</p>\n</dd>\n<dt><strong>q</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float</span></dt><dd><p>scale factor of the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r76e82749e6a0-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id54\">1</a>,<a href=\"#id699\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-phi-matrix\">\n<h3>mapmri_phi_matrix<a class=\"headerlink\" href=\"#mapmri-phi-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_phi_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_phi_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">q_gradients</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_phi_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the MAPMRI phi matrix for the signal <a class=\"reference internal\" href=\"#r3a5a50d36842-1\" id=\"id701\">[1]</a> eq. (23).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>\n</dd>\n<dt><strong>q_gradients</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points in the q-space in which evaluate the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3a5a50d36842-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id55\">1</a>,<a href=\"#id701\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-psi-1d\">\n<h3>mapmri_psi_1d<a class=\"headerlink\" href=\"#mapmri-psi-1d\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_psi_1d\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_psi_1d</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">x</em>, <em class=\"sig-param\">mu</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_psi_1d\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>One dimensional MAPMRI propagator basis function from <a class=\"reference internal\" href=\"#rb9b07bc1eb95-1\" id=\"id703\">[1]</a> Eq. (10).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>order of the basis</p>\n</dd>\n<dt><strong>x</strong><span class=\"classifier\">array, shape (N,)</span></dt><dd><p>points in the r-space in which evaluate the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">float</span></dt><dd><p>scale factor of the basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb9b07bc1eb95-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id56\">1</a>,<a href=\"#id703\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mapmri-psi-matrix\">\n<h3>mapmri_psi_matrix<a class=\"headerlink\" href=\"#mapmri-psi-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mapmri_psi_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mapmri_psi_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">mu</em>, <em class=\"sig-param\">rgrad</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mapmri_psi_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the MAPMRI psi matrix for the propagator <a class=\"reference internal\" href=\"#rf11279199519-1\" id=\"id705\">[1]</a> eq. (22).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>mu</strong><span class=\"classifier\">array, shape (3,)</span></dt><dd><p>scale factors of the basis for x, y, z</p>\n</dd>\n<dt><strong>rgrad</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>points in the r-space in which evaluate the EAP</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf11279199519-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id57\">1</a>,<a href=\"#id705\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mfactorial\">\n<h3>mfactorial<a class=\"headerlink\" href=\"#mfactorial\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.mfactorial\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">mfactorial</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">/</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.mfactorial\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find x!.</p>\n<p>Raise a ValueError if x is negative or non-integral.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id707\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id707\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id708\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id708\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id709\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#id709\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sfactorial\">\n<h3>sfactorial<a class=\"headerlink\" href=\"#sfactorial\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.sfactorial\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">sfactorial</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">exact=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.sfactorial\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The factorial of a number or array of numbers.</p>\n<p>The factorial of non-negative integer <cite>n</cite> is the product of all\npositive integers less than or equal to <cite>n</cite>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>n! = n * (n - 1) * (n - 2) * ... * 1\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int or array_like of ints</span></dt><dd><p>Input values.  If <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0</span></code>, the return value is 0.</p>\n</dd>\n<dt><strong>exact</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, calculate the answer exactly using long integer arithmetic.\nIf False, result is approximated in floating point rapidly using the\n<cite>gamma</cite> function.\nDefault is False.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>nf</strong><span class=\"classifier\">float or int or ndarray</span></dt><dd><p>Factorial of <cite>n</cite>, as integer or float depending on <cite>exact</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For arrays with <code class=\"docutils literal notranslate\"><span class=\"pre\">exact=True</span></code>, the factorial is computed only once, for\nthe largest input, with each other result computed in the process.\nThe output dtype is increased to <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> if necessary.</p>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">exact=False</span></code> the factorial is approximated using the gamma\nfunction:</p>\n<div class=\"math notranslate nohighlight\">\n\\[n! = \\Gamma(n+1)\\]</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.special</span> <span class=\"k\">import</span> <span class=\"n\">factorial</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">array([   6.,   24.,  120.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">array([  6,  24, 120])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">120</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id710\">\n<h3>sph_harm_ind_list<a class=\"headerlink\" href=\"#id710\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.sph_harm_ind_list\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">sph_harm_ind_list</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.sph_harm_ind_list\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical\nharmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>. The results,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">m_list</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">n_list</span></code> are kx1 arrays, where k depends on <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.\nThey can be passed to <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">real_sh_descoteaux_from_index()</span></code> and\n:func:<code class=\"docutils literal notranslate\"><span class=\"pre\">real_sh_tournier_from_index</span></code>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>even int &gt; 0, max order to return</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for SH basis with even and odd order terms</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>m_list</strong><span class=\"classifier\">array</span></dt><dd><p>degrees of even spherical harmonics</p>\n</dd>\n<dt><strong>n_list</strong><span class=\"classifier\">array</span></dt><dd><p>orders of even spherical harmonics</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_descoteaux_from_index</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_tournier_from_index</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id711\">\n<h3>warn<a class=\"headerlink\" href=\"#id711\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mapmri.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mapmri.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mapmri.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id712\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.GradientTable\" title=\"dipy.reconst.mcsd.GradientTable\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a><a class=\"headerlink\" href=\"#id712\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.GradientTable\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">GradientTable</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gradients</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Diffusion gradient information</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">array_like (N, 3)</span></dt><dd><p>Diffusion gradients. The direction of each of these vectors corresponds\nto the b-vector, and the length corresponds to the b-value.</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.gradient_table\" title=\"dipy.reconst.mcsd.gradient_table\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">gradient_table</span></code></a></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>The GradientTable object is immutable. Do NOT assign attributes.\nIf you have your gradient table in a bval &amp; bvec format, we recommend\nusing the factory function gradient_table</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">(N,3) ndarray</span></dt><dd><p>diffusion gradients</p>\n</dd>\n<dt><strong>bvals</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>The b-value, or magnitude, of each gradient direction.</p>\n</dd>\n<dt><strong>qvals: (N,) ndarray</strong></dt><dd><p>The q-value for each gradient direction. Needs big and small\ndelta.</p>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">(N,3) ndarray</span></dt><dd><p>The direction, represented as a unit vector, of each gradient.</p>\n</dd>\n<dt><strong>b0s_mask</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><p>Boolean array indicating which gradients have no diffusion\nweighting, ie b-value is close to 0.</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>Gradients with b-value less than or equal to <cite>b0_threshold</cite> are\nconsidered to not have diffusion weighting.</p>\n</dd>\n<dt><strong>btens</strong><span class=\"classifier\">(N,3,3) ndarray</span></dt><dd><p>The b-tensor of each gradient direction.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 68%\" />\n<col style=\"width: 32%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>b0s_mask</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>bvals</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-odd\"><td><p><strong>bvecs</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>gradient_strength</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-odd\"><td><p><strong>qvals</strong></p></td>\n<td></td>\n</tr>\n<tr class=\"row-even\"><td><p><strong>tau</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gradients</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructor for GradientTable class</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.b0s_mask\">\n<code class=\"sig-name descname\">b0s_mask</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.b0s_mask\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.bvals\">\n<code class=\"sig-name descname\">bvals</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.bvals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.bvecs\">\n<code class=\"sig-name descname\">bvecs</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.bvecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.gradient_strength\">\n<code class=\"sig-name descname\">gradient_strength</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.gradient_strength\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.info\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">info</code><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.info\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.qvals\">\n<code class=\"sig-name descname\">qvals</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.qvals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.GradientTable.tau\">\n<code class=\"sig-name descname\">tau</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.GradientTable.tau\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id713\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.LooseVersion\" title=\"dipy.reconst.mcsd.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#id713\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.mcsd.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"msdeconvfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MSDeconvFit\" title=\"dipy.reconst.mcsd.MSDeconvFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MSDeconvFit</span></code></a><a class=\"headerlink\" href=\"#msdeconvfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.MSDeconvFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">MSDeconvFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">coeff</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MSDeconvFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit\" title=\"dipy.reconst.shm.SphHarmFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmFit</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>all_shm_coeff</strong></dt><dd></dd>\n<dt><strong>shape</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MSDeconvFit.shm_coeff\" title=\"dipy.reconst.mcsd.MSDeconvFit.shm_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm_coeff</span></code></a></dt><dd><p>The spherical harmonic coefficients of the odf</p>\n</dd>\n<dt><strong>volume_fractions</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code>(sphere)</p></td>\n<td><p>Samples the odf function on the points of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code>([gtab,\u00a0S0])</p></td>\n<td><p>Predict the diffusion signal from the model coefficients.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>gfa</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MSDeconvFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">coeff</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MSDeconvFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Abstract class which holds the fit result of MultiShellDeconvModel.\nInherits the SphHarmFit which fits the diffusion data to a spherical\nharmonic model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model: object</strong></dt><dd><p>MultiShellDeconvModel</p>\n</dd>\n<dt><strong>coeff</strong><span class=\"classifier\">array</span></dt><dd><p>Spherical harmonic coefficients for the ODF.</p>\n</dd>\n<dt><strong>mask: ndarray</strong></dt><dd><p>Mask for fitting</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">all_shm_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MSDeconvFit.all_shm_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MSDeconvFit.shm_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shm_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MSDeconvFit.shm_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The spherical harmonic coefficients of the odf</p>\n<p>Make this a property for now, if there is a usecase for modifying\nthe coefficients we can add a setter or expose the coefficients more\ndirectly</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MSDeconvFit.volume_fractions\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">volume_fractions</code><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MSDeconvFit.volume_fractions\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multishelldeconvmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel\" title=\"dipy.reconst.mcsd.MultiShellDeconvModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiShellDeconvModel</span></code></a><a class=\"headerlink\" href=\"#multishelldeconvmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.MultiShellDeconvModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">MultiShellDeconvModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=&lt;dipy.core.sphere.HemiSphere object&gt;</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">iso=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmModel</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel.fit\" title=\"dipy.reconst.mcsd.MultiShellDeconvModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel.predict\" title=\"dipy.reconst.mcsd.MultiShellDeconvModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(params[,\u00a0gtab,\u00a0S0])</p></td>\n<td><p>Compute a signal prediction given spherical harmonic coefficients for the provided GradientTable class instance.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MultiShellDeconvModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">reg_sphere=&lt;dipy.core.sphere.HemiSphere object&gt;</em>, <em class=\"sig-param\">sh_order=8</em>, <em class=\"sig-param\">iso=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Multi-Shell Multi-Tissue Constrained Spherical Deconvolution\n(MSMT-CSD) <a class=\"reference internal\" href=\"#ra7eb3537dac6-1\" id=\"id714\">[1]</a>. This method extends the CSD model proposed in <a class=\"reference internal\" href=\"#ra7eb3537dac6-2\" id=\"id715\">[2]</a> by\nthe estimation of multiple response functions as a function of multiple\nb-values and multiple tissue types.</p>\n<p>Spherical deconvolution computes a fiber orientation distribution\n(FOD), also called fiber ODF (fODF) <a class=\"reference internal\" href=\"#ra7eb3537dac6-2\" id=\"id716\">[2]</a>. The fODF is derived from\ndifferent tissue types and thus overcomes the overestimation of WM in\nGM and CSF areas.</p>\n<p>The response function is based on the different tissue types\nand is provided as input to the MultiShellDeconvModel.\nIt will be used as deconvolution kernel, as described in <a class=\"reference internal\" href=\"#ra7eb3537dac6-2\" id=\"id717\">[2]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>response</strong><span class=\"classifier\">ndarray or MultiShellResponse object</span></dt><dd><p>Pre-computed multi-shell fiber response function in the form of a\nMultiShellResponse object, or simple response function as a ndarray.\nThe later must be of shape (3, len(bvals)-1, 4), because it will be\nconverted into a MultiShellResponse object via the\n<cite>multi_shell_fiber_response</cite> method (important note: the function\n<cite>unique_bvals_tolerance</cite> is used here to select unique bvalues from\ngtab as input). Each column (3,) has two elements. The first is the\neigen-values as a (3,) ndarray and the second is the signal value\nfor the response function without diffusion weighting (S0). Note\nthat in order to use more than three compartments, one must create\na MultiShellResponse object on the side.</p>\n</dd>\n<dt><strong>reg_sphere</strong><span class=\"classifier\">Sphere (optional)</span></dt><dd><p>sphere used to build the regularization B matrix.\nDefault: \u2018symmetric362\u2019.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int (optional)</span></dt><dd><p>maximal spherical harmonics order. Default: 8</p>\n</dd>\n<dt><strong>iso: int (optional)</strong></dt><dd><p>Number of tissue compartments for running the MSMT-CSD. Minimum\nnumber of compartments required is 2.\nDefault: 2</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra7eb3537dac6-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id714\">1</a></span></dt>\n<dd><p>Jeurissen, B., et al. NeuroImage 2014. Multi-tissue constrained\nspherical deconvolution for improved analysis of multi-shell\ndiffusion MRI data</p>\n</dd>\n<dt class=\"label\" id=\"ra7eb3537dac6-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id715\">1</a>,<a href=\"#id716\">2</a>,<a href=\"#id717\">3</a>)</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of\nthe fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical\ndeconvolution</p>\n</dd>\n<dt class=\"label\" id=\"ra7eb3537dac6-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier, J.D, et al. Imaging Systems and Technology\n2012. MRtrix: Diffusion Tractography in Crossing Fiber Regions</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MultiShellDeconvModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MultiShellDeconvModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">params</em>, <em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellDeconvModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute a signal prediction given spherical harmonic coefficients\nfor the provided GradientTable class instance.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The spherical harmonic representation of the FOD from which to make\nthe signal prediction.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>The gradients for which the signal will be predicted. Use the\nmodel\u2019s gradient table by default.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">ndarray or float</span></dt><dd><p>The non diffusion-weighted signal value.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multishellresponse\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.MultiShellResponse\" title=\"dipy.reconst.mcsd.MultiShellResponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiShellResponse</span></code></a><a class=\"headerlink\" href=\"#multishellresponse\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.MultiShellResponse\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">MultiShellResponse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">response</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">shells</em>, <em class=\"sig-param\">S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellResponse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>iso</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MultiShellResponse.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">response</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">shells</em>, <em class=\"sig-param\">S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellResponse.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Estimate Multi Shell response function for multiple tissues and\nmultiple shells.</p>\n<p>The method <cite>multi_shell_fiber_response</cite> allows to create a multi-shell\nfiber response with the right format, for a three compartments model.\nIt can be refered to in order to understand the inputs of this class.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Multi-shell fiber response. The ordering of the responses should\nfollow the same logic as S0.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>Maximal spherical harmonics order.</p>\n</dd>\n<dt><strong>shells</strong><span class=\"classifier\">int</span></dt><dd><p>Number of shells in the data</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">array (3,)</span></dt><dd><p>Signal with no diffusion weighting for each tissue compartments, in\nthe same tissue order as <cite>response</cite>. This S0 can be used for\npredicting from a fit model later on.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.MultiShellResponse.iso\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">iso</code><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.MultiShellResponse.iso\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qpfitter\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.QpFitter\" title=\"dipy.reconst.mcsd.QpFitter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QpFitter</span></code></a><a class=\"headerlink\" href=\"#qpfitter\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.QpFitter\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">QpFitter</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">X</em>, <em class=\"sig-param\">reg</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.QpFitter\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">__call__</span></code>(signal)</p></td>\n<td><p>Call self as a function.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.QpFitter.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">X</em>, <em class=\"sig-param\">reg</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.QpFitter.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Makes use of the quadratic programming solver <cite>solve_qp</cite> to fit the\nmodel. The initialization for the model is done using the warm-start by\ndefault in <cite>CVXPY</cite>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>X</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Matrix to be fit by the QP solver calculated in\n<cite>MultiShellDeconvModel</cite></p>\n</dd>\n<dt><strong>reg</strong><span class=\"classifier\">ndarray</span></dt><dd><p>the regularization B matrix calculated in <cite>MultiShellDeconvModel</cite></p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id721\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.TensorModel\" title=\"dipy.reconst.mcsd.TensorModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a><a class=\"headerlink\" href=\"#id721\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.mcsd.TensorModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">TensorModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.TensorModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Diffusion Tensor</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.TensorModel.fit\" title=\"dipy.reconst.mcsd.TensorModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the DTI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.mcsd.TensorModel.predict\" title=\"dipy.reconst.mcsd.TensorModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(dti_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this TensorModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.TensorModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">fit_method='WLS'</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.TensorModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A Diffusion Tensor Model <a class=\"reference internal\" href=\"#rff40d14a63d0-1\" id=\"id722\">[1]</a>, <a class=\"reference internal\" href=\"#rff40d14a63d0-2\" id=\"id723\">[2]</a>.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>fit_method</strong><span class=\"classifier\">str or callable</span></dt><dd><p>str can be one of the following:</p>\n<dl class=\"simple\">\n<dt>\u2018WLS\u2019 for weighted least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.wls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018LS\u2019 or \u2018OLS\u2019 for ordinary least squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.ols_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018NLLS\u2019 for non-linear least-squares</dt><dd><p><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.nlls_fit_tensor()</span></code></p>\n</dd>\n<dt>\u2018RT\u2019 or \u2018restore\u2019 or \u2018RESTORE\u2019 for RESTORE robust tensor</dt><dd><p>fitting <a class=\"reference internal\" href=\"#rff40d14a63d0-3\" id=\"id724\">[3]</a>\n<code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">dti.restore_fit_tensor()</span></code></p>\n</dd>\n<dt>callable has to have the signature:</dt><dd><p>fit_method(design_matrix, data, <a href=\"#id725\"><span class=\"problematic\" id=\"id726\">*</span></a>args, <a href=\"#id727\"><span class=\"problematic\" id=\"id728\">**</span></a>kwargs)</p>\n</dd>\n</dl>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>Boolean to return (True) or not (False) the S0 values for the fit.</p>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and key-word arguments passed to the</span></dt><dd><p>fit_method. See dti.wls_fit_tensor, dti.ols_fit_tensor for details</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The minimum signal value. Needs to be a strictly positive\nnumber. Default: minimal signal in the data provided to <cite>fit</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In order to increase speed of processing, tensor fitting is done\nsimultaneously over many voxels. Many fit_methods use the \u2018step\u2019\nparameter to set the number of voxels that will be fit at once in each\niteration. This is the chunk size as a number of voxels. A larger step\nvalue should speed things up, but it will also take up more memory. It\nis advisable to keep an eye on memory consumption as this value is\nincreased.</p>\n<p>E.g., in <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter_fit_tensor()</span></code> we have a default step value of\n1e4</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rff40d14a63d0-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id722\">1</a></span></dt>\n<dd><p>Basser, P.J., Mattiello, J., LeBihan, D., 1994. Estimation of\nthe effective self-diffusion tensor from the NMR spin echo. J Magn\nReson B 103, 247-254.</p>\n</dd>\n<dt class=\"label\" id=\"rff40d14a63d0-2\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id723\">2</a></span></dt>\n<dd><p>Basser, P., Pierpaoli, C., 1996. Microstructural and\nphysiological features of tissues elucidated by quantitative\ndiffusion-tensor MRI.  Journal of Magnetic Resonance 111, 209-219.</p>\n</dd>\n<dt class=\"label\" id=\"rff40d14a63d0-3\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id724\">3</a></span></dt>\n<dd><p>Lin-Ching C., Jones D.K., Pierpaoli, C. 2005. RESTORE: Robust\nestimation of tensors by outlier rejection. MRM 53: 1088-1095</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.TensorModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.TensorModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the DTI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal from one voxel.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.mcsd.TensorModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">dti_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.TensorModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this TensorModel class instance given parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>dti_params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The last dimension should have 12 tensor parameters: 3\neigenvalues, followed by the 3 eigenvectors</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"auto-response-msmt\">\n<h3>auto_response_msmt<a class=\"headerlink\" href=\"#auto-response-msmt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.auto_response_msmt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">auto_response_msmt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">tol=20</em>, <em class=\"sig-param\">roi_center=None</em>, <em class=\"sig-param\">roi_radii=10</em>, <em class=\"sig-param\">wm_fa_thr=0.7</em>, <em class=\"sig-param\">gm_fa_thr=0.3</em>, <em class=\"sig-param\">csf_fa_thr=0.15</em>, <em class=\"sig-param\">gm_md_thr=0.001</em>, <em class=\"sig-param\">csf_md_thr=0.0032</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.auto_response_msmt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Automatic estimation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions using FA and MD.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>roi_center</strong><span class=\"classifier\">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is\nthe center of the volume with shape <cite>data.shape[:3]</cite>.</p>\n</dd>\n<dt><strong>roi_radii</strong><span class=\"classifier\">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>\n</dd>\n<dt><strong>wm_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for WM.</p>\n</dd>\n<dt><strong>gm_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for GM.</p>\n</dd>\n<dt><strong>csf_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for CSF.</p>\n</dd>\n<dt><strong>gm_md_thr</strong><span class=\"classifier\">float</span></dt><dd><p>MD threshold for GM.</p>\n</dd>\n<dt><strong>csf_md_thr</strong><span class=\"classifier\">float</span></dt><dd><p>MD threshold for CSF.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response_wm</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>\n</dd>\n<dt><strong>response_gm</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>\n</dd>\n<dt><strong>response_csf</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In msmt-CSD there is an important pre-processing step: the estimation of\nevery tissue\u2019s response function. In order to do this, we look for voxels\ncorresponding to WM, GM and CSF. We get this information from\nmcsd.mask_for_response_msmt(), which returns masks of selected voxels\n(more details are available in the description of the function).</p>\n<p>With the masks, we compute the response functions by using\nmcsd.response_from_mask_msmt(), which returns the <cite>response</cite> for each\ntissue (more details are available in the description of the function).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id732\">\n<h3>fractional_anisotropy<a class=\"headerlink\" href=\"#id732\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.fractional_anisotropy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">fractional_anisotropy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.fractional_anisotropy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return Fractional anisotropy (FA) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>fa</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated FA. Range is 0 &lt;= FA &lt;= 1.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>FA is calculated using the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[FA = \\sqrt{\\frac{1}{2}\\frac{(\\lambda_1-\\lambda_2)^2+(\\lambda_1-\n            \\lambda_3)^2+(\\lambda_2-\\lambda_3)^2}{\\lambda_1^2+\n            \\lambda_2^2+\\lambda_3^2}}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"get-bval-indices\">\n<h3>get_bval_indices<a class=\"headerlink\" href=\"#get-bval-indices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.get_bval_indices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">get_bval_indices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bval</em>, <em class=\"sig-param\">tol=20</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.get_bval_indices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Get indices where the b-value is <cite>bval</cite></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals: ndarray</strong></dt><dd><p>Array containing the b-values</p>\n</dd>\n<dt><strong>bval: float or int</strong></dt><dd><p>b-value to extract indices</p>\n</dd>\n<dt><strong>tol: int</strong></dt><dd><p>The tolerated gap between the b-values to extract\nand the actual b-values.</p>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014</strong></dt><dd></dd>\n<dt><strong>Array of indices where the b-value is `bval`</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id733\">\n<h3>gradient_table<a class=\"headerlink\" href=\"#id733\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.gradient_table\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">gradient_table</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bvecs=None</em>, <em class=\"sig-param\">big_delta=None</em>, <em class=\"sig-param\">small_delta=None</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">atol=0.01</em>, <em class=\"sig-param\">btens=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.gradient_table\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A general function for creating diffusion MR gradients.</p>\n<p>It reads, loads and prepares scanner parameters like the b-values and\nb-vectors so that they can be useful during the reconstruction process.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">can be any of the four options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N,) or (1, N) or (N, 1) with the b-values.</p></li>\n<li><p>a path for the file which contains an array like the above (1).</p></li>\n<li><p>an array of shape (N, 4) or (4, N). Then this parameter is\nconsidered to be a b-table which contains both bvals and bvecs. In\nthis case the next parameter is skipped.</p></li>\n<li><p>a path for the file which contains an array like the one at (3).</p></li>\n</ol>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">can be any of two options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>\n<li><p>a path for the file which contains an array like the previous.</p></li>\n</ol>\n</dd>\n<dt><strong>big_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse separation time in seconds (default None)</p>\n</dd>\n<dt><strong>small_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse duration time in seconds (default None)</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n<dt><strong>atol</strong><span class=\"classifier\">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>\n</dd>\n<dt><strong>btens</strong><span class=\"classifier\">can be any of three options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>a string specifying the shape of the encoding tensor for all volumes\nin data. Options: \u2018LTE\u2019, \u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to\nlinear, planar, spherical, and \u201ccigar-shaped\u201d tensor encoding.\nTensors are rotated so that linear and cigar tensors are aligned\nwith the corresponding gradient direction and the planar tensor\u2019s\nnormal is aligned with the corresponding gradient direction.\nMagnitude is scaled to match the b-value.</p></li>\n<li><p>an array of strings of shape (N,), (N, 1), or (1, N) specifying\nencoding tensor shape for each volume separately. N corresponds to\nthe number volumes in data. Options for elements in array: \u2018LTE\u2019,\n\u2018PTE\u2019, \u2018STE\u2019, \u2018CTE\u2019 corresponding to linear, planar, spherical, and\n\u201ccigar-shaped\u201d tensor encoding. Tensors are rotated so that linear\nand cigar tensors are aligned with the corresponding gradient\ndirection and the planar tensor\u2019s normal is aligned with the\ncorresponding gradient direction. Magnitude is scaled to match the\nb-value.</p></li>\n<li><p>an array of shape (N,3,3) specifying the b-tensor of each volume\nexactly. N corresponds to the number volumes in data. No rotation or\nscaling is performed.</p></li>\n</ol>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<ol class=\"arabic simple\">\n<li><p>Often b0s (b-values which correspond to images without diffusion\nweighting) have 0 values however in some cases the scanner cannot\nprovide b0s of an exact 0 value and it gives a bit higher values\ne.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>\n<li><p>We assume that the minimum number of b-values is 7.</p></li>\n<li><p>B-vectors should be unit vectors.</p></li>\n</ol>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"n\">gradient_table</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvals</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sq2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">True</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table</span><span class=\"p\">(</span><span class=\"n\">bvals</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span><span class=\"o\">.</span><span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span> <span class=\"o\">==</span> <span class=\"n\">bvecs</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mask-for-response-msmt\">\n<h3>mask_for_response_msmt<a class=\"headerlink\" href=\"#mask-for-response-msmt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.mask_for_response_msmt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">mask_for_response_msmt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">roi_center=None</em>, <em class=\"sig-param\">roi_radii=10</em>, <em class=\"sig-param\">wm_fa_thr=0.7</em>, <em class=\"sig-param\">gm_fa_thr=0.2</em>, <em class=\"sig-param\">csf_fa_thr=0.1</em>, <em class=\"sig-param\">gm_md_thr=0.0007</em>, <em class=\"sig-param\">csf_md_thr=0.002</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.mask_for_response_msmt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of masks for multi-shell multi-tissue (msmt) response</dt><dd><p>function using FA and MD.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data (4D)</p>\n</dd>\n<dt><strong>roi_center</strong><span class=\"classifier\">array-like, (3,)</span></dt><dd><p>Center of ROI in data. If center is None, it is assumed that it is\nthe center of the volume with shape <cite>data.shape[:3]</cite>.</p>\n</dd>\n<dt><strong>roi_radii</strong><span class=\"classifier\">int or array-like, (3,)</span></dt><dd><p>radii of cuboid ROI</p>\n</dd>\n<dt><strong>wm_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for WM.</p>\n</dd>\n<dt><strong>gm_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for GM.</p>\n</dd>\n<dt><strong>csf_fa_thr</strong><span class=\"classifier\">float</span></dt><dd><p>FA threshold for CSF.</p>\n</dd>\n<dt><strong>gm_md_thr</strong><span class=\"classifier\">float</span></dt><dd><p>MD threshold for GM.</p>\n</dd>\n<dt><strong>csf_md_thr</strong><span class=\"classifier\">float</span></dt><dd><p>MD threshold for CSF.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mask_wm</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA above the FA threshold\nfor WM.</p>\n</dd>\n<dt><strong>mask_gm</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold\nfor GM and with MD below the MD threshold for GM.</p>\n</dd>\n<dt><strong>mask_csf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Mask of voxels within the ROI and with FA below the FA threshold\nfor CSF and with MD below the MD threshold for CSF.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In msmt-CSD there is an important pre-processing step: the estimation of\nevery tissue\u2019s response function. In order to do this, we look for voxels\ncorresponding to WM, GM and CSF. This function aims to accomplish that by\nreturning a mask of voxels within a ROI and who respect some threshold\nconstraints, for each tissue. More precisely, the WM mask must have a FA\nvalue above a given threshold. The GM mask and CSF mask must have a FA\nbelow given thresholds and a MD below other thresholds. To get the FA and\nMD, we need to fit a Tensor model to the datasets.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id734\">\n<h3>mean_diffusivity<a class=\"headerlink\" href=\"#id734\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.mean_diffusivity\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">mean_diffusivity</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">evals</em>, <em class=\"sig-param\">axis=-1</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.mean_diffusivity\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean Diffusivity (MD) of a diffusion tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>evals</strong><span class=\"classifier\">array-like</span></dt><dd><p>Eigenvalues of a diffusion tensor.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">int</span></dt><dd><p>Axis of <cite>evals</cite> which contains 3 eigenvalues.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>md</strong><span class=\"classifier\">array</span></dt><dd><p>Calculated MD.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>MD is calculated with the following equation:</p>\n<div class=\"math notranslate nohighlight\">\n\\[MD = \\frac{\\lambda_1 + \\lambda_2 + \\lambda_3}{3}\\]</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multi-shell-fiber-response\">\n<h3>multi_shell_fiber_response<a class=\"headerlink\" href=\"#multi-shell-fiber-response\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.multi_shell_fiber_response\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">multi_shell_fiber_response</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">wm_rf</em>, <em class=\"sig-param\">gm_rf</em>, <em class=\"sig-param\">csf_rf</em>, <em class=\"sig-param\">sphere=None</em>, <em class=\"sig-param\">tol=20</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.multi_shell_fiber_response\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fiber response function estimation for multi-shell data.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>Maximum spherical harmonics order.</p>\n</dd>\n<dt><strong>bvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the b-values. Must be unique b-values, like outputed\nby <cite>dipy.core.gradients.unique_bvals_tolerance</cite>.</p>\n</dd>\n<dt><strong>wm_rf</strong><span class=\"classifier\">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the WM tissue, for each bvals.</p>\n</dd>\n<dt><strong>gm_rf</strong><span class=\"classifier\">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the GM tissue, for each bvals.</p>\n</dd>\n<dt><strong>csf_rf</strong><span class=\"classifier\">(4, len(bvals)) ndarray</span></dt><dd><p>Response function of the CSF tissue, for each bvals.</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\"><cite>dipy.core.Sphere</cite> instance, optional</span></dt><dd><p>Sphere where the signal will be evaluated.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>MultiShellResponse</dt><dd><p>MultiShellResponse object.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multi-tissue-basis\">\n<h3>multi_tissue_basis<a class=\"headerlink\" href=\"#multi-tissue-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.multi_tissue_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">multi_tissue_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">iso_comp</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.multi_tissue_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Builds a basis for multi-shell multi-tissue CSD model.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd></dd>\n<dt><strong>iso_comp: int</strong></dt><dd><p>Number of tissue compartments for running the MSMT-CSD. Minimum\nnumber of compartments required is 2.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>B</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Matrix of the spherical harmonics model used to fit the data</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id735\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id735\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id736\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id736\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"response-from-mask-msmt\">\n<h3>response_from_mask_msmt<a class=\"headerlink\" href=\"#response-from-mask-msmt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.response_from_mask_msmt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">response_from_mask_msmt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask_wm</em>, <em class=\"sig-param\">mask_gm</em>, <em class=\"sig-param\">mask_csf</em>, <em class=\"sig-param\">tol=20</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.response_from_mask_msmt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of multi-shell multi-tissue (msmt) response</dt><dd><p>functions from given tissues masks.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>mask_wm</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the WM response function.</p>\n</dd>\n<dt><strong>mask_gm</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the GM response function.</p>\n</dd>\n<dt><strong>mask_csf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the CSF response function.</p>\n</dd>\n<dt><strong>tol</strong><span class=\"classifier\">int</span></dt><dd><p>tolerance gap for b-values clustering. (Default = 20)</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response_wm</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for WM for each unique bvalues (except b0).</p>\n</dd>\n<dt><strong>response_gm</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for GM for each unique bvalues (except b0).</p>\n</dd>\n<dt><strong>response_csf</strong><span class=\"classifier\">ndarray, (len(unique_bvals_tolerance(gtab.bvals))-1, 4)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>) for CSF for each unique bvalues (except b0).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In msmt-CSD there is an important pre-processing step: the estimation of\nevery tissue\u2019s response function. In order to do this, we look for voxels\ncorresponding to WM, GM and CSF. This information can be obtained by using\nmcsd.mask_for_response_msmt() through masks of selected voxels. The present\nfunction uses such masks to compute the msmt response functions.</p>\n<p>For the responses, we base our approach on the function\ncsdeconv.response_from_mask_ssst(), with the added layers of multishell and\nmulti-tissue (see the ssst function for more information about the\ncomputation of the ssst response function). This means that for each tissue\nwe use the previously found masks and loop on them. For each mask, we loop\non the b-values (clustered using the tolerance gap) to get many responses\nand then average them to get one response per tissue.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id737\">\n<h3>response_from_mask_ssst<a class=\"headerlink\" href=\"#id737\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.response_from_mask_ssst\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">response_from_mask_ssst</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.response_from_mask_ssst\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Computation of single-shell single-tissue (ssst) response</dt><dd><p>function from a given mask.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd></dd>\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd><p>diffusion data</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray</span></dt><dd><p>mask from where to compute the response function</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>response</strong><span class=\"classifier\">tuple, (2,)</span></dt><dd><p>(<cite>evals</cite>, <cite>S0</cite>)</p>\n</dd>\n<dt><strong>ratio</strong><span class=\"classifier\">float</span></dt><dd><p>The ratio between smallest versus largest eigenvalue of the response.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In CSD there is an important pre-processing step: the estimation of the\nfiber response function. In order to do this, we look for voxels with very\nanisotropic configurations. This information can be obtained by using\ncsdeconv.mask_for_response_ssst() through a mask of selected voxels\n(see[Ra8b305330c9c-1]_). The present function uses such a mask to compute the ssst\nresponse function.</p>\n<p>For the response we also need to find the average S0 in the ROI. This is\npossible using <cite>gtab.b0s_mask()</cite> we can find all the S0 volumes (which\ncorrespond to b-values equal 0) in the dataset.</p>\n<p>The <cite>response</cite> consists always of a prolate tensor created by averaging\nthe highest and second highest eigenvalues in the ROI with FA higher than\nthreshold. We also include the average S0s.</p>\n<p>We also return the <cite>ratio</cite> which is used for the SDT models.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra8b305330c9c-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2004. Direct estimation of the</p>\n</dd>\n</dl>\n<p>fiber orientation density function from diffusion-weighted MRI\ndata using spherical deconvolution</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id739\">\n<h3>single_tensor<a class=\"headerlink\" href=\"#id739\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.single_tensor\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">single_tensor</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1</em>, <em class=\"sig-param\">evals=None</em>, <em class=\"sig-param\">evecs=None</em>, <em class=\"sig-param\">snr=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.single_tensor\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Simulate diffusion-weighted signals with a single tensor.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Table with information of b-values and gradient directions g.\nNote that if gtab has a btens attribute, simulations will be performed\naccording to the given b-tensor B information.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">double,</span></dt><dd><p>Strength of signal in the presence of no diffusion gradient (also\ncalled the <code class=\"docutils literal notranslate\"><span class=\"pre\">b=0</span></code> value).</p>\n</dd>\n<dt><strong>evals</strong><span class=\"classifier\">(3,) ndarray</span></dt><dd><p>Eigenvalues of the diffusion tensor.  By default, values typical for\nprolate white matter are used.</p>\n</dd>\n<dt><strong>evecs</strong><span class=\"classifier\">(3, 3) ndarray</span></dt><dd><p>Eigenvectors of the tensor.  You can also think of this as a rotation\nmatrix that transforms the direction of the tensor. The eigenvectors\nneed to be column wise.</p>\n</dd>\n<dt><strong>snr</strong><span class=\"classifier\">float</span></dt><dd><p>Signal to noise ratio, assuming Rician noise.  None implies no noise.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(N,) ndarray</span></dt><dd><dl class=\"simple\">\n<dt>Simulated signal:</dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">S(b,</span> <span class=\"pre\">g)</span> <span class=\"pre\">=</span> <span class=\"pre\">S_0</span> <span class=\"pre\">e^(-b</span> <span class=\"pre\">g^T</span> <span class=\"pre\">R</span> <span class=\"pre\">D</span> <span class=\"pre\">R.T</span> <span class=\"pre\">g)</span></code>, if gtab.tens=None\n<code class=\"docutils literal notranslate\"><span class=\"pre\">S(B)</span> <span class=\"pre\">=</span> <span class=\"pre\">S_0</span> <span class=\"pre\">e^(-B:D)</span></code>, if gtab.tens information is given</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcc58d25455ff-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>M. Descoteaux, \u201cHigh Angular Resolution Diffusion MRI: from Local\nEstimation to Segmentation and Tractography\u201d, PhD thesis,\nUniversity of Nice-Sophia Antipolis, p. 42, 2008.</p>\n</dd>\n<dt class=\"label\" id=\"rcc58d25455ff-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>E. Stejskal and J. Tanner, \u201cSpin diffusion measurements: spin echos\nin the presence of a time-dependent field gradient\u201d, Journal of\nChemical Physics, nr. 42, pp. 288\u2013292, 1965.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"solve-qp\">\n<h3>solve_qp<a class=\"headerlink\" href=\"#solve-qp\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.solve_qp\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">solve_qp</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">P</em>, <em class=\"sig-param\">Q</em>, <em class=\"sig-param\">G</em>, <em class=\"sig-param\">H</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.solve_qp\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Helper function to set up and solve the Quadratic Program (QP) in CVXPY.\nA QP problem has the following form:\nminimize      1/2 x\u2019 P x + Q\u2019 x\nsubject to    G x &lt;= H</p>\n<p>Here the QP solver is based on CVXPY and uses OSQP.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>P</strong><span class=\"classifier\">ndarray</span></dt><dd><p>n x n matrix for the primal QP objective function.</p>\n</dd>\n<dt><strong>Q</strong><span class=\"classifier\">ndarray</span></dt><dd><p>n x 1 matrix for the primal QP objective function.</p>\n</dd>\n<dt><strong>G</strong><span class=\"classifier\">ndarray</span></dt><dd><p>m x n matrix for the inequality constraint.</p>\n</dd>\n<dt><strong>H</strong><span class=\"classifier\">ndarray</span></dt><dd><p>m x 1 matrix for the inequality constraint.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array</span></dt><dd><p>Optimal solution to the QP problem.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"unique-bvals-tolerance\">\n<h3>unique_bvals_tolerance<a class=\"headerlink\" href=\"#unique-bvals-tolerance\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.mcsd.unique_bvals_tolerance\">\n<code class=\"sig-prename descclassname\">dipy.reconst.mcsd.</code><code class=\"sig-name descname\">unique_bvals_tolerance</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">tol=20</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.mcsd.unique_bvals_tolerance\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Gives the unique b-values of the data, within a tolerance gap</p>\n<p>The b-values must be regrouped in clusters easily separated by a\ndistance greater than the tolerance gap. If all the b-values of a\ncluster fit within the tolerance gap, the highest b-value is kept.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the b-values</p>\n</dd>\n<dt><strong>tol</strong><span class=\"classifier\">int</span></dt><dd><p>The tolerated gap between the b-values to extract\nand the actual b-values.</p>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014</strong></dt><dd></dd>\n<dt><strong>ubvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the unique b-values using the median value\nfor each cluster</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"meandiffusionkurtosisfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisFit</span></code></a><a class=\"headerlink\" href=\"#meandiffusionkurtosisfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">MeanDiffusionKurtosisFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>S0_hat</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd</span></code></a>()</p></td>\n<td><p>Mean signal diffusitivity (MSD) calculated from the mean signal Diffusion Kurtosis Model.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msk</span></code></a>()</p></td>\n<td><p>Mean signal kurtosis (MSK) calculated from the mean signal Diffusion Kurtosis Model.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(gtab[,\u00a0S0])</p></td>\n<td><p>Given a mean signal diffusion kurtosis model fit, predict the signal on the vertices of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">smt2di</span></code></a>()</p></td>\n<td><p>Computes the intrisic diffusivity from the mean signal diffusional kurtosis parameters assuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#rca2963601d0d-1\" id=\"id742\">[1]</a>, <a class=\"reference internal\" href=\"#rca2963601d0d-2\" id=\"id743\">[2]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">smt2f</span></code></a>()</p></td>\n<td><p>Computes the axonal water fraction from the mean signal kurtosis assuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#r377caa862e0d-1\" id=\"id744\">[1]</a>, <a class=\"reference internal\" href=\"#r377caa862e0d-2\" id=\"id745\">[2]</a></p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">smt2uFA</span></code></a>()</p></td>\n<td><p>Computes the microscopic fractional anisotropy from the mean signal diffusional kurtosis parameters assuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#r2c9f3770f537-1\" id=\"id746\">[1]</a>, <a class=\"reference internal\" href=\"#r2c9f3770f537-2\" id=\"id747\">[2]</a></p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">model_params</em>, <em class=\"sig-param\">model_S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a MeanDiffusionKurtosisFit class instance.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">S0_hat</code><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.S0_hat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd\">\n<code class=\"sig-name descname\">msd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean signal diffusitivity (MSD) calculated from the mean signal\nDiffusion Kurtosis Model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>msd</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Calculated signal mean diffusitivity.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ref84c17533d3-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk\">\n<code class=\"sig-name descname\">msk</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.msk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean signal kurtosis (MSK) calculated from the mean signal\nDiffusion Kurtosis Model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>msk</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Calculated signal mean kurtosis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r380c5d09ae4f-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a mean signal diffusion kurtosis model fit, predict the signal\non the vertices of a sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>This encodes the directions for which a prediction is made</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion weighted signal in each voxel. Default:\nThe fitted S0 value in all voxels if it was fitted. Otherwise 1 in\nall voxels.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated mean signal based on the mean signal kurtosis model</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The predicted signal is given by:\n<span class=\"math notranslate nohighlight\">\\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\\)</span>, where <span class=\"math notranslate nohighlight\">\\(D\\)</span> and <span class=\"math notranslate nohighlight\">\\(k\\)</span> are the\nmean signal diffusivity and mean signal kurtosis.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra7a4992ba6ea-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di\">\n<code class=\"sig-name descname\">smt2di</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2di\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the intrisic diffusivity from the mean signal diffusional\nkurtosis parameters assuming the 2-compartmental spherical mean\ntechnique model <a class=\"reference internal\" href=\"#rca2963601d0d-1\" id=\"id751\">[1]</a>, <a class=\"reference internal\" href=\"#rca2963601d0d-2\" id=\"id752\">[2]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>smt2di</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Intrisic diffusivity computed by converting MSDKI to SMT2.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Computes the intrinsic diffusivity using equation 16 of <a class=\"reference internal\" href=\"#rca2963601d0d-1\" id=\"id753\">[1]</a></p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rca2963601d0d-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id742\">1</a>,<a href=\"#id751\">2</a>,<a href=\"#id753\">3</a>)</span></dt>\n<dd><p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic\nanisotropy misestimation in spherical\u2010mean single diffusion\nencoding MRI. Magnetic Resonance in Medicine (In press).\ndoi: 10.1002/mrm.27606</p>\n</dd>\n<dt class=\"label\" id=\"rca2963601d0d-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id743\">1</a>,<a href=\"#id752\">2</a>)</span></dt>\n<dd><p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi\u2010compartment\nmicroscopic diffusion imaging. Neuroimage 139:346\u2013359.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f\">\n<code class=\"sig-name descname\">smt2f</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2f\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the axonal water fraction from the mean signal kurtosis\nassuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#r377caa862e0d-1\" id=\"id756\">[1]</a>, <a class=\"reference internal\" href=\"#r377caa862e0d-2\" id=\"id757\">[2]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>smt2f</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Axonal volume fraction calculated from MSK.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Computes the axonal water fraction from the mean signal kurtosis\nMSK using equation 17 of <a class=\"reference internal\" href=\"#r377caa862e0d-1\" id=\"id758\">[1]</a></p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r377caa862e0d-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id744\">1</a>,<a href=\"#id756\">2</a>,<a href=\"#id758\">3</a>)</span></dt>\n<dd><p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic\nanisotropy misestimation in spherical\u2010mean single diffusion\nencoding MRI. Magnetic Resonance in Medicine (In press).\ndoi: 10.1002/mrm.27606</p>\n</dd>\n<dt class=\"label\" id=\"r377caa862e0d-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id745\">1</a>,<a href=\"#id757\">2</a>)</span></dt>\n<dd><p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi\u2010compartment\nmicroscopic diffusion imaging. Neuroimage 139:346\u2013359.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA\">\n<code class=\"sig-name descname\">smt2uFA</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisFit.smt2uFA\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the microscopic fractional anisotropy from the mean signal\ndiffusional kurtosis parameters assuming the 2-compartmental spherical\nmean technique model <a class=\"reference internal\" href=\"#r2c9f3770f537-1\" id=\"id761\">[1]</a>, <a class=\"reference internal\" href=\"#r2c9f3770f537-2\" id=\"id762\">[2]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>smt2uFA</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Microscopic fractional anisotropy computed by converting MSDKI to\nSMT2.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Computes the intrinsic diffusivity using equation 10 of <a class=\"reference internal\" href=\"#r2c9f3770f537-1\" id=\"id763\">[1]</a></p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2c9f3770f537-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id746\">1</a>,<a href=\"#id761\">2</a>,<a href=\"#id763\">3</a>)</span></dt>\n<dd><p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic\nanisotropy misestimation in spherical\u2010mean single diffusion\nencoding MRI. Magnetic Resonance in Medicine (In press).\ndoi: 10.1002/mrm.27606</p>\n</dd>\n<dt class=\"label\" id=\"r2c9f3770f537-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id747\">1</a>,<a href=\"#id762\">2</a>)</span></dt>\n<dd><p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi\u2010compartment\nmicroscopic diffusion imaging. Neuroimage 139:346\u2013359.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"meandiffusionkurtosismodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisModel</span></code></a><a class=\"headerlink\" href=\"#meandiffusionkurtosismodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">MeanDiffusionKurtosisModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">bmag=None</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>Mean signal Diffusion Kurtosis Model</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method of the MSDKI model class</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict\" title=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(msdki_params[,\u00a0S0])</p></td>\n<td><p>Predict a signal for this MeanDiffusionKurtosisModel class instance given parameters.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">bmag=None</em>, <em class=\"sig-param\">return_S0_hat=False</em>, <em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Mean Signal Diffusion Kurtosis Model <a class=\"reference internal\" href=\"#r7ed73a81f42d-1\" id=\"id766\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude that the bvalues have to differ to be\nconsidered an unique b-value. Default: derive this value from the\nmaximal b-value provided: <span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, also return S0 values for the fit.</p>\n</dd>\n<dt><strong>args, kwargs</strong><span class=\"classifier\">arguments and keyword arguments passed to the</span></dt><dd></dd>\n<dt><strong>fit_method. See msdki.wls_fit_msdki for details</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r7ed73a81f42d-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id766\">1</a></span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method of the MSDKI model class</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026], g)</span></dt><dd><p>ndarray containing the data signals in its last dimension.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[:-1]</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">msdki_params</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.MeanDiffusionKurtosisModel.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict a signal for this MeanDiffusionKurtosisModel class instance\ngiven parameters.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>msdki_params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The parameters of the mean signal diffusion kurtosis model</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>S</strong><span class=\"classifier\">(\u2026, N) ndarray</span></dt><dd><p>Simulated mean signal based on the mean signal diffusion kurtosis\nmodel</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<dl class=\"simple\">\n<dt>The predicted signal is given by:</dt><dd><p><span class=\"math notranslate nohighlight\">\\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\\)</span>, where <span class=\"math notranslate nohighlight\">\\(D\\)</span> and <span class=\"math notranslate nohighlight\">\\(K\\)</span> are\nthe mean signal diffusivity and mean signal kurtosis.</p>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ree1f3b2a9b45-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id769\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.msdki.ReconstModel\" title=\"dipy.reconst.msdki.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id769\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.msdki.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.msdki.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id770\">\n<h3>auto_attr<a class=\"headerlink\" href=\"#id770\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.auto_attr\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">auto_attr</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.auto_attr\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Decorator to create OneTimeProperty attributes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">method</span></dt><dd><p>The method that will be called the first time to compute a value.\nAfterwards, the method\u2019s name will be a standard attribute holding the\nvalue of this computation.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">MagicProp</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nd\">@auto_attr</span>\n<span class=\"gp\">... </span>    <span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>        <span class=\"k\">return</span> <span class=\"mi\">99</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">MagicProp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"go\">99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"awf-from-msk\">\n<h3>awf_from_msk<a class=\"headerlink\" href=\"#awf-from-msk\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.awf_from_msk\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">awf_from_msk</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">msk</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.awf_from_msk\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the axonal water fraction from the mean signal kurtosis\nassuming the 2-compartmental spherical mean technique model <a class=\"reference internal\" href=\"#r01d7e07fd924-1\" id=\"id771\">[1]</a>, <a class=\"reference internal\" href=\"#r01d7e07fd924-2\" id=\"id772\">[2]</a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>msk</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026])</span></dt><dd><p>Mean signal kurtosis (msk)</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">ndarray, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that should be\nanalyzed that has the same shape of the msdki parameters</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>smt2f</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Computes the axonal water fraction from the mean signal kurtosis\nMSK using equation 17 of <a class=\"reference internal\" href=\"#r01d7e07fd924-1\" id=\"id773\">[1]</a></p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r01d7e07fd924-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id58\">1</a>,<a href=\"#id771\">2</a>,<a href=\"#id773\">3</a>)</span></dt>\n<dd><p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic\nanisotropy misestimation in spherical\u2010mean single diffusion\nencoding MRI. Magnetic Resonance in Medicine (In press).\ndoi: 10.1002/mrm.27606</p>\n</dd>\n<dt class=\"label\" id=\"r01d7e07fd924-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id59\">1</a>,<a href=\"#id772\">2</a>)</span></dt>\n<dd><p>Kaden E, Kelm ND, Carson RP, et al. (2016) Multi\u2010compartment\nmicroscopic diffusion imaging. Neuroimage 139:346\u2013359.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id776\">\n<h3>check_multi_b<a class=\"headerlink\" href=\"#id776\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.check_multi_b\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">check_multi_b</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">n_bvals</em>, <em class=\"sig-param\">non_zero=True</em>, <em class=\"sig-param\">bmag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.check_multi_b\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Check if you have enough different b-values in your gradient table</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance.</span></dt><dd></dd>\n<dt><strong>n_bvals</strong><span class=\"classifier\">int</span></dt><dd><p>The number of different b-values you are checking for.</p>\n</dd>\n<dt><strong>non_zero</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to check only non-zero bvalues. In this case, we will require\nat least <cite>n_bvals</cite> <em>non-zero</em> b-values (where non-zero is defined\ndepending on the <cite>gtab</cite> object\u2019s <cite>b0_threshold</cite> attribute)</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude of the b-values used. The function will\nnormalize the b-values relative <span class=\"math notranslate nohighlight\">\\(10^{bmag}\\)</span>. Default: derive this\nvalue from the maximal b-value provided:\n<span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>bool</strong><span class=\"classifier\">Whether there are at least <cite>n_bvals</cite> different b-values in the</span></dt><dd></dd>\n<dt>gradient table used.</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id777\">\n<h3>design_matrix<a class=\"headerlink\" href=\"#id777\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ubvals</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for the mean signal diffusion kurtosis model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ubvals</strong><span class=\"classifier\">array</span></dt><dd><p>Containing the unique b-values of the data.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (nb, 3)</span></dt><dd><p>Design matrix or B matrix for the mean signal diffusion kurtosis\nmodel assuming that parameters are in the following order:\ndesign_matrix[j, :] = (msd, msk, S0)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"mean-signal-bvalue\">\n<h3>mean_signal_bvalue<a class=\"headerlink\" href=\"#mean-signal-bvalue\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.mean_signal_bvalue\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">mean_signal_bvalue</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">bmag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.mean_signal_bvalue\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the average signal across different diffusion directions\nfor each unique b-value</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026], g)</span></dt><dd><p>ndarray containing the data signals in its last dimension.</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table containing diffusion acquisition parameters.</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">The order of magnitude that the bvalues have to differ to be</span></dt><dd><p>considered an unique b-value. Default: derive this value from the\nmaximal b-value provided: <span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>msignal</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026, nub])</span></dt><dd><p>Mean signal along all gradient directions for each unique b-value\nNote that the last dimension contains the signal means and nub is the\nnumber of unique b-values.</p>\n</dd>\n<dt><strong>ng</strong><span class=\"classifier\">ndarray(nub)</span></dt><dd><p>Number of gradient directions used to compute the mean signal for\nall unique b-values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This function assumes that directions are evenly sampled on the sphere or\non the hemisphere</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"msdki-prediction\">\n<h3>msdki_prediction<a class=\"headerlink\" href=\"#msdki-prediction\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.msdki_prediction\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">msdki_prediction</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">msdki_params</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.msdki_prediction\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the mean signal given the parameters of the mean signal DKI, an\nGradientTable object and S0 signal.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026], 2)</span></dt><dd><p>Array containing the mean signal diffusivity and mean signal kurtosis\nin its last axis</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The gradient table for this prediction</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or ndarray (optional)</span></dt><dd><p>The non diffusion-weighted signal in every voxel, or across all\nvoxels. Default: 1</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<dl class=\"simple\">\n<dt>The predicted signal is given by:</dt><dd><p><span class=\"math notranslate nohighlight\">\\(MS(b) = S_0 * exp(-bD + 1/6 b^{2} D^{2} K)\\)</span>, where <span class=\"math notranslate nohighlight\">\\(D\\)</span> and <span class=\"math notranslate nohighlight\">\\(K\\)</span> are the\nmean signal diffusivity and mean signal kurtosis.</p>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb8c673c09080-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain (Doctoral\nthesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"msk-from-awf\">\n<h3>msk_from_awf<a class=\"headerlink\" href=\"#msk-from-awf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.msk_from_awf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">msk_from_awf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">f</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.msk_from_awf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes mean signal kurtosis from axonal water fraction estimates of the\nSMT2 model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>f</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026])</span></dt><dd><p>ndarray containing the axonal volume fraction estimate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>msk</strong><span class=\"classifier\">ndarray(nub)</span></dt><dd><p>Mean signal kurtosis (msk)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Computes mean signal kurtosis using equations 17 of <a class=\"reference internal\" href=\"#rb570a5c6fee8-1\" id=\"id779\">[1]</a></p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb570a5c6fee8-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id779\">1</a></span></dt>\n<dd><p>Neto Henriques R, Jespersen SN, Shemesh N (2019). Microscopic\nanisotropy misestimation in spherical\u2010mean single diffusion\nencoding MRI. Magnetic Resonance in Medicine (In press).\ndoi: 10.1002/mrm.27606</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id781\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id781\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"round-bvals\">\n<h3>round_bvals<a class=\"headerlink\" href=\"#round-bvals\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.round_bvals\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">round_bvals</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bmag=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.round_bvals\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>\u201cThis function rounds the b-values</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the b-values</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude to round the b-values. If not given b-values\nwill be rounded relative to the order of magnitude\n<span class=\"math notranslate nohighlight\">\\(bmag = (bmagmax - 1)\\)</span>, where bmaxmag is the magnitude order of the\nlarger b-value.</p>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014</strong></dt><dd></dd>\n<dt><strong>rbvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the rounded b-values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"unique-bvals-magnitude\">\n<h3>unique_bvals_magnitude<a class=\"headerlink\" href=\"#unique-bvals-magnitude\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.unique_bvals_magnitude\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">unique_bvals_magnitude</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvals</em>, <em class=\"sig-param\">bmag=None</em>, <em class=\"sig-param\">rbvals=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.unique_bvals_magnitude\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>This function gives the unique rounded b-values of the data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the b-values</p>\n</dd>\n<dt><strong>bmag</strong><span class=\"classifier\">int</span></dt><dd><p>The order of magnitude that the bvalues have to differ to be\nconsidered an unique b-value. B-values are also rounded up to\nthis order of magnitude. Default: derive this value from the\nmaximal b-value provided: <span class=\"math notranslate nohighlight\">\\(bmag=log_{10}(max(bvals)) - 1\\)</span>.</p>\n</dd>\n<dt><strong>rbvals</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True function also returns all individual rounded b-values.\nDefault: False</p>\n</dd>\n<dt><strong>Returns</strong></dt><dd></dd>\n<dt><strong>\u2014\u2014</strong></dt><dd></dd>\n<dt><strong>ubvals</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array containing the rounded unique b-values</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"wls-fit-msdki\">\n<h3>wls_fit_msdki<a class=\"headerlink\" href=\"#wls-fit-msdki\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.msdki.wls_fit_msdki\">\n<code class=\"sig-prename descclassname\">dipy.reconst.msdki.</code><code class=\"sig-name descname\">wls_fit_msdki</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">design_matrix</em>, <em class=\"sig-param\">msignal</em>, <em class=\"sig-param\">ng</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">min_signal=0.0001</em>, <em class=\"sig-param\">return_S0_hat=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.msdki.wls_fit_msdki\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fits the mean signal diffusion kurtosis imaging based on a weighted\nleast square solution <a class=\"reference internal\" href=\"#rc9bf1f124f2b-1\" id=\"id782\">[1]</a>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (nub, 3)</span></dt><dd><p>Design matrix holding the covariants used to solve for the regression\ncoefficients of the mean signal diffusion kurtosis model. Note that\nnub is the number of unique b-values</p>\n</dd>\n<dt><strong>msignal</strong><span class=\"classifier\">ndarray ([X, Y, Z, \u2026, nub])</span></dt><dd><p>Mean signal along all gradient directions for each unique b-value\nNote that the last dimension should contain the signal means and nub\nis the number of unique b-values.</p>\n</dd>\n<dt><strong>ng</strong><span class=\"classifier\">ndarray(nub)</span></dt><dd><p>Number of gradient directions used to compute the mean signal for\nall unique b-values</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed that has the shape data.shape[:-1]</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Voxel with mean signal intensities lower than the min positive signal\nare not processed. Default: 0.0001</p>\n</dd>\n<dt><strong>return_S0_hat</strong><span class=\"classifier\">bool</span></dt><dd><p>If True, also return S0 values for the fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>params</strong><span class=\"classifier\">array (\u2026, 2)</span></dt><dd><p>Containing the mean signal diffusivity and mean signal kurtosis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc9bf1f124f2b-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id60\">1</a>,<a href=\"#id782\">2</a>)</span></dt>\n<dd><p>Henriques, R.N., 2018. Advanced Methods for Diffusion MRI Data\nAnalysis and their Application to the Healthy Ageing Brain\n(Doctoral thesis). Downing College, University of Cambridge.\n<a class=\"reference external\" href=\"https://doi.org/10.17863/CAM.29356\">https://doi.org/10.17863/CAM.29356</a></p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"callablearray\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.CallableArray\" title=\"dipy.reconst.multi_voxel.CallableArray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CallableArray</span></code></a><a class=\"headerlink\" href=\"#callablearray\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.multi_voxel.CallableArray\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">CallableArray</code><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.CallableArray\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">numpy.ndarray</span></code></p>\n<p>An array which can be called like a function</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">T</span></code></dt><dd><p>The transposed array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>\n</dd>\n<dt><a class=\"reference external\" href=\"https://docs.python.org/3/library/ctypes.html#module-ctypes\" title=\"(in Python v3.9)\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ctypes</span></code></a></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array\u2019s data.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dtype</span></code></dt><dd><p>Data-type of the array\u2019s elements.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">imag</span></code></dt><dd><p>The imaginary part of the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ndim</span></code></dt><dd><p>Number of array dimensions.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">real</span></code></dt><dd><p>The real part of the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">size</span></code></dt><dd><p>Number of elements in the array.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">__call__</span></code>(*args,\u00a0**kwargs)</p></td>\n<td><p>Call self as a function.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">all</span></code>([axis,\u00a0out,\u00a0keepdims])</p></td>\n<td><p>Returns True if all elements evaluate to True.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">any</span></code>([axis,\u00a0out,\u00a0keepdims])</p></td>\n<td><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">argmax</span></code>([axis,\u00a0out])</p></td>\n<td><p>Return indices of the maximum values along the given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">argmin</span></code>([axis,\u00a0out])</p></td>\n<td><p>Return indices of the minimum values along the given axis of <cite>a</cite>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">argpartition</span></code>(kth[,\u00a0axis,\u00a0kind,\u00a0order])</p></td>\n<td><p>Returns the indices that would partition this array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">argsort</span></code>([axis,\u00a0kind,\u00a0order])</p></td>\n<td><p>Returns the indices that would sort this array.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">astype</span></code>(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])</p></td>\n<td><p>Copy of the array, cast to a specified type.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">byteswap</span></code>([inplace])</p></td>\n<td><p>Swap the bytes of the array elements</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">choose</span></code>(choices[,\u00a0out,\u00a0mode])</p></td>\n<td><p>Use an index array to construct a new array from a set of choices.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">clip</span></code>([min,\u00a0max,\u00a0out])</p></td>\n<td><p>Return an array whose values are limited to <code class=\"docutils literal notranslate\"><span class=\"pre\">[min,</span> <span class=\"pre\">max]</span></code>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">compress</span></code>(condition[,\u00a0axis,\u00a0out])</p></td>\n<td><p>Return selected slices of this array along given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">conj</span></code>()</p></td>\n<td><p>Complex-conjugate all elements.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">conjugate</span></code>()</p></td>\n<td><p>Return the complex conjugate, element-wise.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">copy</span></code>([order])</p></td>\n<td><p>Return a copy of the array.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cumprod</span></code>([axis,\u00a0dtype,\u00a0out])</p></td>\n<td><p>Return the cumulative product of the elements along the given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cumsum</span></code>([axis,\u00a0dtype,\u00a0out])</p></td>\n<td><p>Return the cumulative sum of the elements along the given axis.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">diagonal</span></code>([offset,\u00a0axis1,\u00a0axis2])</p></td>\n<td><p>Return specified diagonals.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dot</span></code>(b[,\u00a0out])</p></td>\n<td><p>Dot product of two arrays.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dump</span></code>(file)</p></td>\n<td><p>Dump a pickle of the array to the specified file.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">dumps</span></code>()</p></td>\n<td><p>Returns the pickle of the array as a string.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fill</span></code>(value)</p></td>\n<td><p>Fill the array with a scalar value.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">flatten</span></code>([order])</p></td>\n<td><p>Return a copy of the array collapsed into one dimension.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">getfield</span></code>(dtype[,\u00a0offset])</p></td>\n<td><p>Returns a field of the given array as a certain type.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">item</span></code>(*args)</p></td>\n<td><p>Copy an element of an array to a standard Python scalar and return it.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">itemset</span></code>(*args)</p></td>\n<td><p>Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">max</span></code>([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])</p></td>\n<td><p>Return the maximum along a given axis.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean</span></code>([axis,\u00a0dtype,\u00a0out,\u00a0keepdims])</p></td>\n<td><p>Returns the average of the array elements along given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">min</span></code>([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])</p></td>\n<td><p>Return the minimum along a given axis.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">newbyteorder</span></code>([new_order])</p></td>\n<td><p>Return the array with the same data viewed with a different byte order.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nonzero</span></code>()</p></td>\n<td><p>Return the indices of the elements that are non-zero.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">partition</span></code>(kth[,\u00a0axis,\u00a0kind,\u00a0order])</p></td>\n<td><p>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">prod</span></code>([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0\u2026])</p></td>\n<td><p>Return the product of the array elements over the given axis</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ptp</span></code>([axis,\u00a0out,\u00a0keepdims])</p></td>\n<td><p>Peak to peak (maximum - minimum) value along a given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">put</span></code>(indices,\u00a0values[,\u00a0mode])</p></td>\n<td><p>Set <code class=\"docutils literal notranslate\"><span class=\"pre\">a.flat[n]</span> <span class=\"pre\">=</span> <span class=\"pre\">values[n]</span></code> for all <cite>n</cite> in indices.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">ravel</span></code>([order])</p></td>\n<td><p>Return a flattened array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">repeat</span></code>(repeats[,\u00a0axis])</p></td>\n<td><p>Repeat elements of an array.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">reshape</span></code>(shape[,\u00a0order])</p></td>\n<td><p>Returns an array containing the same data with a new shape.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">resize</span></code>(new_shape[,\u00a0refcheck])</p></td>\n<td><p>Change shape and size of array in-place.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">round</span></code>([decimals,\u00a0out])</p></td>\n<td><p>Return <cite>a</cite> with each element rounded to the given number of decimals.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">searchsorted</span></code>(v[,\u00a0side,\u00a0sorter])</p></td>\n<td><p>Find indices where elements of v should be inserted in a to maintain order.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">setfield</span></code>(val,\u00a0dtype[,\u00a0offset])</p></td>\n<td><p>Put a value into a specified place in a field defined by a data-type.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">setflags</span></code>([write,\u00a0align,\u00a0uic])</p></td>\n<td><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sort</span></code>([axis,\u00a0kind,\u00a0order])</p></td>\n<td><p>Sort an array in-place.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">squeeze</span></code>([axis])</p></td>\n<td><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">std</span></code>([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])</p></td>\n<td><p>Returns the standard deviation of the array elements along given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sum</span></code>([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])</p></td>\n<td><p>Return the sum of the array elements over the given axis.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">swapaxes</span></code>(axis1,\u00a0axis2)</p></td>\n<td><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">take</span></code>(indices[,\u00a0axis,\u00a0out,\u00a0mode])</p></td>\n<td><p>Return an array formed from the elements of <cite>a</cite> at the given indices.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tobytes</span></code>([order])</p></td>\n<td><p>Construct Python bytes containing the raw data bytes in the array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tofile</span></code>(fid[,\u00a0sep,\u00a0format])</p></td>\n<td><p>Write array to a file as text or binary (default).</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tolist</span></code>()</p></td>\n<td><p>Return the array as an <code class=\"docutils literal notranslate\"><span class=\"pre\">a.ndim</span></code>-levels deep nested list of Python scalars.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">tostring</span></code>([order])</p></td>\n<td><p>A compatibility alias for <cite>tobytes</cite>, with exactly the same behavior.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">trace</span></code>([offset,\u00a0axis1,\u00a0axis2,\u00a0dtype,\u00a0out])</p></td>\n<td><p>Return the sum along diagonals of the array.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">transpose</span></code>(*axes)</p></td>\n<td><p>Returns a view of the array with axes transposed.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">var</span></code>([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])</p></td>\n<td><p>Returns the variance of the array elements, along given axis.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">view</span></code>([dtype][,\u00a0type])</p></td>\n<td><p>New view of array with the same data.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.multi_voxel.CallableArray.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.CallableArray.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"multivoxelfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit\" title=\"dipy.reconst.multi_voxel.MultiVoxelFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiVoxelFit</span></code></a><a class=\"headerlink\" href=\"#multivoxelfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.multi_voxel.MultiVoxelFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">MultiVoxelFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">fit_array</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p>Holds an array of fits and allows access to their attributes and\nmethods</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit.predict\" title=\"dipy.reconst.multi_voxel.MultiVoxelFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(*args,\u00a0**kwargs)</p></td>\n<td><p>Predict for the multi-voxel object using each single-object\u2019s prediction API, with S0 provided from an array.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.multi_voxel.MultiVoxelFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">fit_array</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.multi_voxel.MultiVoxelFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict for the multi-voxel object using each single-object\u2019s\nprediction API, with S0 provided from an array.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.multi_voxel.MultiVoxelFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.MultiVoxelFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id784\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.multi_voxel.ReconstFit\" title=\"dipy.reconst.multi_voxel.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a><a class=\"headerlink\" href=\"#id784\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.multi_voxel.ReconstFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">ReconstFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.ReconstFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class which holds the fit result of ReconstModel</p>\n<p>For example that could be holding FA or GFA etc.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.multi_voxel.ReconstFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.ReconstFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"as-strided\">\n<h3>as_strided<a class=\"headerlink\" href=\"#as-strided\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.multi_voxel.as_strided\">\n<code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">as_strided</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">shape=None</em>, <em class=\"sig-param\">strides=None</em>, <em class=\"sig-param\">subok=False</em>, <em class=\"sig-param\">writeable=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.as_strided\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Create a view into the array with the given shape and strides.</p>\n<div class=\"admonition warning\">\n<p class=\"admonition-title\">Warning</p>\n<p>This function has to be used with extreme care, see notes.</p>\n</div>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>x</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Array to create a new.</p>\n</dd>\n<dt><strong>shape</strong><span class=\"classifier\">sequence of int, optional</span></dt><dd><p>The shape of the new array. Defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">x.shape</span></code>.</p>\n</dd>\n<dt><strong>strides</strong><span class=\"classifier\">sequence of int, optional</span></dt><dd><p>The strides of the new array. Defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">x.strides</span></code>.</p>\n</dd>\n<dt><strong>subok</strong><span class=\"classifier\">bool, optional</span></dt><dd><div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.10.</span></p>\n</div>\n<p>If True, subclasses are preserved.</p>\n</dd>\n<dt><strong>writeable</strong><span class=\"classifier\">bool, optional</span></dt><dd><div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.12.</span></p>\n</div>\n<p>If set to False, the returned array will always be readonly.\nOtherwise it will be writable if the original array was. It\nis advisable to set this to False if possible (see Notes).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>view</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">broadcast_to</span></code></dt><dd><p>broadcast an array to a given shape.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">reshape</span></code></dt><dd><p>reshape an array.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">as_strided</span></code> creates a view into the array given the exact strides\nand shape. This means it manipulates the internal data structure of\nndarray and, if done incorrectly, the array elements can point to\ninvalid memory and can corrupt results or crash your program.\nIt is advisable to always use the original <code class=\"docutils literal notranslate\"><span class=\"pre\">x.strides</span></code> when\ncalculating new strides to avoid reliance on a contiguous memory\nlayout.</p>\n<p>Furthermore, arrays created with this function often contain self\noverlapping memory, so that two elements are identical.\nVectorized write operations on such arrays will typically be\nunpredictable. They may even give different results for small, large,\nor transposed arrays.\nSince writing to these arrays has to be tested and done with great\ncare, you may want to use <code class=\"docutils literal notranslate\"><span class=\"pre\">writeable=False</span></code> to avoid accidental write\noperations.</p>\n<p>For these reasons it is advisable to avoid <code class=\"docutils literal notranslate\"><span class=\"pre\">as_strided</span></code> when\npossible.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id785\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id785\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.multi_voxel.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id786\">\n<h3>ndindex<a class=\"headerlink\" href=\"#id786\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.multi_voxel.ndindex\">\n<code class=\"sig-prename descclassname\">dipy.reconst.multi_voxel.</code><code class=\"sig-name descname\">ndindex</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">shape</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.multi_voxel.ndindex\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>An N-dimensional iterator object to index arrays.</p>\n<p>Given the shape of an array, an <cite>ndindex</cite> instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned; the last dimension is iterated over first.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong><span class=\"classifier\">tuple of ints</span></dt><dd><p>The dimensions of the array.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.ndindex</span> <span class=\"k\">import</span> <span class=\"n\">ndindex</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"n\">ndindex</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span>\n<span class=\"go\">(0, 0, 0)</span>\n<span class=\"go\">(0, 1, 0)</span>\n<span class=\"go\">(1, 0, 0)</span>\n<span class=\"go\">(1, 1, 0)</span>\n<span class=\"go\">(2, 0, 0)</span>\n<span class=\"go\">(2, 1, 0)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id787\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a><a class=\"headerlink\" href=\"#id787\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.odf.OdfFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">OdfFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit.odf\" title=\"dipy.reconst.odf.OdfFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>To be implemented but specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.OdfFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.OdfFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented but specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id788\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a><a class=\"headerlink\" href=\"#id788\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.odf.OdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">OdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>An abstract class to be sub-classed by specific odf models</p>\n<p>All odf models should provide a fit method which may take data as it\u2019s\nfirst and only argument.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel.fit\" title=\"dipy.reconst.odf.OdfModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.OdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.OdfModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.OdfModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented by specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id789\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.odf.ReconstFit\" title=\"dipy.reconst.odf.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a><a class=\"headerlink\" href=\"#id789\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.odf.ReconstFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">ReconstFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.ReconstFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class which holds the fit result of ReconstModel</p>\n<p>For example that could be holding FA or GFA etc.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.ReconstFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.ReconstFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id790\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.odf.ReconstModel\" title=\"dipy.reconst.odf.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id790\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.odf.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.odf.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id791\">\n<h3>gfa<a class=\"headerlink\" href=\"#id791\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.odf.gfa\">\n<code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">gfa</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">samples</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.gfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The general fractional anisotropy of a function evaluated\non the unit sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>samples</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Values of data on the unit sphere.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gfa</strong><span class=\"classifier\">ndarray</span></dt><dd><p>GFA evaluated in each entry of the array, along the last dimension.\nAn <cite>np.nan</cite> is returned for coordinates that contain all-zeros in\n<cite>samples</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The GFA is defined as <a class=\"reference internal\" href=\"#r6d0af26625ec-1\" id=\"id792\">[1]</a></p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>\\<span class=\"n\">sqrt</span><span class=\"p\">{</span>\\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"n\">n</span> \\<span class=\"n\">sum_i</span><span class=\"p\">{(</span>\\<span class=\"n\">Psi_i</span> <span class=\"o\">-</span> <span class=\"o\">&lt;</span>\\<span class=\"n\">Psi</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"o\">^</span><span class=\"mi\">2</span><span class=\"p\">}}{(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> \\<span class=\"nb\">sum</span><span class=\"p\">{</span>\\<span class=\"n\">Psi_i</span> <span class=\"o\">^</span> <span class=\"mi\">2</span><span class=\"p\">}}}</span>\n</pre></div>\n</div>\n<p>Where <span class=\"math notranslate nohighlight\">\\(\\Psi\\)</span> is an orientation distribution function sampled discretely on\nthe unit sphere and angle brackets denote average over the samples on the\nsphere.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6d0af26625ec-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id792\">1</a></span></dt>\n<dd><p>Quality assessment of High Angular Resolution Diffusion Imaging\ndata using bootstrap on Q-ball reconstruction. J. Cohen Adad, M.\nDescoteaux, L.L. Wald. JMRI 33: 1194-1208.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"minmax-normalize\">\n<h3>minmax_normalize<a class=\"headerlink\" href=\"#minmax-normalize\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.odf.minmax_normalize\">\n<code class=\"sig-prename descclassname\">dipy.reconst.odf.</code><code class=\"sig-name descname\">minmax_normalize</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">samples</em>, <em class=\"sig-param\">out=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.odf.minmax_normalize\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Min-max normalization of a function evaluated on the unit sphere</p>\n<p>Normalizes samples to <code class=\"docutils literal notranslate\"><span class=\"pre\">(samples</span> <span class=\"pre\">-</span> <span class=\"pre\">min(samples))</span> <span class=\"pre\">/</span> <span class=\"pre\">(max(samples)</span> <span class=\"pre\">-</span>\n<span class=\"pre\">min(samples))</span></code> for each unit sphere.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>samples</strong><span class=\"classifier\">ndarray (\u2026, N)</span></dt><dd><p>N samples on a unit sphere for each point, stored along the last axis\nof the array.</p>\n</dd>\n<dt><strong>out</strong><span class=\"classifier\">ndrray (\u2026, N), optional</span></dt><dd><p>An array to store the normalized samples.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>out</strong><span class=\"classifier\">ndarray, (\u2026, N)</span></dt><dd><p>Normalized samples.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"eudxdirectiongetter\">\n<h3>EuDXDirectionGetter<a class=\"headerlink\" href=\"#eudxdirectiongetter\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.peak_direction_getter.EuDXDirectionGetter\">\n<code class=\"sig-prename descclassname\">dipy.reconst.peak_direction_getter.</code><code class=\"sig-name descname\">EuDXDirectionGetter</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.peak_direction_getter.EuDXDirectionGetter\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"id793\">\n<h3>warn<a class=\"headerlink\" href=\"#id793\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.peak_direction_getter.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.peak_direction_getter.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.peak_direction_getter.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id794\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.Cache\" title=\"dipy.reconst.qtdmri.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id794\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.qtdmri.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.Cache.cache_clear\" title=\"dipy.reconst.qtdmri.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.Cache.cache_get\" title=\"dipy.reconst.qtdmri.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.Cache.cache_set\" title=\"dipy.reconst.qtdmri.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id795\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.LooseVersion\" title=\"dipy.reconst.qtdmri.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#id795\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.qtdmri.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.qtdmri.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmrifit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit\" title=\"dipy.reconst.qtdmri.QtdmriFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QtdmriFit</span></code></a><a class=\"headerlink\" href=\"#qtdmrifit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">QtdmriFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">qtdmri_coef</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">tau_scaling</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">lopt</em>, <em class=\"sig-param\">alpha</em>, <em class=\"sig-param\">cvxpy_solution_optimal</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.fitted_signal\" title=\"dipy.reconst.qtdmri.QtdmriFit.fitted_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fitted_signal</span></code></a>([gtab])</p></td>\n<td><p>Recovers the fitted signal for the given gradient table.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.msd\" title=\"dipy.reconst.qtdmri.QtdmriFit.msd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd</span></code></a>(tau)</p></td>\n<td><p>Calculates the analytical Mean Squared Displacement (MSD) for a given diffusion time tau.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal\" title=\"dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">norm_of_laplacian_signal</span></code></a>()</p></td>\n<td><p>Calculates the norm of the laplacian of the fitted signal <span id=\"id796\">[Re930b800cbc4-1]</span>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.odf\" title=\"dipy.reconst.qtdmri.QtdmriFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere,\u00a0tau[,\u00a0s])</p></td>\n<td><p>Calculates the analytical Orientation Distribution Function (ODF) for a given diffusion time tau from the signal, <a class=\"reference internal\" href=\"#re8a94af3adb8-1\" id=\"id797\">[1]</a> Eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.odf_sh\" title=\"dipy.reconst.qtdmri.QtdmriFit.odf_sh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_sh</span></code></a>(tau[,\u00a0s])</p></td>\n<td><p>Calculates the real analytical odf for a given discrete sphere.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.pdf\" title=\"dipy.reconst.qtdmri.QtdmriFit.pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf</span></code></a>(rt_points)</p></td>\n<td><p>Diffusion propagator on a given set of real points.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.predict\" title=\"dipy.reconst.qtdmri.QtdmriFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>(qvals_or_gtab[,\u00a0S0])</p></td>\n<td><p>Recovers the reconstructed signal for any qvalue array or gradient table.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.qiv\" title=\"dipy.reconst.qtdmri.QtdmriFit.qiv\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qiv</span></code></a>(tau)</p></td>\n<td><p>Calculates the analytical Q-space Inverse Variance (QIV) for given diffusion time tau.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef\" title=\"dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">qtdmri_to_mapmri_coef</span></code></a>(tau)</p></td>\n<td><p>This function converts the qtdmri coefficients to mapmri coefficients for a given tau <a class=\"reference internal\" href=\"#rbeb00b0728f1-1\" id=\"id798\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtap\" title=\"dipy.reconst.qtdmri.QtdmriFit.rtap\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtap</span></code></a>(tau)</p></td>\n<td><p>Calculates the analytical return to the axis probability (RTAP) for a given diffusion time tau, <a class=\"reference internal\" href=\"#rb426f7ff6c1f-1\" id=\"id799\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtop\" title=\"dipy.reconst.qtdmri.QtdmriFit.rtop\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop</span></code></a>(tau)</p></td>\n<td><p>Calculates the analytical return to the origin probability (RTOP) for a given diffusion time tau <a class=\"reference internal\" href=\"#rae9ef6a2072f-1\" id=\"id800\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtpp\" title=\"dipy.reconst.qtdmri.QtdmriFit.rtpp\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtpp</span></code></a>(tau)</p></td>\n<td><p>Calculates the analytical return to the plane probability (RTPP) for a given diffusion time tau, <a class=\"reference internal\" href=\"#r0ef534f1e9fc-1\" id=\"id801\">[1]</a> eq.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs\" title=\"dipy.reconst.qtdmri.QtdmriFit.sparsity_abs\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sparsity_abs</span></code></a>([threshold])</p></td>\n<td><p>As a measure of sparsity, calculates the number of largest coefficients needed to absolute sum up to 99% of the total absolute sum of all coefficients</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriFit.sparsity_density\" title=\"dipy.reconst.qtdmri.QtdmriFit.sparsity_density\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sparsity_density</span></code></a>([threshold])</p></td>\n<td><p>As a measure of sparsity, calculates the number of largest coefficients needed to squared sum up to 99% of the total squared sum of all coefficients</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">qtdmri_coef</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">tau_scaling</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">lopt</em>, <em class=\"sig-param\">alpha</em>, <em class=\"sig-param\">cvxpy_solution_optimal</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates diffusion properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>AnalyticalModel</p>\n</dd>\n<dt><strong>qtdmri_coef</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>qtdmri coefficients</p>\n</dd>\n<dt><strong>us</strong><span class=\"classifier\">array, 3 x 1</span></dt><dd><p>spatial scaling factors</p>\n</dd>\n<dt><strong>ut</strong><span class=\"classifier\">float</span></dt><dd><p>temporal scaling factor</p>\n</dd>\n<dt><strong>tau_scaling</strong><span class=\"classifier\">float,</span></dt><dd><p>the temporal scaling that used to scale tau to the size of us</p>\n</dd>\n<dt><strong>R</strong><span class=\"classifier\">3x3 numpy array,</span></dt><dd><p>tensor eigenvectors</p>\n</dd>\n<dt><strong>lopt</strong><span class=\"classifier\">float,</span></dt><dd><p>laplacian regularization weight</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float,</span></dt><dd><p>the l1 regularization weight</p>\n</dd>\n<dt><strong>cvxpy_solution_optimal: bool,</strong></dt><dd><p>indicates whether the cvxpy coefficient estimation reach an optimal\nsolution</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.fitted_signal\">\n<code class=\"sig-name descname\">fitted_signal</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.fitted_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Recovers the fitted signal for the given gradient table. If no gradient\ntable is given it recovers the signal for the gtab of the model object.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.msd\">\n<code class=\"sig-name descname\">msd</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.msd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Mean Squared Displacement (MSD) for a\ngiven diffusion time tau. It is defined as the Laplacian of the origin\nof the estimated signal <a class=\"reference internal\" href=\"#r9ee09c2d0d0c-1\" id=\"id802\">[1]</a>. The analytical formula for the MAP-MRI\nbasis was derived in <span id=\"id803\">[R9ee09c2d0d0c-2]</span> eq. (C13, D1). The qtdmri coefficients are\nfirst converted to mapmri coefficients following [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9ee09c2d0d0c-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id802\">1</a></span></dt>\n<dd><p>Cheng, J., 2014. Estimation and Processing of Ensemble Average\nPropagator and Its Features in Diffusion MRI. Ph.D. Thesis.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9ee09c2d0d0c-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal\">\n<code class=\"sig-name descname\">norm_of_laplacian_signal</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.norm_of_laplacian_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the norm of the laplacian of the fitted signal <span id=\"id807\">[Re930b800cbc4-1]</span>.\nThis information could be useful to assess if the extrapolation of the\nfitted signal contains spurious oscillations. A high laplacian norm may\nindicate that these are present, and any q-space indices that\nuse integrals of the signal may be corrupted (e.g. RTOP, RTAP, RTPP,\nQIV). In contrast to [1], the Laplacian now describes oscillations in\nthe 4-dimensional qt-signal [2].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re930b800cbc4-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">tau</em>, <em class=\"sig-param\">s=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Orientation Distribution Function (ODF)\nfor a given diffusion time tau from the signal, <a class=\"reference internal\" href=\"#re8a94af3adb8-1\" id=\"id810\">[1]</a> Eq. (32). The\nqtdmri coefficients are first converted to mapmri coefficients\nfollowing [2].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">dipy sphere object</span></dt><dd><p>sphere object with vertice orientations to compute the ODF on.</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re8a94af3adb8-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id797\">1</a>,<a href=\"#id810\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et. al, \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"re8a94af3adb8-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.odf_sh\">\n<code class=\"sig-name descname\">odf_sh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em>, <em class=\"sig-param\">s=2</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.odf_sh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the real analytical odf for a given discrete sphere.\nComputes the design matrix of the ODF for the given sphere vertices\nand radial moment <a class=\"reference internal\" href=\"#r0a1decd741db-1\" id=\"id813\">[1]</a> eq. (32). The radial moment s acts as a\nsharpening method. The analytical equation for the spherical ODF basis\nis given in <span id=\"id814\">[R0a1decd741db-2]</span> eq. (C8). The qtdmri coefficients are first converted\nto mapmri coefficients following [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n<dt><strong>s</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>radial moment of the ODF</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0a1decd741db-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id813\">1</a></span></dt>\n<dd><p>Ozarslan E. et. al, \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0a1decd741db-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.pdf\">\n<code class=\"sig-name descname\">pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">rt_points</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion propagator on a given set of real points.\nif the array r_points is non writeable, then intermediate\nresults are cached for faster recalculation</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">qvals_or_gtab</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Recovers the reconstructed signal for any qvalue array or\ngradient table.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.qiv\">\n<code class=\"sig-name descname\">qiv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.qiv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical Q-space Inverse Variance (QIV) for given\ndiffusion time tau.\nIt is defined as the inverse of the Laplacian of the origin of the\nestimated propagator <a class=\"reference internal\" href=\"#r1e32c9d7d6dc-1\" id=\"id818\">[1]</a> eq. (22). The analytical formula for the\nMAP-MRI basis was derived in <span id=\"id819\">[R1e32c9d7d6dc-2]</span> eq. (C14, D2). The qtdmri\ncoefficients are first converted to mapmri coefficients following [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1e32c9d7d6dc-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id818\">1</a></span></dt>\n<dd><p>Hosseinbor et al. \u201cBessel fourier orientation reconstruction\n(bfor): An analytical diffusion propagator reconstruction for\nhybrid diffusion imaging and computation of q-space indices.\nNeuroImage 64, 2013, 650\u2013670.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r1e32c9d7d6dc-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef\">\n<code class=\"sig-name descname\">qtdmri_to_mapmri_coef</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.qtdmri_to_mapmri_coef\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>This function converts the qtdmri coefficients to mapmri\ncoefficients for a given tau <a class=\"reference internal\" href=\"#rbeb00b0728f1-1\" id=\"id823\">[1]</a>. The conversion is performed by a\nmatrix multiplication that evaluates the time-depenent part of the\nbasis and multiplies it with the coefficients, after which coefficients\nwith the same spatial orders are summed up, resulting in mapmri\ncoefficients.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rbeb00b0728f1-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id798\">1</a>,<a href=\"#id823\">2</a>)</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.rtap\">\n<code class=\"sig-name descname\">rtap</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtap\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the axis probability (RTAP)\nfor a given diffusion time tau, <a class=\"reference internal\" href=\"#rb426f7ff6c1f-1\" id=\"id825\">[1]</a> eq. (40, 44a). The analytical\nformula for the isotropic MAP-MRI basis was derived in <span id=\"id826\">[Rb426f7ff6c1f-2]</span> eq. (C11).\nThe qtdmri coefficients are first converted to mapmri coefficients\nfollowing [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb426f7ff6c1f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id799\">1</a>,<a href=\"#id825\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et. al, \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb426f7ff6c1f-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.rtop\">\n<code class=\"sig-name descname\">rtop</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtop\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the origin probability (RTOP)\nfor a given diffusion time tau <a class=\"reference internal\" href=\"#rae9ef6a2072f-1\" id=\"id830\">[1]</a> eq. (36, 43). The analytical\nformula for the isotropic MAP-MRI basis was derived in <span id=\"id831\">[Rae9ef6a2072f-2]</span> eq. (C11).\nThe qtdmri coefficients are first converted to mapmri coefficients\nfollowing [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rae9ef6a2072f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id800\">1</a>,<a href=\"#id830\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et. al, \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rae9ef6a2072f-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.rtpp\">\n<code class=\"sig-name descname\">rtpp</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.rtpp\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to the plane probability (RTPP)\nfor a given diffusion time tau, <a class=\"reference internal\" href=\"#r0ef534f1e9fc-1\" id=\"id835\">[1]</a> eq. (42). The analytical formula\nfor the isotropic MAP-MRI basis was derived in <span id=\"id836\">[R0ef534f1e9fc-2]</span> eq. (C11). The\nqtdmri coefficients are first converted to mapmri coefficients\nfollowing [3].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0ef534f1e9fc-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id801\">1</a>,<a href=\"#id835\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et. al, \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0ef534f1e9fc-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.sparsity_abs\">\n<code class=\"sig-name descname\">sparsity_abs</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">threshold=0.99</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.sparsity_abs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>As a measure of sparsity, calculates the number of largest\ncoefficients needed to absolute sum up to 99% of the total absolute sum\nof all coefficients</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriFit.sparsity_density\">\n<code class=\"sig-name descname\">sparsity_density</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">threshold=0.99</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriFit.sparsity_density\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>As a measure of sparsity, calculates the number of largest\ncoefficients needed to squared sum up to 99% of the total squared sum\nof all coefficients</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmrimodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriModel\" title=\"dipy.reconst.qtdmri.QtdmriModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QtdmriModel</span></code></a><a class=\"headerlink\" href=\"#qtdmrimodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">QtdmriModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">time_order=2</em>, <em class=\"sig-param\">laplacian_regularization=False</em>, <em class=\"sig-param\">laplacian_weighting=0.2</em>, <em class=\"sig-param\">l1_regularization=False</em>, <em class=\"sig-param\">l1_weighting=0.1</em>, <em class=\"sig-param\">cartesian=True</em>, <em class=\"sig-param\">anisotropic_scaling=True</em>, <em class=\"sig-param\">normalization=False</em>, <em class=\"sig-param\">constrain_q0=True</em>, <em class=\"sig-param\">bval_threshold=10000000000.0</em>, <em class=\"sig-param\">eigenvalue_threshold=0.0001</em>, <em class=\"sig-param\">cvxpy_solver='ECOS'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>The q:math:<cite>tau</cite>-dMRI model [1] to analytically and continuously represent\nthe q:math:<cite>tau</cite> diffusion signal attenuation over diffusion sensitization\nq and diffusion time <span class=\"math notranslate nohighlight\">\\(\\tau\\)</span>. The model can be seen as an extension of\nthe MAP-MRI basis [2] towards different diffusion times.</p>\n<p>The main idea is to model the diffusion signal over time and space as\na linear combination of continuous functions,</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>hat{E}(textbf{q},tau;textbf{c}) =\nsum_i^{N_{textbf{q}}}sum_k^{<a href=\"#id987\"><span class=\"problematic\" id=\"id988\">N_</span></a>tau} textbf{c}_{ik}\n,Phi_i(textbf{q}),T_k(tau),</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\Phi\\)</span> and <span class=\"math notranslate nohighlight\">\\(T\\)</span> are the spatial and temporal basis funcions,\n<span class=\"math notranslate nohighlight\">\\(N_{\\textbf{q}}\\)</span> and <span class=\"math notranslate nohighlight\">\\(N_\\tau\\)</span> are the maximum spatial and temporal\norder, and <span class=\"math notranslate nohighlight\">\\(i,k\\)</span> are basis order iterators.</p>\n<p>The estimation of the coefficients <span class=\"math notranslate nohighlight\">\\(c_i\\)</span> can be regularized using\neither analytic Laplacian regularization, sparsity regularization using\nthe l1-norm, or both to do a type of elastic net regularization.</p>\n<p>From the coefficients, there exists an analytical formula to estimate\nthe ODF, RTOP, RTAP, RTPP, QIV and MSD, for any diffusion time.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class. The bvalues\nshould be in the normal s/mm^2. big_delta and small_delta need to\ngiven in seconds.</p>\n</dd>\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>\n</dd>\n<dt><strong>time_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order\nof the basis.</p>\n</dd>\n<dt><strong>laplacian_regularization</strong><span class=\"classifier\">bool,</span></dt><dd><p>Regularize using the Laplacian of the qt-dMRI basis.</p>\n</dd>\n<dt><strong>laplacian_weighting: string or scalar,</strong></dt><dd><p>The string \u2018GCV\u2019 makes it use generalized cross-validation to find\nthe regularization weight [3]. A scalar sets the regularization\nweight to that value.</p>\n</dd>\n<dt><strong>l1_regularization</strong><span class=\"classifier\">bool,</span></dt><dd><p>Regularize by imposing sparsity in the coefficients using the\nl1-norm.</p>\n</dd>\n<dt><strong>l1_weighting</strong><span class=\"classifier\">\u2018CV\u2019 or scalar,</span></dt><dd><p>The string \u2018CV\u2019 makes it use five-fold cross-validation to find\nthe regularization weight. A scalar sets the regularization weight\nto that value.</p>\n</dd>\n<dt><strong>cartesian</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to use the Cartesian or spherical implementation of the\nqt-dMRI basis, which we first explored in [4].</p>\n</dd>\n<dt><strong>anisotropic_scaling</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to use anisotropic scaling or isotropic scaling. This\noption can be used to test if the Cartesian implementation is\nequivalent with the spherical one when using the same scaling.</p>\n</dd>\n<dt><strong>normalization</strong><span class=\"classifier\">bool</span></dt><dd><p>Whether to normalize the basis functions such that their inner\nproduct is equal to one. Normalization is only necessary when\nimposing sparsity in the spherical basis if cartesian=False.</p>\n</dd>\n<dt><strong>constrain_q0</strong><span class=\"classifier\">bool</span></dt><dd><p>whether to constrain the q0 point to unity along the tau-space.\nThis is necessary to ensure that <span class=\"math notranslate nohighlight\">\\(E(0,\\tau)=1\\)</span>.</p>\n</dd>\n<dt><strong>bval_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>the threshold b-value to be used, such that only data points below\nthat threshold are used when estimating the scale factors.</p>\n</dd>\n<dt><strong>eigenvalue_threshold</strong><span class=\"classifier\">float,</span></dt><dd><p>Sets the minimum of the tensor eigenvalues in order to avoid\nstability problem.</p>\n</dd>\n<dt><strong>cvxpy_solver</strong><span class=\"classifier\">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint\nwith a particular cvxpy solver. See See <a class=\"reference external\" href=\"http://www.cvxpy.org/\">http://www.cvxpy.org/</a> for\ndetails. Default: ECOS.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r6dee8b26f150-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n<dt class=\"label\" id=\"r6dee8b26f150-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"r6dee8b26f150-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Craven et al. \u201cSmoothing Noisy Data with Spline Functions.\u201d\nNUMER MATH 31.4 (1978): 377-403.</p>\n</dd>\n<dt class=\"label\" id=\"r6dee8b26f150-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cA unifying framework for spatial and\ntemporal diffusion in diffusion mri.\u201d International Conference on\nInformation Processing in Medical Imaging. Springer, Cham, 2015.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.qtdmri.QtdmriModel.fit\" title=\"dipy.reconst.qtdmri.QtdmriModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">time_order=2</em>, <em class=\"sig-param\">laplacian_regularization=False</em>, <em class=\"sig-param\">laplacian_weighting=0.2</em>, <em class=\"sig-param\">l1_regularization=False</em>, <em class=\"sig-param\">l1_weighting=0.1</em>, <em class=\"sig-param\">cartesian=True</em>, <em class=\"sig-param\">anisotropic_scaling=True</em>, <em class=\"sig-param\">normalization=False</em>, <em class=\"sig-param\">constrain_q0=True</em>, <em class=\"sig-param\">bval_threshold=10000000000.0</em>, <em class=\"sig-param\">eigenvalue_threshold=0.0001</em>, <em class=\"sig-param\">cvxpy_solver='ECOS'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.qtdmri.QtdmriModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.QtdmriModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id844\">\n<h3>GCV_cost_function<a class=\"headerlink\" href=\"#id844\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.GCV_cost_function\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">GCV_cost_function</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">weight</em>, <em class=\"sig-param\">arguments</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.GCV_cost_function\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized Cross Validation Function that is iterated [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r288c54af3b44-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Craven et al. \u201cSmoothing Noisy Data with Spline Functions.\u201d\nNUMER MATH 31.4 (1978): 377-403.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"h\">\n<h3>H<a class=\"headerlink\" href=\"#h\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.H\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">H</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.H\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Step function of H(x)=1 if x&gt;=0 and zero otherwise. Used for the\ntemporal laplacian matrix.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"angular-basis-eap-opt\">\n<h3>angular_basis_EAP_opt<a class=\"headerlink\" href=\"#angular-basis-eap-opt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.angular_basis_EAP_opt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">angular_basis_EAP_opt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">m</em>, <em class=\"sig-param\">r</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.angular_basis_EAP_opt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"angular-basis-opt\">\n<h3>angular_basis_opt<a class=\"headerlink\" href=\"#angular-basis-opt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.angular_basis_opt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">angular_basis_opt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">l</em>, <em class=\"sig-param\">m</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.angular_basis_opt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Angular basis independent of spatial scaling factor us. Though it\nincludes q, it is independent of the data and can be precomputed.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id846\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id846\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"create-rt-space-grid\">\n<h3>create_rt_space_grid<a class=\"headerlink\" href=\"#create-rt-space-grid\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.create_rt_space_grid\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">create_rt_space_grid</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">grid_size_r</em>, <em class=\"sig-param\">max_radius_r</em>, <em class=\"sig-param\">grid_size_tau</em>, <em class=\"sig-param\">min_radius_tau</em>, <em class=\"sig-param\">max_radius_tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.create_rt_space_grid\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generates EAP grid (for potential positivity constraint).</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"design-matrix-spatial\">\n<h3>design_matrix_spatial<a class=\"headerlink\" href=\"#design-matrix-spatial\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.design_matrix_spatial\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">design_matrix_spatial</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">bvecs</em>, <em class=\"sig-param\">qvals</em>, <em class=\"sig-param\">dtype=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.design_matrix_spatial\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for DTI weighted least squares or\nleast squares fitting. (Basser et al., 1994a)</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>bvecs</strong><span class=\"classifier\">array (N x 3)</span></dt><dd><p>unit b-vectors of the acquisition.</p>\n</dd>\n<dt><strong>qvals</strong><span class=\"classifier\">array (N,)</span></dt><dd><p>corresponding q-values in 1/mm</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>design_matrix</strong><span class=\"classifier\">array (g,7)</span></dt><dd><p>Design matrix or B matrix assuming Gaussian distributed tensor model\ndesign_matrix[j, :] = (Bxx, Byy, Bzz, Bxy, Bxz, Byz, dummy)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"elastic-crossvalidation\">\n<h3>elastic_crossvalidation<a class=\"headerlink\" href=\"#elastic-crossvalidation\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.elastic_crossvalidation\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">elastic_crossvalidation</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b0s_mask</em>, <em class=\"sig-param\">E</em>, <em class=\"sig-param\">M</em>, <em class=\"sig-param\">L</em>, <em class=\"sig-param\">lopt</em>, <em class=\"sig-param\">weight_array=array([0.</em>, <em class=\"sig-param\">0.01</em>, <em class=\"sig-param\">0.02</em>, <em class=\"sig-param\">0.03</em>, <em class=\"sig-param\">0.04</em>, <em class=\"sig-param\">0.05</em>, <em class=\"sig-param\">0.06</em>, <em class=\"sig-param\">0.07</em>, <em class=\"sig-param\">0.08</em>, <em class=\"sig-param\">0.09</em>, <em class=\"sig-param\">0.1</em>, <em class=\"sig-param\">0.11</em>, <em class=\"sig-param\">0.12</em>, <em class=\"sig-param\">0.13</em>, <em class=\"sig-param\">0.14</em>, <em class=\"sig-param\">0.15</em>, <em class=\"sig-param\">0.16</em>, <em class=\"sig-param\">0.17</em>, <em class=\"sig-param\">0.18</em>, <em class=\"sig-param\">0.19</em>, <em class=\"sig-param\">0.2 ])</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.elastic_crossvalidation\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>cross-validation function to find the optimal weight of alpha for\nsparsity regularization when also Laplacian regularization is used.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"factorial\">\n<h3>factorial<a class=\"headerlink\" href=\"#factorial\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.factorial\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">factorial</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">exact=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.factorial\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The factorial of a number or array of numbers.</p>\n<p>The factorial of non-negative integer <cite>n</cite> is the product of all\npositive integers less than or equal to <cite>n</cite>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>n! = n * (n - 1) * (n - 2) * ... * 1\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int or array_like of ints</span></dt><dd><p>Input values.  If <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0</span></code>, the return value is 0.</p>\n</dd>\n<dt><strong>exact</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, calculate the answer exactly using long integer arithmetic.\nIf False, result is approximated in floating point rapidly using the\n<cite>gamma</cite> function.\nDefault is False.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>nf</strong><span class=\"classifier\">float or int or ndarray</span></dt><dd><p>Factorial of <cite>n</cite>, as integer or float depending on <cite>exact</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>For arrays with <code class=\"docutils literal notranslate\"><span class=\"pre\">exact=True</span></code>, the factorial is computed only once, for\nthe largest input, with each other result computed in the process.\nThe output dtype is increased to <code class=\"docutils literal notranslate\"><span class=\"pre\">int64</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">object</span></code> if necessary.</p>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">exact=False</span></code> the factorial is approximated using the gamma\nfunction:</p>\n<div class=\"math notranslate nohighlight\">\n\\[n! = \\Gamma(n+1)\\]</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.special</span> <span class=\"k\">import</span> <span class=\"n\">factorial</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">array([   6.,   24.,  120.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">array([  6,  24, 120])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">120</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id847\">\n<h3>factorial2<a class=\"headerlink\" href=\"#id847\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.factorial2\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">factorial2</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">exact=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.factorial2\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Double factorial.</p>\n<p>This is the factorial with every second value skipped.  E.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">7!!</span> <span class=\"pre\">=</span> <span class=\"pre\">7</span> <span class=\"pre\">*</span> <span class=\"pre\">5</span>\n<span class=\"pre\">*</span> <span class=\"pre\">3</span> <span class=\"pre\">*</span> <span class=\"pre\">1</span></code>.  It can be approximated numerically as:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>n!! = special.gamma(n/2+1)*2**((m+1)/2)/sqrt(pi)  n odd\n    = 2**(n/2) * (n/2)!                           n even\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int or array_like</span></dt><dd><p>Calculate <code class=\"docutils literal notranslate\"><span class=\"pre\">n!!</span></code>.  Arrays are only supported with <cite>exact</cite> set\nto False.  If <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0</span></code>, the return value is 0.</p>\n</dd>\n<dt><strong>exact</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>The result can be approximated rapidly using the gamma-formula\nabove (default).  If <cite>exact</cite> is set to True, calculate the\nanswer exactly using integer arithmetic.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>nff</strong><span class=\"classifier\">float or int</span></dt><dd><p>Double factorial of <cite>n</cite>, as an int or a float depending on\n<cite>exact</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">scipy.special</span> <span class=\"k\">import</span> <span class=\"n\">factorial2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial2</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"go\">array(105.00000000000001)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">factorial2</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">exact</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">105</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"fmin-l-bfgs-b\">\n<h3>fmin_l_bfgs_b<a class=\"headerlink\" href=\"#fmin-l-bfgs-b\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.fmin_l_bfgs_b\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">fmin_l_bfgs_b</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em>, <em class=\"sig-param\">x0</em>, <em class=\"sig-param\">fprime=None</em>, <em class=\"sig-param\">args=()</em>, <em class=\"sig-param\">approx_grad=0</em>, <em class=\"sig-param\">bounds=None</em>, <em class=\"sig-param\">m=10</em>, <em class=\"sig-param\">factr=10000000.0</em>, <em class=\"sig-param\">pgtol=1e-05</em>, <em class=\"sig-param\">epsilon=1e-08</em>, <em class=\"sig-param\">iprint=-1</em>, <em class=\"sig-param\">maxfun=15000</em>, <em class=\"sig-param\">maxiter=15000</em>, <em class=\"sig-param\">disp=None</em>, <em class=\"sig-param\">callback=None</em>, <em class=\"sig-param\">maxls=20</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.fmin_l_bfgs_b\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Minimize a function func using the L-BFGS-B algorithm.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">callable f(x,*args)</span></dt><dd><p>Function to minimize.</p>\n</dd>\n<dt><strong>x0</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Initial guess.</p>\n</dd>\n<dt><strong>fprime</strong><span class=\"classifier\">callable fprime(x,*args), optional</span></dt><dd><p>The gradient of <cite>func</cite>. If None, then <cite>func</cite> returns the function\nvalue and the gradient (<code class=\"docutils literal notranslate\"><span class=\"pre\">f,</span> <span class=\"pre\">g</span> <span class=\"pre\">=</span> <span class=\"pre\">func(x,</span> <span class=\"pre\">*args)</span></code>), unless\n<cite>approx_grad</cite> is True in which case <cite>func</cite> returns only <code class=\"docutils literal notranslate\"><span class=\"pre\">f</span></code>.</p>\n</dd>\n<dt><strong>args</strong><span class=\"classifier\">sequence, optional</span></dt><dd><p>Arguments to pass to <cite>func</cite> and <cite>fprime</cite>.</p>\n</dd>\n<dt><strong>approx_grad</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>Whether to approximate the gradient numerically (in which case\n<cite>func</cite> returns only the function value).</p>\n</dd>\n<dt><strong>bounds</strong><span class=\"classifier\">list, optional</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">(min,</span> <span class=\"pre\">max)</span></code> pairs for each element in <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code>, defining\nthe bounds on that parameter. Use None or +-inf for one of <code class=\"docutils literal notranslate\"><span class=\"pre\">min</span></code> or\n<code class=\"docutils literal notranslate\"><span class=\"pre\">max</span></code> when there is no bound in that direction.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The maximum number of variable metric corrections\nused to define the limited memory matrix. (The limited memory BFGS\nmethod does not store the full hessian but uses this many terms in an\napproximation to it.)</p>\n</dd>\n<dt><strong>factr</strong><span class=\"classifier\">float, optional</span></dt><dd><p>The iteration stops when\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(f^k</span> <span class=\"pre\">-</span> <span class=\"pre\">f^{k+1})/max{|f^k|,|f^{k+1}|,1}</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">factr</span> <span class=\"pre\">*</span> <span class=\"pre\">eps</span></code>,\nwhere <code class=\"docutils literal notranslate\"><span class=\"pre\">eps</span></code> is the machine precision, which is automatically\ngenerated by the code. Typical values for <cite>factr</cite> are: 1e12 for\nlow accuracy; 1e7 for moderate accuracy; 10.0 for extremely\nhigh accuracy. See Notes for relationship to <cite>ftol</cite>, which is exposed\n(instead of <cite>factr</cite>) by the <cite>scipy.optimize.minimize</cite> interface to\nL-BFGS-B.</p>\n</dd>\n<dt><strong>pgtol</strong><span class=\"classifier\">float, optional</span></dt><dd><p>The iteration will stop when\n<code class=\"docutils literal notranslate\"><span class=\"pre\">max{|proj</span> <span class=\"pre\">g_i</span> <span class=\"pre\">|</span> <span class=\"pre\">i</span> <span class=\"pre\">=</span> <span class=\"pre\">1,</span> <span class=\"pre\">...,</span> <span class=\"pre\">n}</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">pgtol</span></code>\nwhere <code class=\"docutils literal notranslate\"><span class=\"pre\">pg_i</span></code> is the i-th component of the projected gradient.</p>\n</dd>\n<dt><strong>epsilon</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Step size used when <cite>approx_grad</cite> is True, for numerically\ncalculating the gradient</p>\n</dd>\n<dt><strong>iprint</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Controls the frequency of output. <code class=\"docutils literal notranslate\"><span class=\"pre\">iprint</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">0</span></code> means no output;\n<code class=\"docutils literal notranslate\"><span class=\"pre\">iprint</span> <span class=\"pre\">=</span> <span class=\"pre\">0</span></code>    print only one line at the last iteration;\n<code class=\"docutils literal notranslate\"><span class=\"pre\">0</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">iprint</span> <span class=\"pre\">&lt;</span> <span class=\"pre\">99</span></code> print also f and <code class=\"docutils literal notranslate\"><span class=\"pre\">|proj</span> <span class=\"pre\">g|</span></code> every iprint iterations;\n<code class=\"docutils literal notranslate\"><span class=\"pre\">iprint</span> <span class=\"pre\">=</span> <span class=\"pre\">99</span></code>   print details of every iteration except n-vectors;\n<code class=\"docutils literal notranslate\"><span class=\"pre\">iprint</span> <span class=\"pre\">=</span> <span class=\"pre\">100</span></code>  print also the changes of active set and final x;\n<code class=\"docutils literal notranslate\"><span class=\"pre\">iprint</span> <span class=\"pre\">&gt;</span> <span class=\"pre\">100</span></code>  print details of every iteration including x and g.</p>\n</dd>\n<dt><strong>disp</strong><span class=\"classifier\">int, optional</span></dt><dd><p>If zero, then no output. If a positive number, then this over-rides\n<cite>iprint</cite> (i.e., <cite>iprint</cite> gets the value of <cite>disp</cite>).</p>\n</dd>\n<dt><strong>maxfun</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum number of function evaluations.</p>\n</dd>\n<dt><strong>maxiter</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum number of iterations.</p>\n</dd>\n<dt><strong>callback</strong><span class=\"classifier\">callable, optional</span></dt><dd><p>Called after each iteration, as <code class=\"docutils literal notranslate\"><span class=\"pre\">callback(xk)</span></code>, where <code class=\"docutils literal notranslate\"><span class=\"pre\">xk</span></code> is the\ncurrent parameter vector.</p>\n</dd>\n<dt><strong>maxls</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum number of line search steps (per iteration). Default is 20.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>Estimated position of the minimum.</p>\n</dd>\n<dt><strong>f</strong><span class=\"classifier\">float</span></dt><dd><p>Value of <cite>func</cite> at the minimum.</p>\n</dd>\n<dt><strong>d</strong><span class=\"classifier\">dict</span></dt><dd><p>Information dictionary.</p>\n<ul class=\"simple\">\n<li><p>d[\u2018warnflag\u2019] is</p>\n<ul>\n<li><p>0 if converged,</p></li>\n<li><p>1 if too many function evaluations or too many iterations,</p></li>\n<li><p>2 if stopped for another reason, given in d[\u2018task\u2019]</p></li>\n</ul>\n</li>\n<li><p>d[\u2018grad\u2019] is the gradient at the minimum (should be 0 ish)</p></li>\n<li><p>d[\u2018funcalls\u2019] is the number of function calls made.</p></li>\n<li><p>d[\u2018nit\u2019] is the number of iterations.</p></li>\n</ul>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">minimize</span></code></dt><dd><p>Interface to minimization algorithms for multivariate functions. See the \u2018L-BFGS-B\u2019 <cite>method</cite> in particular. Note that the <cite>ftol</cite> option is made available via that interface, while <cite>factr</cite> is provided via this interface, where <cite>factr</cite> is the factor multiplying the default machine floating-point precision to arrive at <cite>ftol</cite>: <code class=\"docutils literal notranslate\"><span class=\"pre\">ftol</span> <span class=\"pre\">=</span> <span class=\"pre\">factr</span> <span class=\"pre\">*</span> <span class=\"pre\">numpy.finfo(float).eps</span></code>.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>License of L-BFGS-B (FORTRAN code):</p>\n<p>The version included here (in fortran code) is 3.0\n(released April 25, 2011). It was written by Ciyou Zhu, Richard Byrd,\nand Jorge Nocedal &lt;<a class=\"reference external\" href=\"mailto:nocedal&#37;&#52;&#48;ece&#46;nwu&#46;edu\">nocedal<span>&#64;</span>ece<span>&#46;</span>nwu<span>&#46;</span>edu</a>&gt;. It carries the following\ncondition for use:</p>\n<p>This software is freely available, but we expect that all publications\ndescribing work using this software, or all commercial products using it,\nquote at least one of the references given below. This software is released\nunder the BSD License.</p>\n<p class=\"rubric\">References</p>\n<ul class=\"simple\">\n<li><p>R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound\nConstrained Optimization, (1995), SIAM Journal on Scientific and\nStatistical Computing, 16, 5, pp. 1190-1208.</p></li>\n<li><p>C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B,\nFORTRAN routines for large scale bound constrained optimization (1997),\nACM Transactions on Mathematical Software, 23, 4, pp. 550 - 560.</p></li>\n<li><p>J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B,\nFORTRAN routines for large scale bound constrained optimization (2011),\nACM Transactions on Mathematical Software, 38, 1.</p></li>\n</ul>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id848\">\n<h3>generalized_crossvalidation<a class=\"headerlink\" href=\"#id848\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.generalized_crossvalidation\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">generalized_crossvalidation</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">M</em>, <em class=\"sig-param\">LR</em>, <em class=\"sig-param\">startpoint=0.0005</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.generalized_crossvalidation\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized Cross Validation Function [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2320c3f97d4d-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Craven et al. \u201cSmoothing Noisy Data with Spline Functions.\u201d\nNUMER MATH 31.4 (1978): 377-403.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id850\">\n<h3>genlaguerre<a class=\"headerlink\" href=\"#id850\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.genlaguerre\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">genlaguerre</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">alpha</em>, <em class=\"sig-param\">monic=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.genlaguerre\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized (associated) Laguerre polynomial.</p>\n<p>Defined to be the solution of</p>\n<div class=\"math notranslate nohighlight\">\n\\[x\\frac{d^2}{dx^2}L_n^{(\\alpha)}\n  + (\\alpha + 1 - x)\\frac{d}{dx}L_n^{(\\alpha)}\n  + nL_n^{(\\alpha)} = 0,\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\alpha &gt; -1\\)</span>; <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span> is a polynomial\nof degree <span class=\"math notranslate nohighlight\">\\(n\\)</span>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int</span></dt><dd><p>Degree of the polynomial.</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float</span></dt><dd><p>Parameter, must be greater than -1.</p>\n</dd>\n<dt><strong>monic</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If <cite>True</cite>, scale the leading coefficient to be 1. Default is\n<cite>False</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>L</strong><span class=\"classifier\">orthopoly1d</span></dt><dd><p>Generalized Laguerre polynomial.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">laguerre</span></code></dt><dd><p>Laguerre polynomial.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>For fixed <span class=\"math notranslate nohighlight\">\\(\\alpha\\)</span>, the polynomials <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span>\nare orthogonal over <span class=\"math notranslate nohighlight\">\\([0, \\infty)\\)</span> with weight function\n<span class=\"math notranslate nohighlight\">\\(e^{-x}x^\\alpha\\)</span>.</p>\n<p>The Laguerre polynomials are the special case where <span class=\"math notranslate nohighlight\">\\(\\alpha\n= 0\\)</span>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gradient-table-from-gradient-strength-bvecs\">\n<h3>gradient_table_from_gradient_strength_bvecs<a class=\"headerlink\" href=\"#gradient-table-from-gradient-strength-bvecs\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">gradient_table_from_gradient_strength_bvecs</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gradient_strength</em>, <em class=\"sig-param\">bvecs</em>, <em class=\"sig-param\">big_delta</em>, <em class=\"sig-param\">small_delta</em>, <em class=\"sig-param\">b0_threshold=50</em>, <em class=\"sig-param\">atol=0.01</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.gradient_table_from_gradient_strength_bvecs\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>A general function for creating diffusion MR gradients.</p>\n<p>It reads, loads and prepares scanner parameters like the b-values and\nb-vectors so that they can be useful during the reconstruction process.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gradient_strength</strong><span class=\"classifier\">an array of shape (N,),</span></dt><dd><p>gradient strength given in T/mm</p>\n</dd>\n<dt><strong>bvecs</strong><span class=\"classifier\">can be any of two options</span></dt><dd><ol class=\"arabic simple\">\n<li><p>an array of shape (N, 3) or (3, N) with the b-vectors.</p></li>\n<li><p>a path for the file which contains an array like the previous.</p></li>\n</ol>\n</dd>\n<dt><strong>big_delta</strong><span class=\"classifier\">float or array of shape (N,)</span></dt><dd><p>acquisition pulse separation time in seconds</p>\n</dd>\n<dt><strong>small_delta</strong><span class=\"classifier\">float</span></dt><dd><p>acquisition pulse duration time in seconds</p>\n</dd>\n<dt><strong>b0_threshold</strong><span class=\"classifier\">float</span></dt><dd><p>All b-values with values less than or equal to <cite>bo_threshold</cite> are\nconsidered as b0s i.e. without diffusion weighting.</p>\n</dd>\n<dt><strong>atol</strong><span class=\"classifier\">float</span></dt><dd><p>All b-vectors need to be unit vectors up to a tolerance.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>gradients</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>A GradientTable with all the gradient information.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<ol class=\"arabic simple\">\n<li><p>Often b0s (b-values which correspond to images without diffusion\nweighting) have 0 values however in some cases the scanner cannot\nprovide b0s of an exact 0 value and it gives a bit higher values\ne.g. 6 or 12. This is the purpose of the b0_threshold in the __init__.</p></li>\n<li><p>We assume that the minimum number of b-values is 7.</p></li>\n<li><p>B-vectors should be unit vectors.</p></li>\n</ol>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.core.gradients</span> <span class=\"k\">import</span> <span class=\"p\">(</span>\n<span class=\"gp\">... </span>   <span class=\"n\">gradient_table_from_gradient_strength_bvecs</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gradient_strength</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"mf\">03e-3</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">)</span>  <span class=\"c1\"># clinical strength at 30 mT/m</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">big_delta</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"mi\">03</span>  <span class=\"c1\"># pulse separation of 30ms</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">small_delta</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>  <span class=\"c1\"># pulse duration of 10ms</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gradient_strength</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sq2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">bvecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">],</span>\n<span class=\"gp\">... </span>                  <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">,</span> <span class=\"n\">sq2</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">gt</span> <span class=\"o\">=</span> <span class=\"n\">gradient_table_from_gradient_strength_bvecs</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">gradient_strength</span><span class=\"p\">,</span> <span class=\"n\">bvecs</span><span class=\"p\">,</span> <span class=\"n\">big_delta</span><span class=\"p\">,</span> <span class=\"n\">small_delta</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"l1-crossvalidation\">\n<h3>l1_crossvalidation<a class=\"headerlink\" href=\"#l1-crossvalidation\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.l1_crossvalidation\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">l1_crossvalidation</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">b0s_mask</em>, <em class=\"sig-param\">E</em>, <em class=\"sig-param\">M</em>, <em class=\"sig-param\">weight_array=array([0.</em>, <em class=\"sig-param\">0.02</em>, <em class=\"sig-param\">0.04</em>, <em class=\"sig-param\">0.06</em>, <em class=\"sig-param\">0.08</em>, <em class=\"sig-param\">0.1</em>, <em class=\"sig-param\">0.12</em>, <em class=\"sig-param\">0.14</em>, <em class=\"sig-param\">0.16</em>, <em class=\"sig-param\">0.18</em>, <em class=\"sig-param\">0.2</em>, <em class=\"sig-param\">0.22</em>, <em class=\"sig-param\">0.24</em>, <em class=\"sig-param\">0.26</em>, <em class=\"sig-param\">0.28</em>, <em class=\"sig-param\">0.3</em>, <em class=\"sig-param\">0.32</em>, <em class=\"sig-param\">0.34</em>, <em class=\"sig-param\">0.36</em>, <em class=\"sig-param\">0.38</em>, <em class=\"sig-param\">0.4 ])</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.l1_crossvalidation\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>cross-validation function to find the optimal weight of alpha for\nsparsity regularization</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id851\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id851\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id852\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id852\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part1-reg-matrix-tau\">\n<h3>part1_reg_matrix_tau<a class=\"headerlink\" href=\"#part1-reg-matrix-tau\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part1_reg_matrix_tau\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part1_reg_matrix_tau</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">ut</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part1_reg_matrix_tau\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial temporal Laplacian regularization matrix following\nAppendix B in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8e68d0fd6501-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part23-iso-reg-matrix-q\">\n<h3>part23_iso_reg_matrix_q<a class=\"headerlink\" href=\"#part23-iso-reg-matrix-q\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part23_iso_reg_matrix_q\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part23_iso_reg_matrix_q</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">us</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part23_iso_reg_matrix_q\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial spherical spatial Laplacian regularization matrix following the\nequation below Eq. (C4) in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r5e69c004448e-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part23-reg-matrix-q\">\n<h3>part23_reg_matrix_q<a class=\"headerlink\" href=\"#part23-reg-matrix-q\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part23_reg_matrix_q\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part23_reg_matrix_q</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">U_mat</em>, <em class=\"sig-param\">T_mat</em>, <em class=\"sig-param\">us</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part23_reg_matrix_q\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial cartesian spatial Laplacian regularization matrix following\nsecond line of Eq. (B2) in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3f2cd4a23cf5-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part23-reg-matrix-tau\">\n<h3>part23_reg_matrix_tau<a class=\"headerlink\" href=\"#part23-reg-matrix-tau\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part23_reg_matrix_tau\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part23_reg_matrix_tau</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">ut</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part23_reg_matrix_tau\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial temporal Laplacian regularization matrix following\nAppendix B in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd02c9fab0299-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part4-iso-reg-matrix-q\">\n<h3>part4_iso_reg_matrix_q<a class=\"headerlink\" href=\"#part4-iso-reg-matrix-q\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part4_iso_reg_matrix_q\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part4_iso_reg_matrix_q</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">us</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part4_iso_reg_matrix_q\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial spherical spatial Laplacian regularization matrix following the\nequation below Eq. (C4) in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r14eeb60c3baf-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part4-reg-matrix-q\">\n<h3>part4_reg_matrix_q<a class=\"headerlink\" href=\"#part4-reg-matrix-q\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part4_reg_matrix_q\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part4_reg_matrix_q</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">U_mat</em>, <em class=\"sig-param\">us</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part4_reg_matrix_q\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial cartesian spatial Laplacian regularization matrix following\nequation Eq. (B2) in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd6bc6528afc6-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"part4-reg-matrix-tau\">\n<h3>part4_reg_matrix_tau<a class=\"headerlink\" href=\"#part4-reg-matrix-tau\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.part4_reg_matrix_tau\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">part4_reg_matrix_tau</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">ut</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.part4_reg_matrix_tau\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Partial temporal Laplacian regularization matrix following\nAppendix B in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra481a087fd3c-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-anisotropic-scaling\">\n<h3>qtdmri_anisotropic_scaling<a class=\"headerlink\" href=\"#qtdmri-anisotropic-scaling\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_anisotropic_scaling\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_anisotropic_scaling</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">bvecs</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_anisotropic_scaling\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for fitting an exponential to the\ndiffusion time points.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-eap-matrix\">\n<h3>qtdmri_eap_matrix<a class=\"headerlink\" href=\"#qtdmri-eap-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_eap_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_eap_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">grid</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_eap_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs the design matrix as a product of 3 separated radial,\nangular and temporal design matrices. It precomputes the relevant basis\norders for each one and finally puts them together according to the index\nmatrix</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id860\">\n<h3><a href=\"#id989\"><span class=\"problematic\" id=\"id990\">qtdmri_eap_matrix_</span></a><a class=\"headerlink\" href=\"#id860\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_eap_matrix_\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_eap_matrix_</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">grid</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_eap_matrix_\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-index-matrix\">\n<h3>qtdmri_index_matrix<a class=\"headerlink\" href=\"#qtdmri-index-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_index_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_index_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_index_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the SHORE basis order indices according to [1].</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-eap-matrix\">\n<h3>qtdmri_isotropic_eap_matrix<a class=\"headerlink\" href=\"#qtdmri-isotropic-eap-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_eap_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">grid</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs the design matrix as a product of 3 separated radial,\nangular and temporal design matrices. It precomputes the relevant basis\norders for each one and finally puts them together according to the index\nmatrix</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id861\">\n<h3><a href=\"#id991\"><span class=\"problematic\" id=\"id992\">qtdmri_isotropic_eap_matrix_</span></a><a class=\"headerlink\" href=\"#id861\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_eap_matrix_</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">grid</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_eap_matrix_\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-index-matrix\">\n<h3>qtdmri_isotropic_index_matrix<a class=\"headerlink\" href=\"#qtdmri-isotropic-index-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_index_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_index_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the SHORE basis order indices according to [1].</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-laplacian-reg-matrix\">\n<h3>qtdmri_isotropic_laplacian_reg_matrix<a class=\"headerlink\" href=\"#qtdmri-isotropic-laplacian-reg-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_laplacian_reg_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">part1_uq_iso_precomp=None</em>, <em class=\"sig-param\">part1_ut_precomp=None</em>, <em class=\"sig-param\">part23_ut_precomp=None</em>, <em class=\"sig-param\">part4_ut_precomp=None</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_laplacian_reg_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the spherical qt-dMRI Laplacian regularization matrix. If\ngiven, uses precomputed matrices for temporal and spatial regularization\nmatrices to speed up computation. Follows the the formulation of Appendix C\nin [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r191ed4b20871-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-scaling\">\n<h3>qtdmri_isotropic_scaling<a class=\"headerlink\" href=\"#qtdmri-isotropic-scaling\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_scaling\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_scaling</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_scaling\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs design matrix for fitting an exponential to the\ndiffusion time points.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-signal-matrix\">\n<h3>qtdmri_isotropic_signal_matrix<a class=\"headerlink\" href=\"#qtdmri-isotropic-signal-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_signal_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"id863\">\n<h3><a href=\"#id993\"><span class=\"problematic\" id=\"id994\">qtdmri_isotropic_signal_matrix_</span></a><a class=\"headerlink\" href=\"#id863\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_signal_matrix_</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">tau</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_signal_matrix_\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-isotropic-to-mapmri-matrix\">\n<h3>qtdmri_isotropic_to_mapmri_matrix<a class=\"headerlink\" href=\"#qtdmri-isotropic-to-mapmri-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_isotropic_to_mapmri_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_isotropic_to_mapmri_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generates the matrix that maps the spherical qtdmri coefficients to\nMAP-MRI coefficients. The conversion is done by only evaluating the time\nbasis for a diffusion time tau and summing up coefficients with the same\nspatial basis orders [1].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>\n</dd>\n<dt><strong>time_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order\nof the basis.</p>\n</dd>\n<dt><strong>ut</strong><span class=\"classifier\">float</span></dt><dd><p>temporal scaling factor</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra63fed2caebe-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-laplacian-reg-matrix\">\n<h3>qtdmri_laplacian_reg_matrix<a class=\"headerlink\" href=\"#qtdmri-laplacian-reg-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_laplacian_reg_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ind_mat</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">S_mat=None</em>, <em class=\"sig-param\">T_mat=None</em>, <em class=\"sig-param\">U_mat=None</em>, <em class=\"sig-param\">part1_ut_precomp=None</em>, <em class=\"sig-param\">part23_ut_precomp=None</em>, <em class=\"sig-param\">part4_ut_precomp=None</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_laplacian_reg_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the cartesian qt-dMRI Laplacian regularization matrix. If\ngiven, uses precomputed matrices for temporal and spatial regularization\nmatrices to speed up computation. Follows the the formulation of Appendix B\nin [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r74810f43fcd2-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-mapmri-isotropic-normalization\">\n<h3>qtdmri_mapmri_isotropic_normalization<a class=\"headerlink\" href=\"#qtdmri-mapmri-isotropic-normalization\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_mapmri_isotropic_normalization</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">u0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_mapmri_isotropic_normalization\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Normalization factor for Spherical MAP-MRI basis. The normalization\nfor a basis function with orders [j,l,m] depends only on orders j,l and\nthe isotropic scale factor.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-mapmri-normalization\">\n<h3>qtdmri_mapmri_normalization<a class=\"headerlink\" href=\"#qtdmri-mapmri-normalization\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_mapmri_normalization\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_mapmri_normalization</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">mu</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_mapmri_normalization\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Normalization factor for Cartesian MAP-MRI basis. The scaling is the\nsame for every basis function depending only on the spatial scaling\nmu.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-number-of-coefficients\">\n<h3>qtdmri_number_of_coefficients<a class=\"headerlink\" href=\"#qtdmri-number-of-coefficients\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_number_of_coefficients\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_number_of_coefficients</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_number_of_coefficients\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Computes the total number of coefficients of the qtdmri basis given a\nradial and temporal order. Equation given below Eq (9) in [1].</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcf42999df2c0-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-signal-matrix\">\n<h3>qtdmri_signal_matrix<a class=\"headerlink\" href=\"#qtdmri-signal-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_signal_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_signal_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_signal_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Constructs the design matrix as a product of 3 separated radial,\nangular and temporal design matrices. It precomputes the relevant basis\norders for each one and finally puts them together according to the index\nmatrix</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id867\">\n<h3><a href=\"#id995\"><span class=\"problematic\" id=\"id996\">qtdmri_signal_matrix_</span></a><a class=\"headerlink\" href=\"#id867\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_signal_matrix_\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_signal_matrix_</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">q</em>, <em class=\"sig-param\">tau</em>, <em class=\"sig-param\">normalization=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_signal_matrix_\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Function to generate the qtdmri signal basis.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-temporal-normalization\">\n<h3>qtdmri_temporal_normalization<a class=\"headerlink\" href=\"#qtdmri-temporal-normalization\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_temporal_normalization\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_temporal_normalization</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ut</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_temporal_normalization\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Normalization factor for the temporal basis</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qtdmri-to-mapmri-matrix\">\n<h3>qtdmri_to_mapmri_matrix<a class=\"headerlink\" href=\"#qtdmri-to-mapmri-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">qtdmri_to_mapmri_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">time_order</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.qtdmri_to_mapmri_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generates the matrix that maps the qtdmri coefficients to MAP-MRI\ncoefficients. The conversion is done by only evaluating the time basis for\na diffusion time tau and summing up coefficients with the same spatial\nbasis orders [1].</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer representing the spatial/radial order of the basis.</p>\n</dd>\n<dt><strong>time_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an integer larger or equal than zero representing the time order\nof the basis.</p>\n</dd>\n<dt><strong>ut</strong><span class=\"classifier\">float</span></dt><dd><p>temporal scaling factor</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float</span></dt><dd><p>diffusion time (big_delta - small_delta / 3.) in seconds</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r9f26e60b820f-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Fick, Rutger HJ, et al. \u201cNon-Parametric GraphNet-Regularized\nRepresentation of dMRI in Space and Time\u201d, Medical Image Analysis,\n2017.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"radial-basis-eap-opt\">\n<h3>radial_basis_EAP_opt<a class=\"headerlink\" href=\"#radial-basis-eap-opt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.radial_basis_EAP_opt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">radial_basis_EAP_opt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">r</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.radial_basis_EAP_opt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</div>\n<div class=\"section\" id=\"radial-basis-opt\">\n<h3>radial_basis_opt<a class=\"headerlink\" href=\"#radial-basis-opt\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.radial_basis_opt\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">radial_basis_opt</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">j</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">us</em>, <em class=\"sig-param\">q</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.radial_basis_opt\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spatial basis dependent on spatial scaling factor us</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id869\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#id869\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"temporal-basis\">\n<h3>temporal_basis<a class=\"headerlink\" href=\"#temporal-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.temporal_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">temporal_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">o</em>, <em class=\"sig-param\">ut</em>, <em class=\"sig-param\">tau</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.temporal_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Temporal basis dependent on temporal scaling factor ut</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"visualise-gradient-table-g-delta-rainbow\">\n<h3>visualise_gradient_table_G_Delta_rainbow<a class=\"headerlink\" href=\"#visualise-gradient-table-g-delta-rainbow\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">visualise_gradient_table_G_Delta_rainbow</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">big_delta_start=None</em>, <em class=\"sig-param\">big_delta_end=None</em>, <em class=\"sig-param\">G_start=None</em>, <em class=\"sig-param\">G_end=None</em>, <em class=\"sig-param\">bval_isolines=array([    0</em>, <em class=\"sig-param\">250</em>, <em class=\"sig-param\">1000</em>, <em class=\"sig-param\">2500</em>, <em class=\"sig-param\">5000</em>, <em class=\"sig-param\">7500</em>, <em class=\"sig-param\">10000</em>, <em class=\"sig-param\">14000])</em>, <em class=\"sig-param\">alpha_shading=0.6</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.visualise_gradient_table_G_Delta_rainbow\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>This function visualizes a q-tau acquisition scheme as a function of\ngradient strength and pulse separation (big_delta). It represents every\nmeasurements at its G and big_delta position regardless of b-vector, with a\nbackground of b-value isolines for reference. It assumes there is only one\nunique pulse length (small_delta) in the acquisition scheme.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable object</span></dt><dd><p>constructed gradient table with big_delta and small_delta given as\ninputs.</p>\n</dd>\n<dt><strong>big_delta_start</strong><span class=\"classifier\">float,</span></dt><dd><p>optional minimum big_delta that is plotted in seconds</p>\n</dd>\n<dt><strong>big_delta_end</strong><span class=\"classifier\">float,</span></dt><dd><p>optional maximum big_delta that is plotted in seconds</p>\n</dd>\n<dt><strong>G_start</strong><span class=\"classifier\">float,</span></dt><dd><p>optional minimum gradient strength that is plotted in T/m</p>\n</dd>\n<dt><strong>G_end</strong><span class=\"classifier\">float,</span></dt><dd><p>optional maximum gradient strength taht is plotted in T/m</p>\n</dd>\n<dt><strong>bval_isolines</strong><span class=\"classifier\">array,</span></dt><dd><p>optional array of bvalue isolines that are plotted in the background</p>\n</dd>\n<dt><strong>alpha_shading</strong><span class=\"classifier\">float between [0-1]</span></dt><dd><p>optional shading of the bvalue colors in the background</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id870\">\n<h3>warn<a class=\"headerlink\" href=\"#id870\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.qtdmri.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.qtdmri.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.qtdmri.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id871\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.Cache\" title=\"dipy.reconst.sfm.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id871\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.sfm.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.Cache.cache_clear\" title=\"dipy.reconst.sfm.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.Cache.cache_get\" title=\"dipy.reconst.sfm.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.Cache.cache_set\" title=\"dipy.reconst.sfm.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"exponentialisotropicfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit\" title=\"dipy.reconst.sfm.ExponentialIsotropicFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicFit</span></code></a><a class=\"headerlink\" href=\"#exponentialisotropicfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">ExponentialIsotropicFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicFit\" title=\"dipy.reconst.sfm.IsotropicFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.sfm.IsotropicFit</span></code></a></p>\n<p>A fit to the ExponentialIsotropicModel object, based on data.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit.predict\" title=\"dipy.reconst.sfm.ExponentialIsotropicFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab])</p></td>\n<td><p>Predict the isotropic signal, based on a gradient table.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IsotropicFit object.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">IsotropicModel class instance</span></dt><dd></dd>\n<dt><strong>params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The mean isotropic model parameters (the mean diffusion-weighted\nsignal in each voxel).</p>\n</dd>\n<dt><strong>n_vox</strong><span class=\"classifier\">int</span></dt><dd><p>The number of voxels for which the fit was done.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the isotropic signal, based on a gradient table. In this case,\nthe prediction will be for an exponential decay with the mean\ndiffusivity derived from the data that was fit.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance (optional)</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this\nfit was derived.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"exponentialisotropicmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel\" title=\"dipy.reconst.sfm.ExponentialIsotropicModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicModel</span></code></a><a class=\"headerlink\" href=\"#exponentialisotropicmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">ExponentialIsotropicModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicModel\" title=\"dipy.reconst.sfm.IsotropicModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.sfm.IsotropicModel</span></code></a></p>\n<p>Representing the isotropic signal as a fit to an exponential decay function\nwith b-values</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel.fit\" title=\"dipy.reconst.sfm.ExponentialIsotropicModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><p></p></dd>\n</dl>\n</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IsotropicModel.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ExponentialIsotropicModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ExponentialIsotropicModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>ExponentialIsotropicFit class instance.</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"isotropicfit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicFit\" title=\"dipy.reconst.sfm.IsotropicFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IsotropicFit</span></code></a><a class=\"headerlink\" href=\"#isotropicfit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.IsotropicFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">IsotropicFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p>A fit object for representing the isotropic signal as the mean of the\ndiffusion-weighted signal.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicFit.predict\" title=\"dipy.reconst.sfm.IsotropicFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab])</p></td>\n<td><p>Predict the isotropic signal.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.IsotropicFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">params</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IsotropicFit object.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">IsotropicModel class instance</span></dt><dd></dd>\n<dt><strong>params</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The mean isotropic model parameters (the mean diffusion-weighted\nsignal in each voxel).</p>\n</dd>\n<dt><strong>n_vox</strong><span class=\"classifier\">int</span></dt><dd><p>The number of voxels for which the fit was done.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.IsotropicFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the isotropic signal.</p>\n<p>Based on a gradient table. In this case, the (naive!) prediction will\nbe the mean of the diffusion-weighted signal in the voxels.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance (optional)</span></dt><dd><p>Defaults to use the gtab from the IsotropicModel from which this\nfit was derived.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"isotropicmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicModel\" title=\"dipy.reconst.sfm.IsotropicModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IsotropicModel</span></code></a><a class=\"headerlink\" href=\"#isotropicmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.IsotropicModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">IsotropicModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>A base-class for the representation of isotropic signals.</p>\n<p>The default behavior, suitable for single b-value data is to calculate the\nmean in each voxel as an estimate of the signal that does not depend on\ndirection.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.IsotropicModel.fit\" title=\"dipy.reconst.sfm.IsotropicModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit an IsotropicModel.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.IsotropicModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize an IsotropicModel.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.IsotropicModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.IsotropicModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit an IsotropicModel.</p>\n<p>This boils down to finding the mean diffusion-weighted signal in each\nvoxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">ndarray</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>IsotropicFit class instance.</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id872\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ReconstFit\" title=\"dipy.reconst.sfm.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a><a class=\"headerlink\" href=\"#id872\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.ReconstFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">ReconstFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ReconstFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class which holds the fit result of ReconstModel</p>\n<p>For example that could be holding FA or GFA etc.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ReconstFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ReconstFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id873\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.ReconstModel\" title=\"dipy.reconst.sfm.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a><a class=\"headerlink\" href=\"#id873\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.ReconstModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">ReconstModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ReconstModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Abstract class for signal reconstruction models</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>fit</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ReconstModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ReconstModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.ReconstModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.ReconstModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sparsefasciclefit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleFit\" title=\"dipy.reconst.sfm.SparseFascicleFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SparseFascicleFit</span></code></a><a class=\"headerlink\" href=\"#sparsefasciclefit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">SparseFascicleFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">beta</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">iso</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleFit.odf\" title=\"dipy.reconst.sfm.SparseFascicleFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>The orientation distribution function of the SFM</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleFit.predict\" title=\"dipy.reconst.sfm.SparseFascicleFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab,\u00a0response,\u00a0S0])</p></td>\n<td><p>Predict the signal based on the SFM parameters</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">beta</em>, <em class=\"sig-param\">S0</em>, <em class=\"sig-param\">iso</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initalize a SparseFascicleFit class instance</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">a SparseFascicleModel object.</span></dt><dd></dd>\n<dt><strong>beta</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The parameters of fit to data.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The mean non-diffusion-weighted signal.</p>\n</dd>\n<dt><strong>iso</strong><span class=\"classifier\">IsotropicFit class instance</span></dt><dd><p>A representation of the isotropic signal, together with parameters\nof the isotropic signal in each voxel, that is capable of\nderiving/predicting an isotropic signal, based on a gradient-table.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The orientation distribution function of the SFM</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points in which the ODF is evaluated</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>odf</strong><span class=\"classifier\">ndarray of shape (x, y, z, sphere.vertices.shape[0])</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">response=None</em>, <em class=\"sig-param\">S0=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the signal based on the SFM parameters</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable, optional</span></dt><dd><p>The bvecs/bvals to predict the signal on. Default: the gtab from\nthe model object.</p>\n</dd>\n<dt><strong>response</strong><span class=\"classifier\">list of 3 elements, optional</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel\nfunction. Default: the response of the model object. Default to use\n<cite>model.response</cite>.</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float or array, optional</span></dt><dd><p>The non-diffusion-weighted signal. Default: use the S0 of the data</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>pred_sig</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The signal predicted in each voxel/direction</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sparsefasciclemodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleModel\" title=\"dipy.reconst.sfm.SparseFascicleModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SparseFascicleModel</span></code></a><a class=\"headerlink\" href=\"#sparsefasciclemodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">SparseFascicleModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleModel.design_matrix\" title=\"dipy.reconst.sfm.SparseFascicleModel.design_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">design_matrix</span></code></a>()</p></td>\n<td><p>The design matrix for a SFM.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.sfm.SparseFascicleModel.fit\" title=\"dipy.reconst.sfm.SparseFascicleModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit the SparseFascicleModel object to data.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab, sphere=None, response=[0.0015, 0.0005, 0.0005], solver='ElasticNet', l1_ratio=0.5, alpha=0.001, isotropic=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize a Sparse Fascicle Model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere class instance, optional</span></dt><dd><p>A sphere on which coefficients will be estimated. Default:</p>\n</dd>\n<dt><strong>symmetric sphere with 362 points (from :mod:`dipy.data`).</strong></dt><dd></dd>\n<dt><strong>response</strong><span class=\"classifier\">(3,) array-like, optional</span></dt><dd><p>The eigenvalues of a canonical tensor to be used as the response\nfunction of single-fascicle signals.\nDefault:[0.0015, 0.0005, 0.0005]</p>\n</dd>\n<dt><strong>solver</strong><span class=\"classifier\">string, or initialized linear model object.</span></dt><dd><p>This will determine the algorithm used to solve the set of linear\nequations underlying this model. If it is a string it needs to be\none of the following: {\u2018ElasticNet\u2019, \u2018NNLS\u2019}. Otherwise, it can be\nan object that inherits from <cite>dipy.optimize.SKLearnLinearSolver</cite>\nor an object with a similar interface from Scikit Learn:\n<cite>sklearn.linear_model.ElasticNet</cite>, <cite>sklearn.linear_model.Lasso</cite> or\n<cite>sklearn.linear_model.Ridge</cite> and other objects that inherit from\n<cite>sklearn.base.RegressorMixin</cite>.\nDefault: \u2018ElasticNet\u2019.</p>\n</dd>\n<dt><strong>l1_ratio</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Sets the balance betwee L1 and L2 regularization in ElasticNet\n<a class=\"reference internal\" href=\"#r3db2a282ece1-zou2005\" id=\"id874\">[Zou2005]</a>. Default: 0.5</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Sets the balance between least-squares error and L1/L2\nregularization in ElasticNet <a class=\"reference internal\" href=\"#r3db2a282ece1-zou2005\" id=\"id875\">[Zou2005]</a>. Default: 0.001</p>\n</dd>\n<dt><strong>isotropic</strong><span class=\"classifier\">IsotropicModel class instance</span></dt><dd><p>This is a class that implements the function that calculates the\nvalue of the isotropic signal. This is a value of the signal that\nis independent of direction, and therefore removed from both sides\nof the SFM equation. The default is an instance of IsotropicModel,\nbut other functions can be inherited from IsotropicModel to\nimplement other fits to the aspects of the data that depend on\nb-value, but not on direction.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This is an implementation of the SFM, described in <a class=\"reference internal\" href=\"../../examples_built/tracking_sfm/#rokem2015\" id=\"id876\"><span>[Rokem2015]</span></a>.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3db2a282ece1-rokem2014\"><span class=\"brackets\">Rokem2014</span></dt>\n<dd><p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick\nN. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell\n(2014). Evaluating the accuracy of diffusion MRI models in white\nmatter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>\n</dd>\n<dt class=\"label\" id=\"r3db2a282ece1-zou2005\"><span class=\"brackets\">Zou2005</span><span class=\"fn-backref\">(<a href=\"#id874\">1</a>,<a href=\"#id875\">2</a>)</span></dt>\n<dd><p>Zou H, Hastie T (2005). Regularization and variable\nselection via the elastic net. J R Stat Soc B:301-320</p>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleModel.design_matrix\">\n<code class=\"sig-name descname\">design_matrix</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleModel.design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The design matrix for a SFM.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Returns</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>ndarray</dt><dd><p>The design matrix, where each column is a rotated version of the\nresponse function.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.sfm.SparseFascicleModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.SparseFascicleModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit the SparseFascicleModel object to data.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>data</strong><span class=\"classifier\">array</span></dt><dd><p>The measured signal.</p>\n</dd>\n<dt><strong>mask</strong><span class=\"classifier\">array, optional</span></dt><dd><p>A boolean array used to mark the coordinates in the data that\nshould be analyzed. Has the shape <cite>data.shape[:-1]</cite>. Default: None,\nwhich implies that all points should be analyzed.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>SparseFascicleFit object</dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id877\">\n<h3>auto_attr<a class=\"headerlink\" href=\"#id877\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.sfm.auto_attr\">\n<code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">auto_attr</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.auto_attr\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Decorator to create OneTimeProperty attributes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">method</span></dt><dd><p>The method that will be called the first time to compute a value.\nAfterwards, the method\u2019s name will be a standard attribute holding the\nvalue of this computation.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">MagicProp</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nd\">@auto_attr</span>\n<span class=\"gp\">... </span>    <span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>        <span class=\"k\">return</span> <span class=\"mi\">99</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">MagicProp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"go\">99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"nanmean\">\n<h3>nanmean<a class=\"headerlink\" href=\"#nanmean\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.sfm.nanmean\">\n<code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">nanmean</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">a</em>, <em class=\"sig-param\">axis=None</em>, <em class=\"sig-param\">dtype=None</em>, <em class=\"sig-param\">out=None</em>, <em class=\"sig-param\">keepdims=&lt;no value&gt;</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.nanmean\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>\n<p>Returns the average of the array elements.  The average is taken over\nthe flattened array by default, otherwise over the specified axis.\n<cite>float64</cite> intermediate and return values are used for integer inputs.</p>\n<p>For all-NaN slices, NaN is returned and a <cite>RuntimeWarning</cite> is raised.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.8.0.</span></p>\n</div>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>a</strong><span class=\"classifier\">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>a</cite> is not an\narray, a conversion is attempted.</p>\n</dd>\n<dt><strong>axis</strong><span class=\"classifier\">{int, tuple of int, None}, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to compute\nthe mean of the flattened array.</p>\n</dd>\n<dt><strong>dtype</strong><span class=\"classifier\">data-type, optional</span></dt><dd><p>Type to use in computing the mean.  For integer inputs, the default\nis <cite>float64</cite>; for inexact inputs, it is the same as the input\ndtype.</p>\n</dd>\n<dt><strong>out</strong><span class=\"classifier\">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  The default\nis <code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code>; if provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary. See\n<cite>ufuncs-output-type</cite> for more details.</p>\n</dd>\n<dt><strong>keepdims</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original <cite>a</cite>.</p>\n<p>If the value is anything but the default, then\n<cite>keepdims</cite> will be passed through to the <cite>mean</cite> or <cite>sum</cite> methods\nof sub-classes of <cite>ndarray</cite>.  If the sub-classes methods\ndoes not implement <cite>keepdims</cite> any exceptions will be raised.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>m</strong><span class=\"classifier\">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,\notherwise a reference to the output array is returned. Nan is\nreturned for slices that contain only NaNs.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">average</span></code></dt><dd><p>Weighted average</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">mean</span></code></dt><dd><p>Arithmetic mean taken while not ignoring NaNs</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">var</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">nanvar</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>The arithmetic mean is the sum of the non-NaN elements along the axis\ndivided by the number of non-NaN elements.</p>\n<p>Note that for floating-point input, the mean is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for <cite>float32</cite>.  Specifying a\nhigher-precision accumulator using the <cite>dtype</cite> keyword can alleviate\nthis issue.</p>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nanmean</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"go\">2.6666666666666665</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nanmean</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"go\">array([2.,  4.])</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nanmean</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"go\">array([1.,  3.5]) # may vary</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id878\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id878\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.sfm.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sfm-design-matrix\">\n<h3>sfm_design_matrix<a class=\"headerlink\" href=\"#sfm-design-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.sfm.sfm_design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.sfm.</code><code class=\"sig-name descname\">sfm_design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">response</em>, <em class=\"sig-param\">mode='signal'</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.sfm.sfm_design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Construct the SFM design matrix</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable or Sphere</span></dt><dd><p>Sets the rows of the matrix, if the mode is \u2018signal\u2019, this should be a\nGradientTable. If mode is \u2018odf\u2019 this should be a Sphere</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>Sets the columns of the matrix</p>\n</dd>\n<dt><strong>response</strong><span class=\"classifier\">list of 3 elements</span></dt><dd><p>The eigenvalues of a tensor which will serve as a kernel\nfunction.</p>\n</dd>\n<dt><strong>mode</strong><span class=\"classifier\">str {\u2018signal\u2019 | \u2018odf\u2019}, optional</span></dt><dd><p>Choose the (default) \u2018signal\u2019 for a design matrix containing predicted\nsignal in the measurements defined by the gradient table for putative\nfascicles oriented along the vertices of the sphere. Otherwise, choose\n\u2018odf\u2019 for an odf convolution matrix, with values of the odf calculated\nfrom a tensor with the provided response eigenvalues, evaluated at the\nb-vectors in the gradient table, for the tensors with prinicipal\ndiffusion directions along the vertices of the sphere.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>mat</strong><span class=\"classifier\">ndarray</span></dt><dd><p>A design matrix that can be used for one of the following operations:\nwhen the \u2018signal\u2019 mode is used, each column contains the putative\nsignal in each of the bvectors of the <cite>gtab</cite> if a fascicle is oriented\nin the direction encoded by the sphere vertex corresponding to this\ncolumn. This is used for deconvolution with a measured DWI signal. If\nthe \u2018odf\u2019 mode is chosen, each column instead contains the values of\nthe tensor ODF for a tensor with a principal diffusion direction\ncorresponding to this vertex. This is used to generate odfs from the\nfits of the SFM for the purpose of tracking.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rdfd493249d4f-rokem2015\"><span class=\"brackets\">Rokem2015</span></dt>\n<dd><p>Ariel Rokem, Jason D. Yeatman, Franco Pestilli, Kendrick\nN. Kay, Aviv Mezer, Stefan van der Walt, Brian A. Wandell\n(2015). Evaluating the accuracy of diffusion MRI models in white\nmatter. PLoS ONE 10(4): e0123272. doi:10.1371/journal.pone.0123272</p>\n</dd>\n<dt class=\"label\" id=\"rdfd493249d4f-rokem2014\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id879\">Rokem2014</a></span></dt>\n<dd><p>Ariel Rokem, Kimberly L. Chan, Jason D. Yeatman, Franco\nPestilli,  Brian A. Wandell (2014). Evaluating the accuracy of diffusion\nmodels at multiple b-values with cross-validation. ISMRM 2014.</p>\n</dd>\n<dt class=\"label\" id=\"rdfd493249d4f-behrens2007\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id880\">Behrens2007</a></span></dt>\n<dd><p>Behrens TEJ, Berg HJ, Jbabdi S, Rushworth MFS, Woolrich MW\n(2007): Probabilistic diffusion tractography with multiple fibre\norientations: What can we gain? Neuroimage 34:144-55.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">dipy.data</span> <span class=\"k\">as</span> <span class=\"nn\">dpd</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">gtab</span> <span class=\"o\">=</span> <span class=\"n\">dpd</span><span class=\"o\">.</span><span class=\"n\">dsi_voxels</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sphere</span> <span class=\"o\">=</span> <span class=\"n\">dpd</span><span class=\"o\">.</span><span class=\"n\">get_sphere</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.reconst.sfm</span> <span class=\"k\">import</span> <span class=\"n\">sfm_design_matrix</span>\n</pre></div>\n</div>\n<p>A canonical tensor approximating corpus-callosum voxels <a class=\"reference internal\" href=\"#rdfd493249d4f-rokem2014\" id=\"id879\">[Rokem2014]</a>:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">tensor_matrix</span> <span class=\"o\">=</span> <span class=\"n\">sfm_design_matrix</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>                                  <span class=\"p\">[</span><span class=\"mf\">0.0015</span><span class=\"p\">,</span> <span class=\"mf\">0.0005</span><span class=\"p\">,</span> <span class=\"mf\">0.0005</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>A \u2018stick\u2019 function (<a class=\"reference internal\" href=\"#rdfd493249d4f-behrens2007\" id=\"id880\">[Behrens2007]</a>):</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">stick_matrix</span> <span class=\"o\">=</span> <span class=\"n\">sfm_design_matrix</span><span class=\"p\">(</span><span class=\"n\">gtab</span><span class=\"p\">,</span> <span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">0.001</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id881\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.Cache\" title=\"dipy.reconst.shm.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id881\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.shm.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.Cache.cache_clear\" title=\"dipy.reconst.shm.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.Cache.cache_get\" title=\"dipy.reconst.shm.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.Cache.cache_set\" title=\"dipy.reconst.shm.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"csaodfmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.CsaOdfModel\" title=\"dipy.reconst.shm.CsaOdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CsaOdfModel</span></code></a><a class=\"headerlink\" href=\"#csaodfmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.CsaOdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">CsaOdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.CsaOdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"dipy.reconst.shm.QballBaseModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.QballBaseModel</span></code></a></p>\n<p>Implementation of Constant Solid Angle reconstruction method.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rbc00e9136e1b-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Aganj, I., et al. 2009. ODF Reconstruction in Q-Ball Imaging With\nSolid Angle Consideration.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code>(data[,\u00a0mask])</p></td>\n<td><p>Fits the model to diffusion data and returns the model fit</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.CsaOdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.CsaOdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Creates a model that can be used to fit or sample diffusion data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are\nclipped to <cite>min_signal</cite>. This is done primarily to avoid values\nless than or equal to zero when taking logs.</p>\n</dd>\n<dt><strong>assume_normed</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the\nmean B0 signal are skipped during mode fitting. This is an advanced\nfeature and should be used with care.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shm.normalize_data\" title=\"dipy.reconst.shm.normalize_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_data</span></code></a></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.shm.CsaOdfModel.max\">\n<code class=\"sig-name descname\">max</code><em class=\"property\"> = 0.999</em><a class=\"headerlink\" href=\"#dipy.reconst.shm.CsaOdfModel.max\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.shm.CsaOdfModel.min\">\n<code class=\"sig-name descname\">min</code><em class=\"property\"> = 0.001</em><a class=\"headerlink\" href=\"#dipy.reconst.shm.CsaOdfModel.min\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id883\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfFit\" title=\"dipy.reconst.shm.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a><a class=\"headerlink\" href=\"#id883\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.OdfFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">OdfFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstFit\" title=\"dipy.reconst.base.ReconstFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstFit</span></code></a></p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfFit.odf\" title=\"dipy.reconst.shm.OdfFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>To be implemented but specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.OdfFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.OdfFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented but specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id884\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfModel\" title=\"dipy.reconst.shm.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a><a class=\"headerlink\" href=\"#id884\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.OdfModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">OdfModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.base.ReconstModel\" title=\"dipy.reconst.base.ReconstModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.base.ReconstModel</span></code></a></p>\n<p>An abstract class to be sub-classed by specific odf models</p>\n<p>All odf models should provide a fit method which may take data as it\u2019s\nfirst and only argument.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.OdfModel.fit\" title=\"dipy.reconst.shm.OdfModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.OdfModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.OdfModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OdfModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>To be implemented by specific odf models</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"opdtmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.OpdtModel\" title=\"dipy.reconst.shm.OpdtModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OpdtModel</span></code></a><a class=\"headerlink\" href=\"#opdtmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.OpdtModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">OpdtModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OpdtModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"dipy.reconst.shm.QballBaseModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.QballBaseModel</span></code></a></p>\n<p>Implementation of Orientation Probability Density Transform\nreconstruction method.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r51b90ac51a5a-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tristan-Vega, A., et al. 2010. A new methodology for estimation of\nfiber populations in white matter of the brain with Funk-Radon\ntransform.</p>\n</dd>\n<dt class=\"label\" id=\"r51b90ac51a5a-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tristan-Vega, A., et al. 2009. Estimation of fiber orientation\nprobability density functions in high angular resolution diffusion\nimaging.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code>(data[,\u00a0mask])</p></td>\n<td><p>Fits the model to diffusion data and returns the model fit</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.OpdtModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.OpdtModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Creates a model that can be used to fit or sample diffusion data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are\nclipped to <cite>min_signal</cite>. This is done primarily to avoid values\nless than or equal to zero when taking logs.</p>\n</dd>\n<dt><strong>assume_normed</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the\nmean B0 signal are skipped during mode fitting. This is an advanced\nfeature and should be used with care.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shm.normalize_data\" title=\"dipy.reconst.shm.normalize_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_data</span></code></a></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qballbasemodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"dipy.reconst.shm.QballBaseModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QballBaseModel</span></code></a><a class=\"headerlink\" href=\"#qballbasemodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.QballBaseModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">QballBaseModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.SphHarmModel</span></code></a></p>\n<p>To be subclassed by Qball type models.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel.fit\" title=\"dipy.reconst.shm.QballBaseModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fits the model to diffusion data and returns the model fit</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.QballBaseModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.QballBaseModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Creates a model that can be used to fit or sample diffusion data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are\nclipped to <cite>min_signal</cite>. This is done primarily to avoid values\nless than or equal to zero when taking logs.</p>\n</dd>\n<dt><strong>assume_normed</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the\nmean B0 signal are skipped during mode fitting. This is an advanced\nfeature and should be used with care.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shm.normalize_data\" title=\"dipy.reconst.shm.normalize_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_data</span></code></a></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.QballBaseModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.QballBaseModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fits the model to diffusion data and returns the model fit</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"qballmodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.QballModel\" title=\"dipy.reconst.shm.QballModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QballModel</span></code></a><a class=\"headerlink\" href=\"#qballmodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.QballModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">QballModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.QballModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.shm.QballBaseModel\" title=\"dipy.reconst.shm.QballBaseModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.shm.QballBaseModel</span></code></a></p>\n<p>Implementation of regularized Qball reconstruction method.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"ra7cb3e95affa-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Descoteaux, M., et al. 2007. Regularized, fast, and robust\nanalytical Q-ball imaging.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code>(data[,\u00a0mask])</p></td>\n<td><p>Fits the model to diffusion data and returns the model fit</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.QballModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">smooth=0.006</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">assume_normed=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.QballModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Creates a model that can be used to fit or sample diffusion data</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Diffusion gradients used to acquire data</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">even int &gt;= 0</span></dt><dd><p>the spherical harmonic order of the model</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float between 0 and 1, optional</span></dt><dd><p>The regularization parameter of the model</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float, &gt; 0, optional</span></dt><dd><p>During fitting, all signal values less than <cite>min_signal</cite> are\nclipped to <cite>min_signal</cite>. This is done primarily to avoid values\nless than or equal to zero when taking logs.</p>\n</dd>\n<dt><strong>assume_normed</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, clipping and normalization of the data with respect to the\nmean B0 signal are skipped during mode fitting. This is an advanced\nfeature and should be used with care.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shm.normalize_data\" title=\"dipy.reconst.shm.normalize_data\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">normalize_data</span></code></a></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"residualbootstrapwrapper\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.ResidualBootstrapWrapper\" title=\"dipy.reconst.shm.ResidualBootstrapWrapper\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ResidualBootstrapWrapper</span></code></a><a class=\"headerlink\" href=\"#residualbootstrapwrapper\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.ResidualBootstrapWrapper\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">ResidualBootstrapWrapper</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">signal_object</em>, <em class=\"sig-param\">B</em>, <em class=\"sig-param\">where_dwi</em>, <em class=\"sig-param\">min_signal=1e-05</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.ResidualBootstrapWrapper\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Returns a residual bootstrap sample of the signal_object when indexed</p>\n<p>Wraps a signal_object, this signal object can be an interpolator. When\nindexed, the the wrapper indexes the signal_object to get the signal.\nThere wrapper than samples the residual boostrap distribution of signal and\nreturns that sample.</p>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.ResidualBootstrapWrapper.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">signal_object</em>, <em class=\"sig-param\">B</em>, <em class=\"sig-param\">where_dwi</em>, <em class=\"sig-param\">min_signal=1e-05</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.ResidualBootstrapWrapper.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Builds a ResidualBootstrapWapper</p>\n<p>Given some linear model described by B, the design matrix, and a\nsignal_object, returns an object which can sample the residual\nbootstrap distribution of the signal. We assume that the signals are\nnormalized so we clip the bootsrap samples to be between <cite>min_signal</cite>\nand 1.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>signal_object</strong><span class=\"classifier\">some object that can be indexed</span></dt><dd><p>This object should return diffusion weighted signals when indexed.</p>\n</dd>\n<dt><strong>B</strong><span class=\"classifier\">ndarray, ndim=2</span></dt><dd><p>The design matrix of the spherical harmonics model used to fit the\ndata. This is the model that will be used to compute the residuals\nand sample the residual bootstrap distribution</p>\n</dd>\n<dt><strong>where_dwi :</strong></dt><dd><p>indexing object to find diffusion weighted signals from signal</p>\n</dd>\n<dt><strong>min_signal</strong><span class=\"classifier\">float</span></dt><dd><p>The lowest allowable signal.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id888\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit\" title=\"dipy.reconst.shm.SphHarmFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a><a class=\"headerlink\" href=\"#id888\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.SphHarmFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">SphHarmFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shm_coef</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfFit\" title=\"dipy.reconst.odf.OdfFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfFit</span></code></a></p>\n<p>Diffusion data fit to a spherical harmonic model</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>shape</strong></dt><dd></dd>\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit.shm_coeff\" title=\"dipy.reconst.shm.SphHarmFit.shm_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm_coeff</span></code></a></dt><dd><p>The spherical harmonic coefficients of the odf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit.odf\" title=\"dipy.reconst.shm.SphHarmFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>Samples the odf function on the points of a sphere</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmFit.predict\" title=\"dipy.reconst.shm.SphHarmFit.predict\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">predict</span></code></a>([gtab,\u00a0S0])</p></td>\n<td><p>Predict the diffusion signal from the model coefficients.</p></td>\n</tr>\n</tbody>\n</table>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 41%\" />\n<col style=\"width: 59%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>gfa</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shm_coef</em>, <em class=\"sig-param\">mask</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.gfa\">\n<code class=\"sig-name descname\">gfa</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.gfa\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Samples the odf function on the points of a sphere</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points on which to sample the odf.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>values</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The value of the odf on each point of <cite>sphere</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.predict\">\n<code class=\"sig-name descname\">predict</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab=None</em>, <em class=\"sig-param\">S0=1.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.predict\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Predict the diffusion signal from the model coefficients.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">a GradientTable class instance</span></dt><dd><p>The directions and bvalues on which prediction is desired</p>\n</dd>\n<dt><strong>S0</strong><span class=\"classifier\">float array</span></dt><dd><p>The mean non-diffusion-weighted signal in each voxel.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.shape\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shape</code><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.shape\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmFit.shm_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shm_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmFit.shm_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The spherical harmonic coefficients of the odf</p>\n<p>Make this a property for now, if there is a usecase for modifying\nthe coefficients we can add a setter or expose the coefficients more\ndirectly</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id889\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"dipy.reconst.shm.SphHarmModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a><a class=\"headerlink\" href=\"#id889\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shm.SphHarmModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">SphHarmModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.odf.OdfModel\" title=\"dipy.reconst.odf.OdfModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.odf.OdfModel</span></code></a>, <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>To be subclassed by all models that return a SphHarmFit when fit.</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code>(data)</p></td>\n<td><p>To be implemented by specific odf models</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shm.SphHarmModel.sampling_matrix\" title=\"dipy.reconst.shm.SphHarmModel.sampling_matrix\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">sampling_matrix</span></code></a>(sphere)</p></td>\n<td><p>The matrix needed to sample ODFs from coefficients of the model.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialization of the abstract class for signal reconstruction models</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable class instance</span></dt><dd></dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shm.SphHarmModel.sampling_matrix\">\n<code class=\"sig-name descname\">sampling_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.SphHarmModel.sampling_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The matrix needed to sample ODFs from coefficients of the model.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>Points used to sample ODF.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sampling_matrix</strong><span class=\"classifier\">array</span></dt><dd><p>The size of the matrix will be (N, M) where N is the number of\nvertices on sphere and M is the number of coefficients needed by\nthe model.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"anisotropic-power\">\n<h3>anisotropic_power<a class=\"headerlink\" href=\"#anisotropic-power\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.anisotropic_power\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">anisotropic_power</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeffs</em>, <em class=\"sig-param\">norm_factor=1e-05</em>, <em class=\"sig-param\">power=2</em>, <em class=\"sig-param\">non_negative=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.anisotropic_power\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate anisotropic power map with a given SH coefficient matrix.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeffs</strong><span class=\"classifier\">ndarray</span></dt><dd><p>A ndarray where the last dimension is the\nSH coefficients estimates for that voxel.</p>\n</dd>\n<dt><strong>norm_factor: float, optional</strong></dt><dd><p>The value to normalize the ap values.</p>\n</dd>\n<dt><strong>power</strong><span class=\"classifier\">int, optional</span></dt><dd><p>The degree to which power maps are calculated.</p>\n</dd>\n<dt><strong>non_negative: bool, optional</strong></dt><dd><p>Whether to rectify the resulting map to be non-negative.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>log_ap</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The log of the resulting power image.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>Calculate AP image based on a IxJxKxC SH coefficient matrix based on the\nequation:\n.. math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">AP</span> <span class=\"o\">=</span> \\<span class=\"n\">sum_</span><span class=\"p\">{</span><span class=\"n\">l</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"o\">...</span><span class=\"p\">}{</span>\\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">}{</span><span class=\"mi\">2</span><span class=\"n\">l</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">}</span> \\<span class=\"n\">sum_</span><span class=\"p\">{</span><span class=\"n\">m</span><span class=\"o\">=-</span><span class=\"n\">l</span><span class=\"p\">}</span><span class=\"o\">^</span><span class=\"n\">l</span><span class=\"p\">{</span><span class=\"o\">|</span><span class=\"n\">a_</span><span class=\"p\">{</span><span class=\"n\">l</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">}</span><span class=\"o\">|^</span><span class=\"n\">n</span><span class=\"p\">}}</span>\n</pre></div>\n</div>\n<p>Where the last dimension, C, is made of a flattened array of <span class=\"math notranslate nohighlight\">\\(l\\)</span>\ncoefficients, where <span class=\"math notranslate nohighlight\">\\(l\\)</span> are the SH orders, and <span class=\"math notranslate nohighlight\">\\(m = 2l+1\\)</span>,\nSo l=1 has 1 coeffecient, l=2 has 5, \u2026 l=8 has 17 and so on.\nA l=2 SH coefficient matrix will then be composed of a IxJxKx6 volume.\nThe power, <span class=\"math notranslate nohighlight\">\\(n\\)</span> is usually set to <span class=\"math notranslate nohighlight\">\\(n=2\\)</span>.</p>\n<p>The final AP image is then shifted by -log(norm_factor), to be strictly\nnon-negative. Remaining values &lt; 0 are discarded (set to 0), per default,\nand this option is controlled through the <cite>non_negative</cite> keyword argument.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r52e1c5ce9111-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Dell\u2019Acqua, F., Lacerda, L., Catani, M., Simmons, A., 2014.\nAnisotropic Power Maps: A diffusion contrast to reveal low\nanisotropy tissues from HARDI data,\nin: Proceedings of International Society for Magnetic Resonance in\nMedicine. Milan, Italy.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id891\">\n<h3>auto_attr<a class=\"headerlink\" href=\"#id891\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.auto_attr\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">auto_attr</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">func</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.auto_attr\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Decorator to create OneTimeProperty attributes.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>func</strong><span class=\"classifier\">method</span></dt><dd><p>The method that will be called the first time to compute a value.\nAfterwards, the method\u2019s name will be a standard attribute holding the\nvalue of this computation.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">MagicProp</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"nd\">@auto_attr</span>\n<span class=\"gp\">... </span>    <span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>        <span class=\"k\">return</span> <span class=\"mi\">99</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">MagicProp</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">False</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">a</span>\n<span class=\"go\">99</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"s1\">&#39;a&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bootstrap-data-array\">\n<h3>bootstrap_data_array<a class=\"headerlink\" href=\"#bootstrap-data-array\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.bootstrap_data_array\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">bootstrap_data_array</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">H</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">permute=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.bootstrap_data_array\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies the Residual Bootstraps to the data given H and R</p>\n<p>data must be normalized, ie 0 &lt; data &lt;= 1</p>\n<p>This function, and the bootstrap_data_voxel function, calculate\nresidual-bootsrap samples given a Hat matrix and a Residual matrix. These\nsamples can be used for non-parametric statistics or for bootstrap\nprobabilistic tractography:</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rf84331cfd25c-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>J. I. Berman, et al., \u201cProbabilistic streamline q-ball tractography\nusing the residual bootstrap\u201d 2008.</p>\n</dd>\n<dt class=\"label\" id=\"rf84331cfd25c-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>HA Haroon, et al., \u201cUsing the model-based residual bootstrap to\nquantify uncertainty in fiber orientations from Q-ball analysis\u201d\n2009.</p>\n</dd>\n<dt class=\"label\" id=\"rf84331cfd25c-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>B. Jeurissen, et al., \u201cProbabilistic Fiber Tracking Using the\nResidual Bootstrap with Constrained Spherical Deconvolution\u201d 2011.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"bootstrap-data-voxel\">\n<h3>bootstrap_data_voxel<a class=\"headerlink\" href=\"#bootstrap-data-voxel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.bootstrap_data_voxel\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">bootstrap_data_voxel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">H</em>, <em class=\"sig-param\">R</em>, <em class=\"sig-param\">permute=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.bootstrap_data_voxel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Like bootstrap_data_array but faster when for a single voxel</p>\n<p>data must be 1d and normalized</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"calculate-max-order\">\n<h3>calculate_max_order<a class=\"headerlink\" href=\"#calculate-max-order\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.calculate_max_order\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">calculate_max_order</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n_coeffs</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.calculate_max_order\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculate the maximal harmonic order, given that you know the\nnumber of parameters that were estimated.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n_coeffs</strong><span class=\"classifier\">int</span></dt><dd><p>The number of SH coefficients</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the used SH basis contains even and odd order SH functions.\nFalse if the SH basis consists only of even order SH functions.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>L</strong><span class=\"classifier\">int</span></dt><dd><p>The maximal SH order, given the number of coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>The calculation in this function for the symmetric SH basis\nproceeds according to the following logic:\n.. math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">n</span> <span class=\"o\">=</span> \\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">}{</span><span class=\"mi\">2</span><span class=\"p\">}</span> <span class=\"p\">(</span><span class=\"n\">L</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">L</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\\<span class=\"n\">rarrow</span> <span class=\"mi\">2</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">L</span><span class=\"o\">^</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"n\">L</span> <span class=\"o\">+</span> <span class=\"mi\">2</span>\n\\<span class=\"n\">rarrow</span> <span class=\"n\">L</span><span class=\"o\">^</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"n\">L</span> <span class=\"o\">+</span> <span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\\<span class=\"n\">rarrow</span> <span class=\"n\">L</span><span class=\"o\">^</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"n\">L</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\\<span class=\"n\">rarrow</span> <span class=\"n\">L_</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">}</span> <span class=\"o\">=</span> \\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"o\">-</span><span class=\"mi\">3</span> \\<span class=\"n\">pm</span> \\<span class=\"n\">sqrt</span><span class=\"p\">{</span><span class=\"mi\">9</span> <span class=\"o\">-</span> <span class=\"mi\">8</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">n</span><span class=\"p\">)}}{</span><span class=\"mi\">2</span><span class=\"p\">}</span>\n\\<span class=\"n\">rarrow</span> <span class=\"n\">L</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">}</span> <span class=\"o\">=</span> \\<span class=\"n\">frac</span><span class=\"p\">{</span><span class=\"o\">-</span><span class=\"mi\">3</span> \\<span class=\"n\">pm</span> \\<span class=\"n\">sqrt</span><span class=\"p\">{</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">8</span><span class=\"n\">n</span><span class=\"p\">}}{</span><span class=\"mi\">2</span><span class=\"p\">}</span>\n</pre></div>\n</div>\n<p>Finally, the positive value is chosen between the two options.</p>\n<p>For a full SH basis, the calcultation consists in solving the equation\n<span class=\"math notranslate nohighlight\">\\(n = (L + 1)^2\\)</span> for <span class=\"math notranslate nohighlight\">\\(L\\)</span>, which gives <span class=\"math notranslate nohighlight\">\\(L = sqrt(n) - 1\\)</span>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id895\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id895\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"convert-sh-from-legacy\">\n<h3>convert_sh_from_legacy<a class=\"headerlink\" href=\"#convert-sh-from-legacy\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.convert_sh_from_legacy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">convert_sh_from_legacy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeffs</em>, <em class=\"sig-param\">sh_basis</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.convert_sh_from_legacy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert SH coefficients in legacy SH basis to SH coefficients\nof the new SH basis for <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> <a class=\"reference internal\" href=\"#r8020d68d5dcd-1\" id=\"id896\">[1]</a> or <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> [R8020d68d5dcd-2]_[R8020d68d5dcd-3]_\nbases.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the\nSH coefficients estimates for that voxel.</p>\n</dd>\n<dt><strong>sh_basis: {\u2018descoteaux07\u2019, \u2018tournier07\u2019}</strong></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 [R8020d68d5dcd-2]_[R8020d68d5dcd-3]_ basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#r8020d68d5dcd-1\" id=\"id897\">[1]</a> basis.</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the input SH basis includes both even and odd\norder SH functions, else False.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the new SH basis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8020d68d5dcd-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id63\">1</a>,<a href=\"#id896\">2</a>,<a href=\"#id897\">3</a>)</span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"r8020d68d5dcd-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"r8020d68d5dcd-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"convert-sh-to-full-basis\">\n<h3>convert_sh_to_full_basis<a class=\"headerlink\" href=\"#convert-sh-to-full-basis\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.convert_sh_to_full_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">convert_sh_to_full_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeffs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.convert_sh_to_full_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given an array of SH coeffs from a symmetric basis, returns the\ncoefficients for the full SH basis by filling odd order SH coefficients\nwith zeros</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the\nSH coefficients estimates for that voxel.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>full_sh_coeffs: ndarray</dt><dd><p>A ndarray where the last dimension is the\nSH coefficients estimates for that voxel in\na full SH basis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"convert-sh-to-legacy\">\n<h3>convert_sh_to_legacy<a class=\"headerlink\" href=\"#convert-sh-to-legacy\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.convert_sh_to_legacy\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">convert_sh_to_legacy</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_coeffs</em>, <em class=\"sig-param\">sh_basis</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.convert_sh_to_legacy\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Convert SH coefficients in new SH basis to SH coefficients for\nthe legacy SH basis for <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> <a class=\"reference internal\" href=\"#r2032a14b59d6-1\" id=\"id901\">[1]</a> or <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> [R2032a14b59d6-2]_[R2032a14b59d6-3]_\nbases.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_coeffs: ndarray</strong></dt><dd><p>A ndarray where the last dimension is the\nSH coefficients estimates for that voxel.</p>\n</dd>\n<dt><strong>sh_basis: {\u2018descoteaux07\u2019, \u2018tournier07\u2019}</strong></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 [R2032a14b59d6-2]_[R2032a14b59d6-3]_ basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#r2032a14b59d6-1\" id=\"id902\">[1]</a> basis.</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True if the input SH basis includes both even and odd\norder SH functions.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>out_sh_coeffs: ndarray</dt><dd><p>The array of coefficients expressed in the legacy SH basis.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r2032a14b59d6-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id64\">1</a>,<a href=\"#id901\">2</a>,<a href=\"#id902\">3</a>)</span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"r2032a14b59d6-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"r2032a14b59d6-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id906\">\n<h3>deprecate_with_version<a class=\"headerlink\" href=\"#id906\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.deprecate_with_version\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">deprecate_with_version</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">message</em>, <em class=\"sig-param\">since=''</em>, <em class=\"sig-param\">until=''</em>, <em class=\"sig-param\">version_comparator=&lt;function cmp_pkg_version&gt;</em>, <em class=\"sig-param\">warn_class=&lt;class 'DeprecationWarning'&gt;</em>, <em class=\"sig-param\">error_class=&lt;class 'dipy.utils.deprecator.ExpiredDeprecationError'&gt;</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.deprecate_with_version\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return decorator function function for deprecation warning / error.</p>\n<p>The decorated function / method will:</p>\n<ul class=\"simple\">\n<li><p>Raise the given <cite>warning_class</cite> warning when the function / method gets\ncalled, up to (and including) version <cite>until</cite> (if specified);</p></li>\n<li><p>Raise the given <cite>error_class</cite> error when the function / method gets\ncalled, when the package version is greater than version <cite>until</cite> (if\nspecified).</p></li>\n</ul>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>message</strong><span class=\"classifier\">str</span></dt><dd><p>Message explaining deprecation, giving possible alternatives.</p>\n</dd>\n<dt><strong>since</strong><span class=\"classifier\">str, optional</span></dt><dd><p>Released version at which object was first deprecated.</p>\n</dd>\n<dt><strong>until</strong><span class=\"classifier\">str, optional</span></dt><dd><p>Last released version at which this function will still raise a\ndeprecation warning.  Versions higher than this will raise an\nerror.</p>\n</dd>\n<dt><strong>version_comparator</strong><span class=\"classifier\">callable</span></dt><dd><p>Callable accepting string as argument, and return 1 if string\nrepresents a higher version than encoded in the <cite>version_comparator</cite>, 0\nif the version is equal, and -1 if the version is lower.  For example,\nthe <cite>version_comparator</cite> may compare the input version string to the\ncurrent package version string.</p>\n</dd>\n<dt><strong>warn_class</strong><span class=\"classifier\">class, optional</span></dt><dd><p>Class of warning to generate for deprecation.</p>\n</dd>\n<dt><strong>error_class</strong><span class=\"classifier\">class, optional</span></dt><dd><p>Class of error to generate when <cite>version_comparator</cite> returns 1 for a\ngiven argument of <code class=\"docutils literal notranslate\"><span class=\"pre\">until</span></code>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>deprecator</strong><span class=\"classifier\">func</span></dt><dd><p>Function returning a decorator.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id907\">\n<h3>forward_sdeconv_mat<a class=\"headerlink\" href=\"#id907\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.forward_sdeconv_mat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">forward_sdeconv_mat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_rh</em>, <em class=\"sig-param\">n</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.forward_sdeconv_mat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Build forward spherical deconvolution matrix</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r_rh</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Rotational harmonics coefficients for the single fiber response\nfunction. Each element <code class=\"docutils literal notranslate\"><span class=\"pre\">rh[i]</span></code> is associated with spherical harmonics\nof degree <code class=\"docutils literal notranslate\"><span class=\"pre\">2*i</span></code>.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray</span></dt><dd><p>The order of spherical harmonic function associated with each row of\nthe deconvolution matrix. Only even orders are allowed</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>R</strong><span class=\"classifier\">ndarray (N, N)</span></dt><dd><p>Deconvolution matrix with shape (N, N)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"gen-dirac\">\n<h3>gen_dirac<a class=\"headerlink\" href=\"#gen-dirac\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.gen_dirac\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">gen_dirac</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.gen_dirac\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generate Dirac delta function orientated in (theta, phi) on the sphere</p>\n<p>The spherical harmonics (SH) representation of this Dirac is returned as\ncoefficients to spherical harmonic functions produced from <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>\nbasis.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>m</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The degree of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The order of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>dirac</strong><span class=\"classifier\">ndarray</span></dt><dd><p>SH coefficients representing the Dirac function. The shape of this is\n<cite>(m + 2) * (m + 1) / 2</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_descoteaux_from_index</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_descoteaux</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"hat\">\n<h3>hat<a class=\"headerlink\" href=\"#hat\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.hat\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">hat</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">B</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.hat\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the hat matrix for the design matrix B</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id908\">\n<h3>lazy_index<a class=\"headerlink\" href=\"#id908\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.lazy_index\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">lazy_index</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">index</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.lazy_index\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Produces a lazy index</p>\n<p>Returns a slice that can be used for indexing an array, if no slice can be\nmade index is returned as is.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"lcr-matrix\">\n<h3>lcr_matrix<a class=\"headerlink\" href=\"#lcr-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.lcr_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">lcr_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">H</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.lcr_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns a matrix for computing leveraged, centered residuals from data</p>\n<p>if r = (d-Hd), the leveraged centered residuals are lcr = (r/l)-mean(r/l)\nruturns the matrix R, such lcr = Rd</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"normalize-data\">\n<h3>normalize_data<a class=\"headerlink\" href=\"#normalize-data\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.normalize_data\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">normalize_data</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">where_b0</em>, <em class=\"sig-param\">min_signal=1e-05</em>, <em class=\"sig-param\">out=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.normalize_data\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Normalizes the data with respect to the mean b0</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"order-from-ncoef\">\n<h3>order_from_ncoef<a class=\"headerlink\" href=\"#order-from-ncoef\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.order_from_ncoef\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">order_from_ncoef</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">ncoef</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.order_from_ncoef\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given a number <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> of coefficients, calculate back the <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>ncoef: int</strong></dt><dd><p>number of coefficients</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True when coefficients are for a full SH basis.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt>sh_order: int</dt><dd><p>maximum order of SH basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"randint\">\n<h3>randint<a class=\"headerlink\" href=\"#randint\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.randint\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">randint</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">low</em>, <em class=\"sig-param\">high=None</em>, <em class=\"sig-param\">size=None</em>, <em class=\"sig-param\">dtype=int</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.randint\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return random integers from <cite>low</cite> (inclusive) to <cite>high</cite> (exclusive).</p>\n<p>Return random integers from the \u201cdiscrete uniform\u201d distribution of\nthe specified dtype in the \u201chalf-open\u201d interval [<cite>low</cite>, <cite>high</cite>). If\n<cite>high</cite> is None (the default), then results are from [0, <cite>low</cite>).</p>\n<div class=\"admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>New code should use the <code class=\"docutils literal notranslate\"><span class=\"pre\">integers</span></code> method of a <code class=\"docutils literal notranslate\"><span class=\"pre\">default_rng()</span></code>\ninstance instead; see <cite>random-quick-start</cite>.</p>\n</div>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>low</strong><span class=\"classifier\">int or array-like of ints</span></dt><dd><p>Lowest (signed) integers to be drawn from the distribution (unless\n<code class=\"docutils literal notranslate\"><span class=\"pre\">high=None</span></code>, in which case this parameter is one above the\n<em>highest</em> such integer).</p>\n</dd>\n<dt><strong>high</strong><span class=\"classifier\">int or array-like of ints, optional</span></dt><dd><p>If provided, one above the largest (signed) integer to be drawn\nfrom the distribution (see above for behavior if <code class=\"docutils literal notranslate\"><span class=\"pre\">high=None</span></code>).\nIf array-like, must contain integer values</p>\n</dd>\n<dt><strong>size</strong><span class=\"classifier\">int or tuple of ints, optional</span></dt><dd><p>Output shape.  If the given shape is, e.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">(m,</span> <span class=\"pre\">n,</span> <span class=\"pre\">k)</span></code>, then\n<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span> <span class=\"pre\">*</span> <span class=\"pre\">n</span> <span class=\"pre\">*</span> <span class=\"pre\">k</span></code> samples are drawn.  Default is None, in which case a\nsingle value is returned.</p>\n</dd>\n<dt><strong>dtype</strong><span class=\"classifier\">dtype, optional</span></dt><dd><p>Desired dtype of the result. Byteorder must be native.\nThe default value is int.</p>\n<div class=\"versionadded\">\n<p><span class=\"versionmodified added\">New in version 1.11.0.</span></p>\n</div>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>out</strong><span class=\"classifier\">int or ndarray of ints</span></dt><dd><p><cite>size</cite>-shaped array of random integers from the appropriate\ndistribution, or a single such random int if <cite>size</cite> not provided.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">random_integers</span></code></dt><dd><p>similar to <cite>randint</cite>, only for the closed interval [<cite>low</cite>, <cite>high</cite>], and 1 is the lowest value if <cite>high</cite> is omitted.</p>\n</dd>\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">Generator.integers</span></code></dt><dd><p>which should be used for new code.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"go\">array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"go\">array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</span>\n</pre></div>\n</div>\n<p>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"go\">array([[4, 0, 2, 1], # random</span>\n<span class=\"go\">       [3, 2, 2, 0]])</span>\n</pre></div>\n</div>\n<p>Generate a 1 x 3 array with 3 different upper bounds</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">])</span>\n<span class=\"go\">array([2, 2, 9]) # random</span>\n</pre></div>\n</div>\n<p>Generate a 1 by 3 array with 3 different lower bounds</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">],</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"go\">array([9, 8, 7]) # random</span>\n</pre></div>\n</div>\n<p>Generate a 2 by 4 array using broadcasting with dtype of uint8</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">],</span> <span class=\"p\">[[</span><span class=\"mi\">10</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">20</span><span class=\"p\">]],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">)</span>\n<span class=\"go\">array([[ 8,  6,  9,  7], # random</span>\n<span class=\"go\">       [ 1, 16,  9, 12]], dtype=uint8)</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sh-descoteaux\">\n<h3>real_sh_descoteaux<a class=\"headerlink\" href=\"#real-sh-descoteaux\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sh_descoteaux\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sh_descoteaux</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">full_basis=False</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sh_descoteaux\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <span id=\"id909\">[R191e35d27b5b-1]</span>,\nwhere the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                      if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>The maximum degree or the spherical harmonic basis.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If true, returns a basis including odd order SH functions as well as\neven order SH functions. Otherwise returns only even order SH\nfunctions.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses DIPY\u2019s legacy descoteaux07 implementation (where <a href=\"#id981\"><span class=\"problematic\" id=\"id982\">|m|</span></a>\nfor m &lt; 0). Else, implements the basis as defined in Descoteaux et al.\n2007.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>real_sh</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code>.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">array</span></dt><dd><p>The degree of the harmonics.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">array</span></dt><dd><p>The order of the harmonics.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sh-descoteaux-from-index\">\n<h3>real_sh_descoteaux_from_index<a class=\"headerlink\" href=\"#real-sh-descoteaux-from-index\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sh_descoteaux_from_index\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sh_descoteaux_from_index</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sh_descoteaux_from_index\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics as in Descoteaux et al. 2007 <span id=\"id910\">[R700bd48b1688-1]</span>,\nwhere the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                      if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses DIPY\u2019s legacy descoteaux07 implementation (where <a href=\"#id983\"><span class=\"problematic\" id=\"id984\">|m|</span></a>\nis used for m &lt; 0). Else, implements the basis as defined in\nDescoteaux et al. 2007 (without the absolute value).</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>real_sh</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sh-tournier\">\n<h3>real_sh_tournier<a class=\"headerlink\" href=\"#real-sh-tournier\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sh_tournier\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sh_tournier</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">full_basis=False</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sh_tournier\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics as initially defined in Tournier\n2007 <a class=\"reference internal\" href=\"#rcffec8eb7314-1\" id=\"id911\">[1]</a> then updated in MRtrix3 <a class=\"reference internal\" href=\"#rcffec8eb7314-2\" id=\"id912\">[2]</a>, where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>\nis defined to be:</p>\n<blockquote>\n<div><p>Real(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                      if m = 0\nImag(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)    if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>The maximum degree or the spherical harmonic basis.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If true, returns a basis including odd order SH functions as well as\neven order SH functions. Else returns only even order SH functions.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses MRtrix 0.2 SH basis definition, where the <code class=\"docutils literal notranslate\"><span class=\"pre\">sqrt(2)</span></code>\nfactor is omitted. Else, uses MRtrix 3 definition presented above.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>real_sh</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code>.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">array</span></dt><dd><p>The degree of the harmonics.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">array</span></dt><dd><p>The order of the harmonics.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rcffec8eb7314-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id65\">1</a>,<a href=\"#id911\">2</a>)</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"rcffec8eb7314-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id66\">1</a>,<a href=\"#id912\">2</a>)</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sh-tournier-from-index\">\n<h3>real_sh_tournier_from_index<a class=\"headerlink\" href=\"#real-sh-tournier-from-index\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sh_tournier_from_index\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sh_tournier_from_index</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sh_tournier_from_index\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics as initially defined in Tournier\n2007 <a class=\"reference internal\" href=\"#r3f87c5e3a9f2-1\" id=\"id915\">[1]</a> then updated in MRtrix3 <a class=\"reference internal\" href=\"#r3f87c5e3a9f2-2\" id=\"id916\">[2]</a>, where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>\nis defined to be:</p>\n<blockquote>\n<div><p>Real(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)      if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                      if m = 0\nImag(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)    if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>If true, uses MRtrix 0.2 SH basis definition, where the <code class=\"docutils literal notranslate\"><span class=\"pre\">sqrt(2)</span></code>\nfactor is omitted. Else, uses the MRtrix 3 definition presented above.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>real_sh</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonics <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r3f87c5e3a9f2-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id67\">1</a>,<a href=\"#id915\">2</a>)</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"r3f87c5e3a9f2-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id68\">1</a>,<a href=\"#id916\">2</a>)</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id919\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#id919\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id920\">\n<h3>real_sym_sh_basis<a class=\"headerlink\" href=\"#id920\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sym_sh_basis\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sym_sh_basis</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sym_sh_basis\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Samples a real symmetric spherical harmonic basis at point on the sphere</p>\n<p>dipy.reconst.shm.real_sym_sh_basis is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Samples the basis functions up to order <cite>sh_order</cite> at points on the sphere\ngiven by <cite>theta</cite> and <cite>phi</cite>. The basis functions are defined here the same\nway as in Descoteaux et al. 2007 <a class=\"reference internal\" href=\"#r573dd6557753-1\" id=\"id921\">[1]</a> where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is\ndefined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>even int &gt; 0, max spherical harmonic order</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code></p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">array</span></dt><dd><p>The degree of the harmonics.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">array</span></dt><dd><p>The order of the harmonics.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r573dd6557753-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id921\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"real-sym-sh-mrtrix\">\n<h3>real_sym_sh_mrtrix<a class=\"headerlink\" href=\"#real-sym-sh-mrtrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.real_sym_sh_mrtrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">real_sym_sh_mrtrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.real_sym_sh_mrtrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>dipy.reconst.shm.real_sym_sh_mrtix is deprecated, Please use dipy.reconst.shm.real_sh_tournier instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Compute real symmetric spherical harmonics as in Tournier 2007 <a class=\"reference internal\" href=\"#r220a2be8a767-2\" id=\"id923\">[2]</a>, where\nthe real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>Real(:math:`Y^m_n`)       if m &gt; 0\n:math:`Y^0_n`             if m = 0\nImag(:math:`Y^|m|_n`)     if m &lt; 0\n</pre></div>\n</div>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>The maximum order or the spherical harmonic basis.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code> as\nimplemented in mrtrix. Warning: the basis is Tournier et al.\n2007 <a class=\"reference internal\" href=\"#r220a2be8a767-2\" id=\"id924\">[2]</a>; 2004 <a class=\"reference internal\" href=\"#r220a2be8a767-1\" id=\"id925\">[1]</a> is slightly different.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">array</span></dt><dd><p>The degree of the harmonics.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">array</span></dt><dd><p>The order of the harmonics.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r220a2be8a767-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id925\">1</a></span></dt>\n<dd><p>Tournier J.D., Calamante F., Gadian D.G. and Connelly A.\nDirect estimation of the fibre orientation density function from\ndiffusion-weighted MRI data using spherical deconvolution.\nNeuroImage. 2004;23:1176-1185.</p>\n</dd>\n<dt class=\"label\" id=\"r220a2be8a767-2\"><span class=\"brackets\">2</span><span class=\"fn-backref\">(<a href=\"#id923\">1</a>,<a href=\"#id924\">2</a>)</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sf-to-sh\">\n<h3>sf_to_sh<a class=\"headerlink\" href=\"#sf-to-sh\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.sf_to_sh\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">sf_to_sh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sf</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">sh_order=4</em>, <em class=\"sig-param\">basis_type=None</em>, <em class=\"sig-param\">full_basis=False</em>, <em class=\"sig-param\">legacy=True</em>, <em class=\"sig-param\">smooth=0.0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.sf_to_sh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical function to spherical harmonics (SH).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Values of a function on the given <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere</span></code>.</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points on which the sf is defined.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>, there will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)</span> <span class=\"pre\">/</span> <span class=\"pre\">2</span></code> SH coefficients for a symmetric\nbasis and <code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span></code> coefficients for a full\nSH basis.</p>\n</dd>\n<dt><strong>basis_type</strong><span class=\"classifier\">{None, \u2018tournier07\u2019, \u2018descoteaux07\u2019}, optional</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the default DIPY basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 [R52104e733a02-2]_[R52104e733a02-3]_ basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#r52104e733a02-1\" id=\"id928\">[1]</a> basis,\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>).</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for using a SH basis containing even and odd order SH functions.\nFalse for using a SH basis consisting only of even order SH functions.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility\nwith previous <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> implementations.</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sh</strong><span class=\"classifier\">ndarray</span></dt><dd><p>SH coefficients representing the input function.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r52104e733a02-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id928\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"r52104e733a02-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"r52104e733a02-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id932\">\n<h3>sh_to_rh<a class=\"headerlink\" href=\"#id932\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.sh_to_rh\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">sh_to_rh</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_sh</em>, <em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.sh_to_rh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical harmonics (SH) to rotational harmonics (RH)</p>\n<p>Calculate the rotational harmonic decomposition up to\nharmonic order <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>, degree <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code> for an axially and antipodally\nsymmetric function. Note that all <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span> <span class=\"pre\">!=</span> <span class=\"pre\">0</span></code> coefficients\nwill be ignored as axial symmetry is assumed. Hence, there\nwill be <code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order/2</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span></code> non-zero coefficients.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>r_sh</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>ndarray of SH coefficients for the single fiber response function.\nThese coefficients must correspond to the real spherical harmonic\nfunctions produced by <cite>shm.real_sph_harm</cite>.</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The degree of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">ndarray (N,)</span></dt><dd><p>The order of the spherical harmonic function associated with each\ncoefficient.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>r_rh</strong><span class=\"classifier\">ndarray (<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)*(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)/2</span></code>,)</span></dt><dd><p>Rotational harmonics coefficients representing the input <cite>r_sh</cite></p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sph_harm</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sym_sh_basis</span></code></dt><dd></dd>\n</dl>\n</div>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r31c920df34a3-1\"><span class=\"brackets\">1</span></dt>\n<dd><p>Tournier, J.D., et al. NeuroImage 2007. Robust determination of the\nfibre orientation distribution in diffusion MRI: Non-negativity\nconstrained super-resolved spherical deconvolution</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sh-to-sf\">\n<h3>sh_to_sf<a class=\"headerlink\" href=\"#sh-to-sf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.sh_to_sf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">sh_to_sf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh</em>, <em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">sh_order=4</em>, <em class=\"sig-param\">basis_type=None</em>, <em class=\"sig-param\">full_basis=False</em>, <em class=\"sig-param\">legacy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.sh_to_sf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Spherical harmonics (SH) to spherical function (SF).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh</strong><span class=\"classifier\">ndarray</span></dt><dd><p>SH coefficients representing a spherical function.</p>\n</dd>\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>, there will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)</span> <span class=\"pre\">/</span> <span class=\"pre\">2</span></code> SH coefficients for a symmetric\nbasis and <code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span></code> coefficients for a full\nSH basis.</p>\n</dd>\n<dt><strong>basis_type</strong><span class=\"classifier\">{None, \u2018tournier07\u2019, \u2018descoteaux07\u2019}, optional</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the default DIPY basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 [Rc2e19fb985c5-2]_[Rc2e19fb985c5-3]_ basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#rc2e19fb985c5-1\" id=\"id934\">[1]</a> basis,\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>).</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True to use a SH basis containing even and odd order SH functions.\nElse, use a SH basis consisting only of even order SH functions.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility\nwith previous <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> implementations.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>sf</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Spherical function values on the <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rc2e19fb985c5-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id934\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"rc2e19fb985c5-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"rc2e19fb985c5-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"sh-to-sf-matrix\">\n<h3>sh_to_sf_matrix<a class=\"headerlink\" href=\"#sh-to-sf-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.sh_to_sf_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">sh_to_sf_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em>, <em class=\"sig-param\">sh_order=4</em>, <em class=\"sig-param\">basis_type=None</em>, <em class=\"sig-param\">full_basis=False</em>, <em class=\"sig-param\">legacy=True</em>, <em class=\"sig-param\">return_inv=True</em>, <em class=\"sig-param\">smooth=0</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.sh_to_sf_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Matrix that transforms Spherical harmonics (SH) to spherical\nfunction (SF).</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sphere</strong><span class=\"classifier\">Sphere</span></dt><dd><p>The points on which to sample the spherical function.</p>\n</dd>\n<dt><strong>sh_order</strong><span class=\"classifier\">int, optional</span></dt><dd><p>Maximum SH order in the SH fit.  For <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>, there will be\n<code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">2)</span> <span class=\"pre\">/</span> <span class=\"pre\">2</span></code> SH coefficients for a symmetric\nbasis and <code class=\"docutils literal notranslate\"><span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span> <span class=\"pre\">*</span> <span class=\"pre\">(sh_order</span> <span class=\"pre\">+</span> <span class=\"pre\">1)</span></code> coefficients for a full\nSH basis.</p>\n</dd>\n<dt><strong>basis_type</strong><span class=\"classifier\">{None, \u2018tournier07\u2019, \u2018descoteaux07\u2019}, optional</span></dt><dd><p><code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> for the default DIPY basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> for the Tournier 2007 [R8e8198e28e5b-2]_[R8e8198e28e5b-3]_ basis,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> for the Descoteaux 2007 <a class=\"reference internal\" href=\"#r8e8198e28e5b-1\" id=\"id938\">[1]</a> basis,\n(<code class=\"docutils literal notranslate\"><span class=\"pre\">None</span></code> defaults to <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code>).</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>If True, uses a SH basis containing even and odd order SH functions.\nElse, uses a SH basis consisting only of even order SH functions.</p>\n</dd>\n<dt><strong>legacy: bool, optional</strong></dt><dd><p>True to use a legacy basis definition for backward compatibility\nwith previous <code class=\"docutils literal notranslate\"><span class=\"pre\">tournier07</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">descoteaux07</span></code> implementations.</p>\n</dd>\n<dt><strong>return_inv</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True then the inverse of the matrix is also returned.</p>\n</dd>\n<dt><strong>smooth</strong><span class=\"classifier\">float, optional</span></dt><dd><p>Lambda-regularization in the SH fit.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>B</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Matrix that transforms spherical harmonics to spherical function\n<code class=\"docutils literal notranslate\"><span class=\"pre\">sf</span> <span class=\"pre\">=</span> <span class=\"pre\">np.dot(sh,</span> <span class=\"pre\">B)</span></code>.</p>\n</dd>\n<dt><strong>invB</strong><span class=\"classifier\">ndarray</span></dt><dd><p>Inverse of B.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r8e8198e28e5b-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id938\">1</a></span></dt>\n<dd><p>Descoteaux, M., Angelino, E., Fitzgibbons, S. and Deriche, R.\nRegularized, Fast, and Robust Analytical Q-ball Imaging.\nMagn. Reson. Med. 2007;58:497-510.</p>\n</dd>\n<dt class=\"label\" id=\"r8e8198e28e5b-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Tournier J.D., Calamante F. and Connelly A. Robust determination\nof the fibre orientation distribution in diffusion MRI:\nNon-negativity constrained super-resolved spherical deconvolution.\nNeuroImage. 2007;35(4):1459-1472.</p>\n</dd>\n<dt class=\"label\" id=\"r8e8198e28e5b-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Tournier J-D, Smith R, Raffelt D, Tabbara R, Dhollander T,\nPietsch M, et al. MRtrix3: A fast, flexible and open software\nframework for medical image processing and visualisation.\nNeuroImage. 2019 Nov 15;202:116-137.</p>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"smooth-pinv\">\n<h3>smooth_pinv<a class=\"headerlink\" href=\"#smooth-pinv\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.smooth_pinv\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">smooth_pinv</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">B</em>, <em class=\"sig-param\">L</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.smooth_pinv\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Regularized pseudo-inverse</p>\n<p>Computes a regularized least square inverse of B</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>B</strong><span class=\"classifier\">array_like (n, m)</span></dt><dd><p>Matrix to be inverted</p>\n</dd>\n<dt><strong>L</strong><span class=\"classifier\">array_like (n,)</span></dt><dd></dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>inv</strong><span class=\"classifier\">ndarray (m, n)</span></dt><dd><p>regularized least square inverse of B</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>In the literature this inverse is often written <span class=\"math notranslate nohighlight\">\\((B^{T}B+L^{2})^{-1}B^{T}\\)</span>.\nHowever here this inverse is implemented using the pseudo-inverse because\nit is more numerically stable than the direct implementation of the matrix\nproduct.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id942\">\n<h3>sph_harm_ind_list<a class=\"headerlink\" href=\"#id942\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.sph_harm_ind_list\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">sph_harm_ind_list</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sh_order</em>, <em class=\"sig-param\">full_basis=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.sph_harm_ind_list\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the degree (<code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code>) and order (<code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>) of all the symmetric spherical\nharmonics of degree less then or equal to <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>. The results,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">m_list</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">n_list</span></code> are kx1 arrays, where k depends on <code class=\"docutils literal notranslate\"><span class=\"pre\">sh_order</span></code>.\nThey can be passed to <a class=\"reference internal\" href=\"#dipy.reconst.shm.real_sh_descoteaux_from_index\" title=\"dipy.reconst.shm.real_sh_descoteaux_from_index\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">real_sh_descoteaux_from_index()</span></code></a> and\n:func:<code class=\"docutils literal notranslate\"><span class=\"pre\">real_sh_tournier_from_index</span></code>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>sh_order</strong><span class=\"classifier\">int</span></dt><dd><p>even int &gt; 0, max order to return</p>\n</dd>\n<dt><strong>full_basis: bool, optional</strong></dt><dd><p>True for SH basis with even and odd order terms</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>m_list</strong><span class=\"classifier\">array</span></dt><dd><p>degrees of even spherical harmonics</p>\n</dd>\n<dt><strong>n_list</strong><span class=\"classifier\">array</span></dt><dd><p>orders of even spherical harmonics</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_descoteaux_from_index</span></code>, <code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shm.real_sh_tournier_from_index</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"spherical-harmonics\">\n<h3>spherical_harmonics<a class=\"headerlink\" href=\"#spherical-harmonics\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.spherical_harmonics\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">spherical_harmonics</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em>, <em class=\"sig-param\">use_scipy=True</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.spherical_harmonics\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute spherical harmonics.</p>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>use_scipy</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If True, use scipy implementation.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">complex float</span></dt><dd><p>The harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <code class=\"docutils literal notranslate\"><span class=\"pre\">theta</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">phi</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Notes</p>\n<p>This is a faster implementation of scipy.special.sph_harm for\nscipy version &lt; 0.15.0. For scipy 0.15 and onwards, we use the scipy\nimplementation of the function.</p>\n<p>The usual definitions for <code class=\"docutils literal notranslate\"><span class=\"pre\">theta`</span> <span class=\"pre\">and</span> <span class=\"pre\">`phi</span></code> used in DIPY are interchanged\nin the method definition to agree with the definitions in\nscipy.special.sph_harm, where <cite>theta</cite> represents the azimuthal coordinate\nand <cite>phi</cite> represents the polar coordinate.</p>\n<p>Altough scipy uses a naming convention where <code class=\"docutils literal notranslate\"><span class=\"pre\">m</span></code> is the order and <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code>\nis the degree of the SH, the opposite of DIPY\u2019s, their definition for both\nparameters is the same as ours, with <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id943\">\n<h3>warn<a class=\"headerlink\" href=\"#id943\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shm.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shm.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shm.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id944\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shore.Cache\" title=\"dipy.reconst.shore.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a><a class=\"headerlink\" href=\"#id944\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shore.Cache\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">Cache</code><a class=\"headerlink\" href=\"#dipy.reconst.shore.Cache\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<p>Cache values based on a key object (such as a sphere or gradient table).</p>\n<p class=\"rubric\">Notes</p>\n<p>This class is meant to be used as a mix-in:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">Model</span><span class=\"p\">,</span> <span class=\"n\">Cache</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelFit</span><span class=\"p\">(</span><span class=\"n\">Fit</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Inside a method on the fit, typical usage would be:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">odf</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">):</span>\n    <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">M</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_compute_basis_matrix</span><span class=\"p\">(</span><span class=\"n\">sphere</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;odf_basis_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">sphere</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.Cache.cache_clear\" title=\"dipy.reconst.shore.Cache.cache_clear\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code></a>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.Cache.cache_get\" title=\"dipy.reconst.shore.Cache.cache_get\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code></a>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.Cache.cache_set\" title=\"dipy.reconst.shore.Cache.cache_set\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code></a>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.Cache.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">*args</em>, <em class=\"sig-param\">**kwargs</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.Cache.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.Cache.cache_clear\">\n<code class=\"sig-name descname\">cache_clear</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.Cache.cache_clear\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Clear the cache.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.Cache.cache_get\">\n<code class=\"sig-name descname\">cache_get</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">default=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.Cache.cache_get\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Retrieve a value from the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>default</strong><span class=\"classifier\">object</span></dt><dd><p>Value to be returned if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>v</strong><span class=\"classifier\">object</span></dt><dd><p>Value from the cache associated with <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.  Returns\n<cite>default</cite> if no cached entry is found.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.Cache.cache_set\">\n<code class=\"sig-name descname\">cache_set</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">tag</em>, <em class=\"sig-param\">key</em>, <em class=\"sig-param\">value</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.Cache.cache_set\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Store a value in the cache.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>tag</strong><span class=\"classifier\">str</span></dt><dd><p>Description of the cached value.</p>\n</dd>\n<dt><strong>key</strong><span class=\"classifier\">object</span></dt><dd><p>Key object used to look up the cached value.</p>\n</dd>\n<dt><strong>value</strong><span class=\"classifier\">object</span></dt><dd><p>Value stored in the cache for each unique combination\nof <code class=\"docutils literal notranslate\"><span class=\"pre\">(tag,</span> <span class=\"pre\">key)</span></code>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"c1\"># Imagine the following computation is very expensive</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cache</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"o\">=</span> <span class=\"n\">compute_expensive_matrix</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_set</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">X1</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X2</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">cache_get</span><span class=\"p\">(</span><span class=\"s1\">&#39;expensive_matrix&#39;</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">X1</span> <span class=\"ow\">is</span> <span class=\"n\">X2</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id945\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shore.LooseVersion\" title=\"dipy.reconst.shore.LooseVersion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a><a class=\"headerlink\" href=\"#id945\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shore.LooseVersion\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">LooseVersion</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.LooseVersion\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">distutils.version.Version</span></code></p>\n<p>Version numbering for anarchists and software realists.\nImplements the standard interface for version number classes as\ndescribed above.  A version number consists of a series of numbers,\nseparated by either periods or strings of letters.  When comparing\nversion numbers, the numeric components will be compared\nnumerically, and the alphabetic components lexically.  The following\nare all valid version numbers, in no particular order:</p>\n<blockquote>\n<div><p>1.5.1\n1.5.2b2\n161\n3.10a\n8.02\n3.4j\n1996.07.12\n3.2.pl0\n3.1.1.6\n2g6\n11g\n0.960923\n2.2beta29\n1.13++\n5.5.kw\n2.0b1pl0</p>\n</div></blockquote>\n<p>In fact, there is no such thing as an invalid version number under\nthis scheme; the rules for comparison are simple and predictable,\nbut may not always give the results you want (for some definition\nof \u201cwant\u201d).</p>\n<p class=\"rubric\">Methods</p>\n<table class=\"docutils align-default\">\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 53%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><strong>parse</strong></p></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.LooseVersion.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.LooseVersion.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>\n</dd></dl>\n\n<dl class=\"attribute\">\n<dt id=\"dipy.reconst.shore.LooseVersion.component_re\">\n<code class=\"sig-name descname\">component_re</code><em class=\"property\"> = re.compile('(\\\\d+ | [a-z]+ | \\\\.)', re.VERBOSE)</em><a class=\"headerlink\" href=\"#dipy.reconst.shore.LooseVersion.component_re\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.LooseVersion.parse\">\n<code class=\"sig-name descname\">parse</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">vstring</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.LooseVersion.parse\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd></dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shorefit\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit\" title=\"dipy.reconst.shore.ShoreFit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ShoreFit</span></code></a><a class=\"headerlink\" href=\"#shorefit\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shore.ShoreFit\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">ShoreFit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shore_coef</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference external\" href=\"https://docs.python.org/3/library/functions.html#object\" title=\"(in Python v3.9)\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">object</span></code></a></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Attributes</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.shore_coeff\" title=\"dipy.reconst.shore.ShoreFit.shore_coeff\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">shore_coeff</span></code></a></dt><dd><p>The SHORE coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.fitted_signal\" title=\"dipy.reconst.shore.ShoreFit.fitted_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fitted_signal</span></code></a>()</p></td>\n<td><p>The fitted signal.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.msd\" title=\"dipy.reconst.shore.ShoreFit.msd\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">msd</span></code></a>()</p></td>\n<td><p>Calculates the analytical mean squared displacement (MSD) <a class=\"reference internal\" href=\"#re8a75ace7245-1\" id=\"id946\">[1]</a></p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.odf\" title=\"dipy.reconst.shore.ShoreFit.odf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf</span></code></a>(sphere)</p></td>\n<td><p>Calculates the ODF for a given discrete sphere.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.odf_sh\" title=\"dipy.reconst.shore.ShoreFit.odf_sh\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">odf_sh</span></code></a>()</p></td>\n<td><p>Calculates the real analytical ODF in terms of Spherical Harmonics.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.pdf\" title=\"dipy.reconst.shore.ShoreFit.pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf</span></code></a>(r_points)</p></td>\n<td><p>Diffusion propagator on a given set of real points.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.pdf_grid\" title=\"dipy.reconst.shore.ShoreFit.pdf_grid\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">pdf_grid</span></code></a>(gridsize,\u00a0radius_max)</p></td>\n<td><p>Applies the analytical FFT on <span class=\"math notranslate nohighlight\">\\(S\\)</span> to generate the diffusion propagator.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.rtop_pdf\" title=\"dipy.reconst.shore.ShoreFit.rtop_pdf\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_pdf</span></code></a>()</p></td>\n<td><p>Calculates the analytical return to origin probability (RTOP) from the pdf <a class=\"reference internal\" href=\"#rbef4711069fe-1\" id=\"id947\">[1]</a>.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreFit.rtop_signal\" title=\"dipy.reconst.shore.ShoreFit.rtop_signal\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">rtop_signal</span></code></a>()</p></td>\n<td><p>Calculates the analytical return to origin probability (RTOP) from the signal <a class=\"reference internal\" href=\"#rb9597cd2c627-1\" id=\"id948\">[1]</a>.</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">model</em>, <em class=\"sig-param\">shore_coef</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates diffusion properties for a single voxel</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>model</strong><span class=\"classifier\">object,</span></dt><dd><p>AnalyticalModel</p>\n</dd>\n<dt><strong>shore_coef</strong><span class=\"classifier\">1d ndarray,</span></dt><dd><p>shore coefficients</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.fitted_signal\">\n<code class=\"sig-name descname\">fitted_signal</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.fitted_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The fitted signal.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.msd\">\n<code class=\"sig-name descname\">msd</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.msd\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical mean squared displacement (MSD) <a class=\"reference internal\" href=\"#re8a75ace7245-1\" id=\"id949\">[1]</a></p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>MSD:{DSI}=int_{-infty}^{infty}int_{-infty}^{infty}\nint_{-infty}^{infty} P(hat{mathbf{r}}) cdot\nhat{mathbf{r}}^{2} dr_x dr_y dr_z</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\hat{\\mathbf{r}}\\)</span> is a point in the 3D propagator space (see Wu\net al. <a class=\"reference internal\" href=\"#re8a75ace7245-1\" id=\"id950\">[1]</a>).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"re8a75ace7245-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id946\">1</a>,<a href=\"#id949\">2</a>,<a href=\"#id950\">3</a>)</span></dt>\n<dd><p>Wu Y. et al., \u201cHybrid diffusion imaging\u201d, NeuroImage, vol 36,</p>\n</dd>\n</dl>\n<ol class=\"loweralpha simple\" start=\"16\">\n<li><p>617-629, 2007.</p></li>\n</ol>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.odf\">\n<code class=\"sig-name descname\">odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">sphere</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the ODF for a given discrete sphere.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.odf_sh\">\n<code class=\"sig-name descname\">odf_sh</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.odf_sh\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the real analytical ODF in terms of Spherical\nHarmonics.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.pdf\">\n<code class=\"sig-name descname\">pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">r_points</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Diffusion propagator on a given set of real points.\nif the array r_points is non writeable, then intermediate\nresults are cached for faster recalculation</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.pdf_grid\">\n<code class=\"sig-name descname\">pdf_grid</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gridsize</em>, <em class=\"sig-param\">radius_max</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.pdf_grid\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Applies the analytical FFT on <span class=\"math notranslate nohighlight\">\\(S\\)</span> to generate the diffusion\npropagator. This is calculated on a discrete 3D grid in order to\nobtain an EAP similar to that which is obtained with DSI.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gridsize</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>\n</dd>\n<dt><strong>radius_max</strong><span class=\"classifier\">float</span></dt><dd><p>maximal radius in which to compute the propagator</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>eap</strong><span class=\"classifier\">ndarray</span></dt><dd><p>the ensemble average propagator in the 3D grid</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.rtop_pdf\">\n<code class=\"sig-name descname\">rtop_pdf</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.rtop_pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to origin probability (RTOP)\nfrom the pdf <a class=\"reference internal\" href=\"#rbef4711069fe-1\" id=\"id952\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rbef4711069fe-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id947\">1</a>,<a href=\"#id952\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.rtop_signal\">\n<code class=\"sig-name descname\">rtop_signal</code><span class=\"sig-paren\">(</span><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.rtop_signal\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Calculates the analytical return to origin probability (RTOP)\nfrom the signal <a class=\"reference internal\" href=\"#rb9597cd2c627-1\" id=\"id954\">[1]</a>.</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rb9597cd2c627-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id948\">1</a>,<a href=\"#id954\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel</p>\n</dd>\n</dl>\n<p>diffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreFit.shore_coeff\">\n<em class=\"property\">property </em><code class=\"sig-name descname\">shore_coeff</code><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreFit.shore_coeff\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>The SHORE coefficients</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shoremodel\">\n<h3><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreModel\" title=\"dipy.reconst.shore.ShoreModel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ShoreModel</span></code></a><a class=\"headerlink\" href=\"#shoremodel\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"class\">\n<dt id=\"dipy.reconst.shore.ShoreModel\">\n<em class=\"property\">class </em><code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">ShoreModel</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">zeta=700</em>, <em class=\"sig-param\">lambdaN=1e-08</em>, <em class=\"sig-param\">lambdaL=1e-08</em>, <em class=\"sig-param\">tau=0.025330295910584444</em>, <em class=\"sig-param\">constrain_e0=False</em>, <em class=\"sig-param\">positive_constraint=False</em>, <em class=\"sig-param\">pos_grid=11</em>, <em class=\"sig-param\">pos_radius=0.02</em>, <em class=\"sig-param\">cvxpy_solver=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreModel\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Bases: <a class=\"reference internal\" href=\"#dipy.reconst.cache.Cache\" title=\"dipy.reconst.cache.Cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dipy.reconst.cache.Cache</span></code></a></p>\n<p>Simple Harmonic Oscillator based Reconstruction and Estimation\n(SHORE) <a class=\"reference internal\" href=\"#rd47fc6332129-1\" id=\"id956\">[1]</a> of the diffusion signal.</p>\n<p>The main idea is to model the diffusion signal as a linear combination of\ncontinuous functions <span class=\"math notranslate nohighlight\">\\(\\phi_i\\)</span>,</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\mathbf{q}\\)</span> is the wave vector which corresponds to different\ngradient directions. Numerous continuous functions <span class=\"math notranslate nohighlight\">\\(\\phi_i\\)</span> can be used to\nmodel <span class=\"math notranslate nohighlight\">\\(S\\)</span>. Some are presented in [2,3,4]_.</p>\n<p>From the <span class=\"math notranslate nohighlight\">\\(c_i\\)</span> coefficients, there exist analytical formulae to estimate\nthe ODF, the return to the origin probability (RTOP), the mean square\ndisplacement (MSD), amongst others <a class=\"reference internal\" href=\"#rd47fc6332129-5\" id=\"id957\">[5]</a>.</p>\n<p class=\"rubric\">Notes</p>\n<p>The implementation of SHORE depends on CVXPY (<a class=\"reference external\" href=\"http://www.cvxpy.org/\">http://www.cvxpy.org/</a>).</p>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"rd47fc6332129-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id69\">1</a>,<a href=\"#id956\">2</a>)</span></dt>\n<dd><p>Ozarslan E. et al., \u201cSimple harmonic oscillator based reconstruction\nand estimation for one-dimensional q-space magnetic resonance\n1D-SHORE)\u201d, Proc Intl Soc Mag Reson Med, vol. 16, p. 35., 2008.</p>\n</dd>\n<dt class=\"label\" id=\"rd47fc6332129-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and ODF\nestimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd>\n<dt class=\"label\" id=\"rd47fc6332129-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Rathi Y. et al., \u201cSparse multi-shell diffusion imaging\u201d, MICCAI,\n2011.</p>\n</dd>\n<dt class=\"label\" id=\"rd47fc6332129-4\"><span class=\"brackets\">4</span></dt>\n<dd><p>Cheng J. et al., \u201cTheoretical Analysis and eapactical Insights on\nEAP Estimation via a Unified HARDI Framework\u201d, MICCAI workshop on\nComputational Diffusion MRI, 2011.</p>\n</dd>\n<dt class=\"label\" id=\"rd47fc6332129-5\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id957\">5</a></span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Methods</p>\n<table class=\"longtable docutils align-default\">\n<colgroup>\n<col style=\"width: 10%\" />\n<col style=\"width: 90%\" />\n</colgroup>\n<tbody>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_clear</span></code>()</p></td>\n<td><p>Clear the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_get</span></code>(tag,\u00a0key[,\u00a0default])</p></td>\n<td><p>Retrieve a value from the cache.</p></td>\n</tr>\n<tr class=\"row-odd\"><td><p><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">cache_set</span></code>(tag,\u00a0key,\u00a0value)</p></td>\n<td><p>Store a value in the cache.</p></td>\n</tr>\n<tr class=\"row-even\"><td><p><a class=\"reference internal\" href=\"#dipy.reconst.shore.ShoreModel.fit\" title=\"dipy.reconst.shore.ShoreModel.fit\"><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">fit</span></code></a>(data[,\u00a0mask])</p></td>\n<td><p>Fit method for every voxel in data</p></td>\n</tr>\n</tbody>\n</table>\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreModel.__init__\">\n<code class=\"sig-name descname\">__init__</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">radial_order=6</em>, <em class=\"sig-param\">zeta=700</em>, <em class=\"sig-param\">lambdaN=1e-08</em>, <em class=\"sig-param\">lambdaL=1e-08</em>, <em class=\"sig-param\">tau=0.025330295910584444</em>, <em class=\"sig-param\">constrain_e0=False</em>, <em class=\"sig-param\">positive_constraint=False</em>, <em class=\"sig-param\">pos_grid=11</em>, <em class=\"sig-param\">pos_radius=0.02</em>, <em class=\"sig-param\">cvxpy_solver=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreModel.__init__\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Analytical and continuous modeling of the diffusion signal with\nrespect to the SHORE basis [1,2]_.\nThis implementation is a modification of SHORE presented in <a class=\"reference internal\" href=\"#r5adcf1d06c8e-1\" id=\"id963\">[1]</a>.\nThe modification was made to obtain the same ordering of the basis\npresented in [2,3]_.</p>\n<p>The main idea is to model the diffusion signal as a linear\ncombination of continuous functions <span class=\"math notranslate nohighlight\">\\(\\phi_i\\)</span>,</p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><p>S(mathbf{q})= sum_{i=0}^I  c_{i} phi_{i}(mathbf{q}).</p>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\mathbf{q}\\)</span> is the wave vector which corresponds to different\ngradient directions.</p>\n<p>From the <span class=\"math notranslate nohighlight\">\\(c_i\\)</span> coefficients, there exists an analytical formula to\nestimate the ODF.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class</p>\n</dd>\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>zeta</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>scale factor</p>\n</dd>\n<dt><strong>lambdaN</strong><span class=\"classifier\">float,</span></dt><dd><p>radial regularisation constant</p>\n</dd>\n<dt><strong>lambdaL</strong><span class=\"classifier\">float,</span></dt><dd><p>angular regularisation constant</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float,</span></dt><dd><p>diffusion time. By default the value that makes q equal to the\nsquare root of the b-value.</p>\n</dd>\n<dt><strong>constrain_e0</strong><span class=\"classifier\">bool,</span></dt><dd><p>Constrain the optimization such that E(0) = 1.</p>\n</dd>\n<dt><strong>positive_constraint</strong><span class=\"classifier\">bool,</span></dt><dd><p>Constrain the propagator to be positive.</p>\n</dd>\n<dt><strong>pos_grid</strong><span class=\"classifier\">int,</span></dt><dd><p>Grid that define the points of the EAP in which we want to enforce\npositivity.</p>\n</dd>\n<dt><strong>pos_radius</strong><span class=\"classifier\">float,</span></dt><dd><p>Radius of the grid of the EAP in which enforce positivity in\nmillimeters. By default 20e-03 mm.</p>\n</dd>\n<dt><strong>cvxpy_solver</strong><span class=\"classifier\">str, optional</span></dt><dd><p>cvxpy solver name. Optionally optimize the positivity constraint\nwith a particular cvxpy solver. See <a class=\"reference external\" href=\"http://www.cvxpy.org/\">http://www.cvxpy.org/</a> for\ndetails.\nDefault: None (cvxpy chooses its own solver)</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r5adcf1d06c8e-1\"><span class=\"brackets\"><a class=\"fn-backref\" href=\"#id963\">1</a></span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and</p>\n</dd>\n</dl>\n<p>ODF estimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r5adcf1d06c8e-2\"><span class=\"brackets\">2</span></dt>\n<dd><p>Cheng J. et al., \u201cTheoretical Analysis and Practical Insights</p>\n</dd>\n</dl>\n<p>on EAP Estimation via a Unified HARDI Framework\u201d, MICCAI workshop on\nComputational Diffusion MRI, 2011.</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r5adcf1d06c8e-3\"><span class=\"brackets\">3</span></dt>\n<dd><p>Ozarslan E. et al., \u201cMean apparent propagator (MAP) MRI: A novel\ndiffusion imaging method for mapping tissue microstructure\u201d,\nNeuroImage, 2013.</p>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>In this example, where the data, gradient table and sphere tessellation\nused for reconstruction are provided, we model the diffusion signal\nwith respect to the SHORE basis and compute the real and analytical\nODF.</p>\n<p>from dipy.data import get_fnames, default_sphere\nfimg, fbvals, fbvecs = get_fnames(\u2018ISBI_testing_2shells_table\u2019)\nbvals, bvecs = read_bvals_bvecs(fbvals, fbvecs)\ngtab = gradient_table(bvals, bvecs)\nfrom dipy.sims.voxel import sticks_and_ball\ndata, golden_directions = sticks_and_ball(</p>\n<blockquote>\n<div><p>gtab, d=0.0015, S0=1., angles=[(0, 0), (90, 0)],\nfractions=[50, 50], snr=None)</p>\n</div></blockquote>\n<p>from dipy.reconst.canal import ShoreModel\nradial_order = 4\nzeta = 700\nasm = ShoreModel(gtab, radial_order=radial_order, zeta=zeta,</p>\n<blockquote>\n<div><p>lambdaN=1e-8, lambdaL=1e-8)</p>\n</div></blockquote>\n<p>asmfit = asm.fit(data)\nodf= asmfit.odf(default_sphere)</p>\n</dd></dl>\n\n<dl class=\"method\">\n<dt id=\"dipy.reconst.shore.ShoreModel.fit\">\n<code class=\"sig-name descname\">fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">data</em>, <em class=\"sig-param\">mask=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.ShoreModel.fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Fit method for every voxel in data</p>\n</dd></dl>\n\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id967\">\n<h3>cart2sphere<a class=\"headerlink\" href=\"#id967\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.cart2sphere\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">cart2sphere</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">y</em>, <em class=\"sig-param\">z</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.cart2sphere\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return angles for Cartesian 3D coordinates <cite>x</cite>, <cite>y</cite>, and <cite>z</cite></p>\n<p>See doc for <code class=\"docutils literal notranslate\"><span class=\"pre\">sphere2cart</span></code> for angle conventions and derivation\nof the formulae.</p>\n<p><span class=\"math notranslate nohighlight\">\\(0\\le\\theta\\mathrm{(theta)}\\le\\pi\\)</span> and <span class=\"math notranslate nohighlight\">\\(-\\pi\\le\\phi\\mathrm{(phi)}\\le\\pi\\)</span></p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>x</strong><span class=\"classifier\">array_like</span></dt><dd><p>x coordinate in Cartesian space</p>\n</dd>\n<dt><strong>y</strong><span class=\"classifier\">array_like</span></dt><dd><p>y coordinate in Cartesian space</p>\n</dd>\n<dt><strong>z</strong><span class=\"classifier\">array_like</span></dt><dd><p>z coordinate</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>r</strong><span class=\"classifier\">array</span></dt><dd><p>radius</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">array</span></dt><dd><p>inclination (polar) angle</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">array</span></dt><dd><p>azimuth angle</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id968\">\n<h3>create_rspace<a class=\"headerlink\" href=\"#id968\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.create_rspace\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">create_rspace</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gridsize</em>, <em class=\"sig-param\">radius_max</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.create_rspace\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><dl class=\"simple\">\n<dt>Create the real space table, that contains the points in which</dt><dd><p>to compute the pdf.</p>\n</dd>\n</dl>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gridsize</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>dimension of the propagator grid</p>\n</dd>\n<dt><strong>radius_max</strong><span class=\"classifier\">float</span></dt><dd><p>maximal radius in which compute the propagator</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>vecs</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>positions of the pdf points in a 3D matrix</p>\n</dd>\n<dt><strong>tab</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id969\">\n<h3>factorial<a class=\"headerlink\" href=\"#id969\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.factorial\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">factorial</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">x</em>, <em class=\"sig-param\">/</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.factorial\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Find x!.</p>\n<p>Raise a ValueError if x is negative or non-integral.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id970\">\n<h3>genlaguerre<a class=\"headerlink\" href=\"#id970\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.genlaguerre\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">genlaguerre</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">alpha</em>, <em class=\"sig-param\">monic=False</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.genlaguerre\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Generalized (associated) Laguerre polynomial.</p>\n<p>Defined to be the solution of</p>\n<div class=\"math notranslate nohighlight\">\n\\[x\\frac{d^2}{dx^2}L_n^{(\\alpha)}\n  + (\\alpha + 1 - x)\\frac{d}{dx}L_n^{(\\alpha)}\n  + nL_n^{(\\alpha)} = 0,\\]</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\alpha &gt; -1\\)</span>; <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span> is a polynomial\nof degree <span class=\"math notranslate nohighlight\">\\(n\\)</span>.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">int</span></dt><dd><p>Degree of the polynomial.</p>\n</dd>\n<dt><strong>alpha</strong><span class=\"classifier\">float</span></dt><dd><p>Parameter, must be greater than -1.</p>\n</dd>\n<dt><strong>monic</strong><span class=\"classifier\">bool, optional</span></dt><dd><p>If <cite>True</cite>, scale the leading coefficient to be 1. Default is\n<cite>False</cite>.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>L</strong><span class=\"classifier\">orthopoly1d</span></dt><dd><p>Generalized Laguerre polynomial.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">laguerre</span></code></dt><dd><p>Laguerre polynomial.</p>\n</dd>\n</dl>\n</div>\n<p class=\"rubric\">Notes</p>\n<p>For fixed <span class=\"math notranslate nohighlight\">\\(\\alpha\\)</span>, the polynomials <span class=\"math notranslate nohighlight\">\\(L_n^{(\\alpha)}\\)</span>\nare orthogonal over <span class=\"math notranslate nohighlight\">\\([0, \\infty)\\)</span> with weight function\n<span class=\"math notranslate nohighlight\">\\(e^{-x}x^\\alpha\\)</span>.</p>\n<p>The Laguerre polynomials are the special case where <span class=\"math notranslate nohighlight\">\\(\\alpha\n= 0\\)</span>.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"l-shore\">\n<h3>l_shore<a class=\"headerlink\" href=\"#l-shore\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.l_shore\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">l_shore</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.l_shore\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the angular regularisation matrix for SHORE basis</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id971\">\n<h3>multi_voxel_fit<a class=\"headerlink\" href=\"#id971\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.multi_voxel_fit\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">multi_voxel_fit</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">single_voxel_fit</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.multi_voxel_fit\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Method decorator to turn a single voxel model fit\ndefinition into a multi voxel model fit definition</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"n-shore\">\n<h3>n_shore<a class=\"headerlink\" href=\"#n-shore\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.n_shore\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">n_shore</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.n_shore\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Returns the angular regularisation matrix for SHORE basis</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id972\">\n<h3>optional_package<a class=\"headerlink\" href=\"#id972\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.optional_package\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">optional_package</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">name</em>, <em class=\"sig-param\">trip_msg=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.optional_package\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Return package-like thing and module setup for package <cite>name</cite></p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>name</strong><span class=\"classifier\">str</span></dt><dd><p>package name</p>\n</dd>\n<dt><strong>trip_msg</strong><span class=\"classifier\">None or str</span></dt><dd><p>message to give when someone tries to use the return package, but we\ncould not import it, and have returned a TripWire object instead.\nDefault message if None.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>pkg_like</strong><span class=\"classifier\">module or <code class=\"docutils literal notranslate\"><span class=\"pre\">TripWire</span></code> instance</span></dt><dd><p>If we can import the package, return it.  Otherwise return an object\nraising an error when accessed</p>\n</dd>\n<dt><strong>have_pkg</strong><span class=\"classifier\">bool</span></dt><dd><p>True if import for package was successful, false otherwise</p>\n</dd>\n<dt><strong>module_setup</strong><span class=\"classifier\">function</span></dt><dd><p>callable usually set as <code class=\"docutils literal notranslate\"><span class=\"pre\">setup_module</span></code> in calling namespace, to allow\nskipping tests.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">Examples</p>\n<p>Typical use would be something like this at the top of a module using an\noptional package:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">dipy.utils.optpkg</span> <span class=\"k\">import</span> <span class=\"n\">optional_package</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">have_pkg</span><span class=\"p\">,</span> <span class=\"n\">setup_module</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;not_a_package&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>Of course in this case the package doesn\u2019t exist, and so, in the module:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">have_pkg</span>\n<span class=\"go\">False</span>\n</pre></div>\n</div>\n<p>and</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"o\">.</span><span class=\"n\">some_function</span><span class=\"p\">()</span> \n<span class=\"gt\">Traceback (most recent call last):</span>\n    <span class=\"o\">...</span>\n<span class=\"gr\">TripWireError</span>: <span class=\"n\">We need package not_a_package for these functions, but</span>\n<span class=\"go\">``import not_a_package`` raised an ImportError</span>\n</pre></div>\n</div>\n<p>If the module does exist - we get the module</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">pkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Or a submodule if that\u2019s what we asked for</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">optional_package</span><span class=\"p\">(</span><span class=\"s1\">&#39;os.path&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">subpkg</span><span class=\"p\">,</span> <span class=\"s1\">&#39;dirname&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id973\">\n<h3>real_sph_harm<a class=\"headerlink\" href=\"#id973\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.real_sph_harm\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">real_sph_harm</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">m</em>, <em class=\"sig-param\">n</em>, <em class=\"sig-param\">theta</em>, <em class=\"sig-param\">phi</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.real_sph_harm\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute real spherical harmonics.</p>\n<p>dipy.reconst.shm.real_sph_harm is deprecated, Please use dipy.reconst.shm.real_sh_descoteaux_from_index instead</p>\n<ul class=\"simple\">\n<li><p>deprecated from version: 1.3</p></li>\n<li><p>Will raise &lt;class \u2018dipy.utils.deprecator.ExpiredDeprecationError\u2019&gt; as of version: 2.0</p></li>\n</ul>\n<p>Where the real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> is defined to be:</p>\n<blockquote>\n<div><p>Imag(<span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span>) * sqrt(2)     if m &gt; 0\n<span class=\"math notranslate nohighlight\">\\(Y^0_n\\)</span>                     if m = 0\nReal(<span class=\"math notranslate nohighlight\">\\(Y^|m|_n\\)</span>) * sqrt(2)   if m &lt; 0</p>\n</div></blockquote>\n<p>This may take scalar or array arguments. The inputs will be broadcasted\nagainst each other.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl>\n<dt><strong>m</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">|m|</span> <span class=\"pre\">&lt;=</span> <span class=\"pre\">n</span></code></span></dt><dd><p>The degree of the harmonic.</p>\n</dd>\n<dt><strong>n</strong><span class=\"classifier\">int <code class=\"docutils literal notranslate\"><span class=\"pre\">&gt;=</span> <span class=\"pre\">0</span></code></span></dt><dd><p>The order of the harmonic.</p>\n</dd>\n<dt><strong>theta</strong><span class=\"classifier\">float [0, pi]</span></dt><dd><p>The polar (colatitudinal) coordinate.</p>\n</dd>\n<dt><strong>phi</strong><span class=\"classifier\">float [0, 2*pi]</span></dt><dd><p>The azimuthal (longitudinal) coordinate.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>y_mn</strong><span class=\"classifier\">real float</span></dt><dd><p>The real harmonic <span class=\"math notranslate nohighlight\">\\(Y^m_n\\)</span> sampled at <cite>theta</cite> and <cite>phi</cite>.</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<div class=\"admonition seealso\">\n<p class=\"admonition-title\">See also</p>\n<dl class=\"simple\">\n<dt><code class=\"xref py py-obj docutils literal notranslate\"><span class=\"pre\">scipy.special.sph_harm</span></code></dt><dd></dd>\n</dl>\n</div>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shore-indices\">\n<h3>shore_indices<a class=\"headerlink\" href=\"#shore-indices\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.shore_indices\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">shore_indices</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">index</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.shore_indices\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given the basis order and the index, return the shore indices n, l, m\nfor modified Merlet\u2019s 3D-SHORE\n..math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"p\">:</span><span class=\"n\">nowrap</span><span class=\"p\">:</span>\n    \\<span class=\"n\">begin</span><span class=\"p\">{</span><span class=\"n\">equation</span><span class=\"p\">}</span>\n        \\<span class=\"n\">textbf</span><span class=\"p\">{</span><span class=\"n\">E</span><span class=\"p\">}(</span><span class=\"n\">q</span>\\<span class=\"n\">textbf</span><span class=\"p\">{</span><span class=\"n\">u</span><span class=\"p\">})</span><span class=\"o\">=</span>\\<span class=\"n\">sum_</span><span class=\"p\">{</span><span class=\"n\">l</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">even</span><span class=\"p\">}</span><span class=\"o\">^</span><span class=\"p\">{</span><span class=\"n\">N_</span><span class=\"p\">{</span><span class=\"nb\">max</span><span class=\"p\">}}</span>\n                                \\<span class=\"n\">sum_</span><span class=\"p\">{</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"n\">l</span><span class=\"p\">}</span><span class=\"o\">^</span><span class=\"p\">{(</span><span class=\"n\">N_</span><span class=\"p\">{</span><span class=\"nb\">max</span><span class=\"p\">}</span><span class=\"o\">+</span><span class=\"n\">l</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">}</span>\n                                \\<span class=\"n\">sum_</span><span class=\"p\">{</span><span class=\"n\">m</span><span class=\"o\">=-</span><span class=\"n\">l</span><span class=\"p\">}</span><span class=\"o\">^</span><span class=\"n\">l</span> <span class=\"n\">c_</span><span class=\"p\">{</span><span class=\"n\">nlm</span><span class=\"p\">}</span>\n                                \\<span class=\"n\">phi_</span><span class=\"p\">{</span><span class=\"n\">nlm</span><span class=\"p\">}(</span><span class=\"n\">q</span>\\<span class=\"n\">textbf</span><span class=\"p\">{</span><span class=\"n\">u</span><span class=\"p\">})</span>\n    \\<span class=\"n\">end</span><span class=\"p\">{</span><span class=\"n\">equation</span><span class=\"p\">}</span>\n</pre></div>\n</div>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\phi_{nlm}\\)</span> is\n..math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>:nowrap:\n    \\begin{equation}\n        \\phi_{nlm}^{SHORE}(q\\textbf{u})=\\Biggl[\\dfrac{2(n-l)!}\n            {\\zeta^{3/2} \\Gamma(n+3/2)} \\Biggr]^{1/2}\n            \\Biggl(\\dfrac{q^2}{\\zeta}\\Biggr)^{l/2}\n            exp\\Biggl(\\dfrac{-q^2}{2\\zeta}\\Biggr)\n            L^{l+1/2}_{n-l} \\Biggl(\\dfrac{q^2}{\\zeta}\\Biggr)\n            Y_l^m(\\textbf{u}).\n    \\end{equation}\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>an even integer that represent the maximal order of the basis</p>\n</dd>\n<dt><strong>index</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>index of the coefficients, start from 0</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index n of the modified shore basis</p>\n</dd>\n<dt><strong>l</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index l of the modified shore basis</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index m of the modified shore basis</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shore-matrix\">\n<h3>shore_matrix<a class=\"headerlink\" href=\"#shore-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.shore_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">shore_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">zeta</em>, <em class=\"sig-param\">gtab</em>, <em class=\"sig-param\">tau=0.025330295910584444</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.shore_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the SHORE matrix for modified Merlet\u2019s 3D-SHORE <a class=\"reference internal\" href=\"#r0425af01b43f-1\" id=\"id974\">[1]</a></p>\n<dl>\n<dt>..math::</dt><dd><dl class=\"field-list\">\n<dt class=\"field-odd\">nowrap</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt>begin{equation}</dt><dd><dl class=\"simple\">\n<dt>textbf{E}(qtextbf{u})=sum_{l=0, even}^{N_{max}}</dt><dd><p>sum_{n=l}^{(N_{max}+l)/2}\nsum_{m=-l}^l c_{nlm}\nphi_{nlm}(qtextbf{u})</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>end{equation}</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p>where <span class=\"math notranslate nohighlight\">\\(\\phi_{nlm}\\)</span> is\n..math:</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span>:nowrap:\n    \\begin{equation}\n        \\phi_{nlm}^{SHORE}(q\\textbf{u})=\\Biggl[\\dfrac{2(n-l)!}\n            {\\zeta^{3/2} \\Gamma(n+3/2)} \\Biggr]^{1/2}\n            \\Biggl(\\dfrac{q^2}{\\zeta}\\Biggr)^{l/2}\n            exp\\Biggl(\\dfrac{-q^2}{2\\zeta}\\Biggr)\n            L^{l+1/2}_{n-l} \\Biggl(\\dfrac{q^2}{\\zeta}\\Biggr)\n            Y_l^m(\\textbf{u}).\n    \\end{equation}\n</pre></div>\n</div>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>zeta</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>scale factor</p>\n</dd>\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable,</span></dt><dd><p>gradient directions and bvalues container class</p>\n</dd>\n<dt><strong>tau</strong><span class=\"classifier\">float,</span></dt><dd><p>diffusion time. By default the value that makes q=sqrt(b).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0425af01b43f-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id70\">1</a>,<a href=\"#id974\">2</a>)</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and</p>\n</dd>\n</dl>\n<p>ODF estimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shore-matrix-odf\">\n<h3>shore_matrix_odf<a class=\"headerlink\" href=\"#shore-matrix-odf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.shore_matrix_odf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">shore_matrix_odf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">zeta</em>, <em class=\"sig-param\">sphere_vertices</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.shore_matrix_odf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the SHORE ODF matrix <a class=\"reference internal\" href=\"#r0934fd177e35-1\" id=\"id976\">[1]</a>\u201d</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>zeta</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>scale factor</p>\n</dd>\n<dt><strong>sphere_vertices</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>vertices of the odf sphere</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r0934fd177e35-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id71\">1</a>,<a href=\"#id976\">2</a>)</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and</p>\n</dd>\n</dl>\n<p>ODF estimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shore-matrix-pdf\">\n<h3>shore_matrix_pdf<a class=\"headerlink\" href=\"#shore-matrix-pdf\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.shore_matrix_pdf\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">shore_matrix_pdf</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">radial_order</em>, <em class=\"sig-param\">zeta</em>, <em class=\"sig-param\">rtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.shore_matrix_pdf\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Compute the SHORE propagator matrix <a class=\"reference internal\" href=\"#r5470c7e1e272-1\" id=\"id978\">[1]</a>\u201d</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>an even integer that represent the order of the basis</p>\n</dd>\n<dt><strong>zeta</strong><span class=\"classifier\">unsigned int,</span></dt><dd><p>scale factor</p>\n</dd>\n<dt><strong>rtab</strong><span class=\"classifier\">array, shape (N,3)</span></dt><dd><p>real space points in which calculates the pdf</p>\n</dd>\n</dl>\n</dd>\n</dl>\n<p class=\"rubric\">References</p>\n<dl class=\"citation\">\n<dt class=\"label\" id=\"r5470c7e1e272-1\"><span class=\"brackets\">1</span><span class=\"fn-backref\">(<a href=\"#id72\">1</a>,<a href=\"#id978\">2</a>)</span></dt>\n<dd><p>Merlet S. et al., \u201cContinuous diffusion signal, EAP and</p>\n</dd>\n</dl>\n<p>ODF estimation via Compressive Sensing in diffusion MRI\u201d, Medical\nImage Analysis, 2013.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"shore-order\">\n<h3>shore_order<a class=\"headerlink\" href=\"#shore-order\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.shore_order\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">shore_order</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">n</em>, <em class=\"sig-param\">l</em>, <em class=\"sig-param\">m</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.shore_order\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Given the indices (n,l,m) of the basis, return the minimum order\nfor those indices and their index for modified Merlet\u2019s 3D-SHORE.</p>\n<dl class=\"field-list simple\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>n</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index n of the modified shore basis</p>\n</dd>\n<dt><strong>l</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index l of the modified shore basis</p>\n</dd>\n<dt><strong>m</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>the index m of the modified shore basis</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl class=\"simple\">\n<dt><strong>radial_order</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>an even integer that represent the maximal order of the basis</p>\n</dd>\n<dt><strong>index</strong><span class=\"classifier\">unsigned int</span></dt><dd><p>index of the coefficient correspondig to (n,l,m), start from 0</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"id980\">\n<h3>warn<a class=\"headerlink\" href=\"#id980\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.shore.warn\">\n<code class=\"sig-prename descclassname\">dipy.reconst.shore.</code><code class=\"sig-name descname\">warn</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">/</em>, <em class=\"sig-param\">message</em>, <em class=\"sig-param\">category=None</em>, <em class=\"sig-param\">stacklevel=1</em>, <em class=\"sig-param\">source=None</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.shore.warn\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>\n</dd></dl>\n\n</div>\n<div class=\"section\" id=\"dki-design-matrix\">\n<h3>dki_design_matrix<a class=\"headerlink\" href=\"#dki-design-matrix\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<dl class=\"function\">\n<dt id=\"dipy.reconst.utils.dki_design_matrix\">\n<code class=\"sig-prename descclassname\">dipy.reconst.utils.</code><code class=\"sig-name descname\">dki_design_matrix</code><span class=\"sig-paren\">(</span><em class=\"sig-param\">gtab</em><span class=\"sig-paren\">)</span><a class=\"headerlink\" href=\"#dipy.reconst.utils.dki_design_matrix\" title=\"Permalink to this definition\">\u00b6</a></dt>\n<dd><p>Construct B design matrix for DKI.</p>\n<dl class=\"field-list\">\n<dt class=\"field-odd\">Parameters</dt>\n<dd class=\"field-odd\"><dl class=\"simple\">\n<dt><strong>gtab</strong><span class=\"classifier\">GradientTable</span></dt><dd><p>Measurement directions.</p>\n</dd>\n</dl>\n</dd>\n<dt class=\"field-even\">Returns</dt>\n<dd class=\"field-even\"><dl>\n<dt><strong>B</strong><span class=\"classifier\">array (N, 22)</span></dt><dd><p>Design matrix or B matrix for the DKI model\nB[j, :] = (Bxx, Bxy, Bzz, Bxz, Byz, Bzz,</p>\n<blockquote>\n<div><p>Bxxxx, Byyyy, Bzzzz, Bxxxy, Bxxxz,\nBxyyy, Byyyz, Bxzzz, Byzzz, Bxxyy,\nBxxzz, Byyzz, Bxxyz, Bxyyz, Bxyzz,\nBlogS0)</p>\n</div></blockquote>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd></dl>\n\n</div>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["reference/dipy.segment", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">segment</span></code>", "N", "next"], ["reference/dipy.nn", "<code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">nn</span></code>", "P", "previous"]], "sourcename": "reference/dipy.reconst.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.base\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.base</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks.bench_bounding_box\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_bounding_box</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks.bench_csd\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_csd</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks.bench_peaks\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_peaks</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks.bench_squash\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_squash</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.benchmarks.bench_vec_val_sum\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.benchmarks.bench_vec_val_sum</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.cache\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.cross_validation\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.cross_validation</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.csdeconv\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.csdeconv</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.dki\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dki</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.dki_micro\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dki_micro</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.dsi\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dsi</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.dti\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.dti</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.forecast\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.forecast</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.fwdti\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.fwdti</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.gqi\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.gqi</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.ivim\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.ivim</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.mapmri\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.mapmri</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.mcsd\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.mcsd</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.msdki\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.msdki</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.multi_voxel\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.multi_voxel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.odf\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.odf</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.peak_direction_getter\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.peak_direction_getter</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.qtdmri\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.qtdmri</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.sfm\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.sfm</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.shm\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.shm</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#references\">References</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.shore\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.shore</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#module-dipy.reconst.utils\">Module: <code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">reconst.utils</span></code></a><ul>\n<li><a class=\"reference internal\" href=\"#bench\">bench</a></li>\n<li><a class=\"reference internal\" href=\"#test\">test</a></li>\n<li><a class=\"reference internal\" href=\"#reconstfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#reconstmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#bench-bounding-box\">bench_bounding_box</a></li>\n<li><a class=\"reference internal\" href=\"#bounding-box\">bounding_box</a></li>\n<li><a class=\"reference internal\" href=\"#measure\">measure</a></li>\n<li><a class=\"reference internal\" href=\"#constrainedsphericaldeconvmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#gradienttable\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#bench-csdeconv\">bench_csdeconv</a></li>\n<li><a class=\"reference internal\" href=\"#load-nifti-data\">load_nifti_data</a></li>\n<li><a class=\"reference internal\" href=\"#num-grad\">num_grad</a></li>\n<li><a class=\"reference internal\" href=\"#read-stanford-labels\">read_stanford_labels</a></li>\n<li><a class=\"reference internal\" href=\"#bench-local-maxima\">bench_local_maxima</a></li>\n<li><a class=\"reference internal\" href=\"#local-maxima\">local_maxima</a></li>\n<li><a class=\"reference internal\" href=\"#id84\">measure</a></li>\n<li><a class=\"reference internal\" href=\"#unique-edges\">unique_edges</a></li>\n<li><a class=\"reference internal\" href=\"#bench-quick-squash\">bench_quick_squash</a></li>\n<li><a class=\"reference internal\" href=\"#id85\">measure</a></li>\n<li><a class=\"reference internal\" href=\"#ndindex\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#old-squash\">old_squash</a></li>\n<li><a class=\"reference internal\" href=\"#quick-squash\">quick_squash</a></li>\n<li><a class=\"reference internal\" href=\"#reduce\">reduce</a></li>\n<li><a class=\"reference internal\" href=\"#bench-vec-val-vect\">bench_vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#id86\">measure</a></li>\n<li><a class=\"reference internal\" href=\"#randn\">randn</a></li>\n<li><a class=\"reference internal\" href=\"#vec-val-vect\">vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#cache\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#auto-attr\">auto_attr</a></li>\n<li><a class=\"reference internal\" href=\"#coeff-of-determination\">coeff_of_determination</a></li>\n<li><a class=\"reference internal\" href=\"#kfold-xval\">kfold_xval</a></li>\n<li><a class=\"reference internal\" href=\"#axsymshresponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">AxSymShResponse</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#constrainedsdtmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSDTModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id93\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ConstrainedSphericalDeconvModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#sphharmfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#sphharmmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#tensormodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#auto-response\">auto_response</a></li>\n<li><a class=\"reference internal\" href=\"#auto-response-ssst\">auto_response_ssst</a></li>\n<li><a class=\"reference internal\" href=\"#cart2sphere\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#csdeconv\">csdeconv</a></li>\n<li><a class=\"reference internal\" href=\"#deprecate-with-version\">deprecate_with_version</a></li>\n<li><a class=\"reference internal\" href=\"#estimate-response\">estimate_response</a></li>\n<li><a class=\"reference internal\" href=\"#fa-trace-to-lambdas\">fa_trace_to_lambdas</a></li>\n<li><a class=\"reference internal\" href=\"#forward-sdeconv-mat\">forward_sdeconv_mat</a></li>\n<li><a class=\"reference internal\" href=\"#forward-sdt-deconv-mat\">forward_sdt_deconv_mat</a></li>\n<li><a class=\"reference internal\" href=\"#fractional-anisotropy\">fractional_anisotropy</a></li>\n<li><a class=\"reference internal\" href=\"#get-sphere\">get_sphere</a></li>\n<li><a class=\"reference internal\" href=\"#lazy-index\">lazy_index</a></li>\n<li><a class=\"reference internal\" href=\"#lpn\">lpn</a></li>\n<li><a class=\"reference internal\" href=\"#mask-for-response-ssst\">mask_for_response_ssst</a></li>\n<li><a class=\"reference internal\" href=\"#multi-voxel-fit\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id122\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#odf-deconv\">odf_deconv</a></li>\n<li><a class=\"reference internal\" href=\"#odf-sh-to-sharp\">odf_sh_to_sharp</a></li>\n<li><a class=\"reference internal\" href=\"#peaks-from-model\">peaks_from_model</a></li>\n<li><a class=\"reference internal\" href=\"#quad\">quad</a></li>\n<li><a class=\"reference internal\" href=\"#real-sph-harm\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#real-sym-sh-basis\">real_sym_sh_basis</a></li>\n<li><a class=\"reference internal\" href=\"#recursive-response\">recursive_response</a></li>\n<li><a class=\"reference internal\" href=\"#response-from-mask\">response_from_mask</a></li>\n<li><a class=\"reference internal\" href=\"#response-from-mask-ssst\">response_from_mask_ssst</a></li>\n<li><a class=\"reference internal\" href=\"#sh-to-rh\">sh_to_rh</a></li>\n<li><a class=\"reference internal\" href=\"#single-tensor\">single_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#sph-harm-ind-list\">sph_harm_ind_list</a></li>\n<li><a class=\"reference internal\" href=\"#vec2vec-rotmat\">vec2vec_rotmat</a></li>\n<li><a class=\"reference internal\" href=\"#diffusionkurtosisfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#diffusionkurtosismodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id196\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#tensorfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#wcons\">Wcons</a></li>\n<li><a class=\"reference internal\" href=\"#wrotate\">Wrotate</a></li>\n<li><a class=\"reference internal\" href=\"#wrotate-element\">Wrotate_element</a></li>\n<li><a class=\"reference internal\" href=\"#apparent-kurtosis-coef\">apparent_kurtosis_coef</a></li>\n<li><a class=\"reference internal\" href=\"#axial-kurtosis\">axial_kurtosis</a></li>\n<li><a class=\"reference internal\" href=\"#carlson-rd\">carlson_rd</a></li>\n<li><a class=\"reference internal\" href=\"#carlson-rf\">carlson_rf</a></li>\n<li><a class=\"reference internal\" href=\"#id222\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#check-multi-b\">check_multi_b</a></li>\n<li><a class=\"reference internal\" href=\"#decompose-tensor\">decompose_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#design-matrix\">design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#directional-diffusion\">directional_diffusion</a></li>\n<li><a class=\"reference internal\" href=\"#directional-diffusion-variance\">directional_diffusion_variance</a></li>\n<li><a class=\"reference internal\" href=\"#directional-kurtosis\">directional_kurtosis</a></li>\n<li><a class=\"reference internal\" href=\"#dki-prediction\">dki_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#from-lower-triangular\">from_lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#get-fnames\">get_fnames</a></li>\n<li><a class=\"reference internal\" href=\"#id232\">get_sphere</a></li>\n<li><a class=\"reference internal\" href=\"#kurtosis-fractional-anisotropy\">kurtosis_fractional_anisotropy</a></li>\n<li><a class=\"reference internal\" href=\"#kurtosis-maximum\">kurtosis_maximum</a></li>\n<li><a class=\"reference internal\" href=\"#id237\">local_maxima</a></li>\n<li><a class=\"reference internal\" href=\"#lower-triangular\">lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#mean-diffusivity\">mean_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#mean-kurtosis\">mean_kurtosis</a></li>\n<li><a class=\"reference internal\" href=\"#mean-kurtosis-tensor\">mean_kurtosis_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#id250\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#nlls-fit-tensor\">nlls_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#ols-fit-dki\">ols_fit_dki</a></li>\n<li><a class=\"reference internal\" href=\"#perpendicular-directions\">perpendicular_directions</a></li>\n<li><a class=\"reference internal\" href=\"#radial-kurtosis\">radial_kurtosis</a></li>\n<li><a class=\"reference internal\" href=\"#restore-fit-tensor\">restore_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#sphere2cart\">sphere2cart</a></li>\n<li><a class=\"reference internal\" href=\"#split-dki-param\">split_dki_param</a></li>\n<li><a class=\"reference internal\" href=\"#id265\">vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#wls-fit-dki\">wls_fit_dki</a></li>\n<li><a class=\"reference internal\" href=\"#id267\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id304\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionKurtosisModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#kurtosismicrostructuralfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructuralFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#kurtosismicrostructuremodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">KurtosisMicrostructureModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#axial-diffusivity\">axial_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#axonal-water-fraction\">axonal_water_fraction</a></li>\n<li><a class=\"reference internal\" href=\"#id343\">decompose_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#diffusion-components\">diffusion_components</a></li>\n<li><a class=\"reference internal\" href=\"#id347\">directional_diffusion</a></li>\n<li><a class=\"reference internal\" href=\"#id350\">directional_kurtosis</a></li>\n<li><a class=\"reference internal\" href=\"#dkimicro-prediction\">dkimicro_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#dti-design-matrix\">dti_design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id358\">from_lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#id359\">get_sphere</a></li>\n<li><a class=\"reference internal\" href=\"#id360\">kurtosis_maximum</a></li>\n<li><a class=\"reference internal\" href=\"#id361\">lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#id362\">mean_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#id363\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#radial-diffusivity\">radial_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#id364\">split_dki_param</a></li>\n<li><a class=\"reference internal\" href=\"#tortuosity\">tortuosity</a></li>\n<li><a class=\"reference internal\" href=\"#trace\">trace</a></li>\n<li><a class=\"reference internal\" href=\"#id365\">vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#id366\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#diffusionspectrumdeconvfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#diffusionspectrumdeconvmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumDeconvModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#diffusionspectrumfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#diffusionspectrummodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">DiffusionSpectrumModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#odffit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#odfmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#lr-deconv\">LR_deconv</a></li>\n<li><a class=\"reference internal\" href=\"#create-qspace\">create_qspace</a></li>\n<li><a class=\"reference internal\" href=\"#create-qtable\">create_qtable</a></li>\n<li><a class=\"reference internal\" href=\"#fftn\">fftn</a></li>\n<li><a class=\"reference internal\" href=\"#fftshift\">fftshift</a></li>\n<li><a class=\"reference internal\" href=\"#gen-psf\">gen_PSF</a></li>\n<li><a class=\"reference internal\" href=\"#half-to-full-qspace\">half_to_full_qspace</a></li>\n<li><a class=\"reference internal\" href=\"#hanning-filter\">hanning_filter</a></li>\n<li><a class=\"reference internal\" href=\"#ifftshift\">ifftshift</a></li>\n<li><a class=\"reference internal\" href=\"#map-coordinates\">map_coordinates</a></li>\n<li><a class=\"reference internal\" href=\"#id385\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#pdf-interp-coords\">pdf_interp_coords</a></li>\n<li><a class=\"reference internal\" href=\"#pdf-odf\">pdf_odf</a></li>\n<li><a class=\"reference internal\" href=\"#project-hemisph-bvecs\">project_hemisph_bvecs</a></li>\n<li><a class=\"reference internal\" href=\"#threshold-propagator\">threshold_propagator</a></li>\n<li><a class=\"reference internal\" href=\"#id386\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id387\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id398\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#apparent-diffusion-coef\">apparent_diffusion_coef</a></li>\n<li><a class=\"reference internal\" href=\"#id409\">auto_attr</a></li>\n<li><a class=\"reference internal\" href=\"#id410\">axial_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#color-fa\">color_fa</a></li>\n<li><a class=\"reference internal\" href=\"#id411\">decompose_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#id412\">design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#determinant\">determinant</a></li>\n<li><a class=\"reference internal\" href=\"#deviatoric\">deviatoric</a></li>\n<li><a class=\"reference internal\" href=\"#eig-from-lo-tri\">eig_from_lo_tri</a></li>\n<li><a class=\"reference internal\" href=\"#id416\">fractional_anisotropy</a></li>\n<li><a class=\"reference internal\" href=\"#id417\">from_lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#geodesic-anisotropy\">geodesic_anisotropy</a></li>\n<li><a class=\"reference internal\" href=\"#id430\">get_sphere</a></li>\n<li><a class=\"reference internal\" href=\"#gradient-table\">gradient_table</a></li>\n<li><a class=\"reference internal\" href=\"#isotropic\">isotropic</a></li>\n<li><a class=\"reference internal\" href=\"#iter-fit-tensor\">iter_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#linearity\">linearity</a></li>\n<li><a class=\"reference internal\" href=\"#id436\">lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#id437\">mean_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#mode\">mode</a></li>\n<li><a class=\"reference internal\" href=\"#id441\">nlls_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#norm\">norm</a></li>\n<li><a class=\"reference internal\" href=\"#ols-fit-tensor\">ols_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#pinv\">pinv</a></li>\n<li><a class=\"reference internal\" href=\"#planarity\">planarity</a></li>\n<li><a class=\"reference internal\" href=\"#quantize-evecs\">quantize_evecs</a></li>\n<li><a class=\"reference internal\" href=\"#id447\">radial_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#id448\">restore_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#sphericity\">sphericity</a></li>\n<li><a class=\"reference internal\" href=\"#tensor-prediction\">tensor_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#id454\">trace</a></li>\n<li><a class=\"reference internal\" href=\"#id455\">vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#vector-norm\">vector_norm</a></li>\n<li><a class=\"reference internal\" href=\"#wls-fit-tensor\">wls_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#id458\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#forecastfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ForecastFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#forecastmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ForecastModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#looseversion\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id467\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id468\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id469\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#id470\">csdeconv</a></li>\n<li><a class=\"reference internal\" href=\"#find-signal-means\">find_signal_means</a></li>\n<li><a class=\"reference internal\" href=\"#forecast-error-func\">forecast_error_func</a></li>\n<li><a class=\"reference internal\" href=\"#forecast-matrix\">forecast_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#lb-forecast\">lb_forecast</a></li>\n<li><a class=\"reference internal\" href=\"#leastsq\">leastsq</a></li>\n<li><a class=\"reference internal\" href=\"#id473\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#optional-package\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#psi-l\">psi_l</a></li>\n<li><a class=\"reference internal\" href=\"#id474\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#rho-matrix\">rho_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#warn\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#freewatertensorfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#freewatertensormodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">FreeWaterTensorModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id484\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id485\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id496\">check_multi_b</a></li>\n<li><a class=\"reference internal\" href=\"#cholesky-to-lower-triangular\">cholesky_to_lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#id499\">decompose_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#id500\">design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id501\">from_lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#fwdti-prediction\">fwdti_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#id504\">lower_triangular</a></li>\n<li><a class=\"reference internal\" href=\"#lower-triangular-to-cholesky\">lower_triangular_to_cholesky</a></li>\n<li><a class=\"reference internal\" href=\"#id507\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id508\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#nls-fit-tensor\">nls_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#nls-iter\">nls_iter</a></li>\n<li><a class=\"reference internal\" href=\"#id511\">vec_val_vect</a></li>\n<li><a class=\"reference internal\" href=\"#id512\">wls_fit_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#wls-iter\">wls_iter</a></li>\n<li><a class=\"reference internal\" href=\"#id515\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#generalizedqsamplingfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#generalizedqsamplingmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GeneralizedQSamplingModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id523\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id524\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#equatorial-maximum\">equatorial_maximum</a></li>\n<li><a class=\"reference internal\" href=\"#equatorial-zone-vertices\">equatorial_zone_vertices</a></li>\n<li><a class=\"reference internal\" href=\"#gfa\">gfa</a></li>\n<li><a class=\"reference internal\" href=\"#id526\">local_maxima</a></li>\n<li><a class=\"reference internal\" href=\"#id527\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#normalize-qa\">normalize_qa</a></li>\n<li><a class=\"reference internal\" href=\"#npa\">npa</a></li>\n<li><a class=\"reference internal\" href=\"#odf-sum\">odf_sum</a></li>\n<li><a class=\"reference internal\" href=\"#patch-maximum\">patch_maximum</a></li>\n<li><a class=\"reference internal\" href=\"#patch-sum\">patch_sum</a></li>\n<li><a class=\"reference internal\" href=\"#patch-vertices\">patch_vertices</a></li>\n<li><a class=\"reference internal\" href=\"#polar-zone-vertices\">polar_zone_vertices</a></li>\n<li><a class=\"reference internal\" href=\"#remove-similar-vertices\">remove_similar_vertices</a></li>\n<li><a class=\"reference internal\" href=\"#squared-radial-component\">squared_radial_component</a></li>\n<li><a class=\"reference internal\" href=\"#triple-odf-maxima\">triple_odf_maxima</a></li>\n<li><a class=\"reference internal\" href=\"#upper-hemi-map\">upper_hemi_map</a></li>\n<li><a class=\"reference internal\" href=\"#ivimfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#ivimmodeltrr\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimModelTRR</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#ivimmodelvp\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IvimModelVP</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id537\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id538\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#ivimmodel\">IvimModel</a></li>\n<li><a class=\"reference internal\" href=\"#differential-evolution\">differential_evolution</a></li>\n<li><a class=\"reference internal\" href=\"#f-d-star-error\">f_D_star_error</a></li>\n<li><a class=\"reference internal\" href=\"#f-d-star-prediction\">f_D_star_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#ivim-model-selector\">ivim_model_selector</a></li>\n<li><a class=\"reference internal\" href=\"#ivim-prediction\">ivim_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#least-squares\">least_squares</a></li>\n<li><a class=\"reference internal\" href=\"#id570\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id571\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#id572\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id573\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#mapmrifit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MapmriFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#mapmrimodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MapmriModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#optimizer\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Optimizer</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id649\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id650\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#b-mat\">b_mat</a></li>\n<li><a class=\"reference internal\" href=\"#b-mat-isotropic\">b_mat_isotropic</a></li>\n<li><a class=\"reference internal\" href=\"#binomialfloat\">binomialfloat</a></li>\n<li><a class=\"reference internal\" href=\"#id655\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#create-rspace\">create_rspace</a></li>\n<li><a class=\"reference internal\" href=\"#delta\">delta</a></li>\n<li><a class=\"reference internal\" href=\"#factorial2\">factorial2</a></li>\n<li><a class=\"reference internal\" href=\"#gcv-cost-function\">gcv_cost_function</a></li>\n<li><a class=\"reference internal\" href=\"#generalized-crossvalidation\">generalized_crossvalidation</a></li>\n<li><a class=\"reference internal\" href=\"#generalized-crossvalidation-array\">generalized_crossvalidation_array</a></li>\n<li><a class=\"reference internal\" href=\"#genlaguerre\">genlaguerre</a></li>\n<li><a class=\"reference internal\" href=\"#id659\">gradient_table</a></li>\n<li><a class=\"reference internal\" href=\"#hermite\">hermite</a></li>\n<li><a class=\"reference internal\" href=\"#isotropic-scale-factor\">isotropic_scale_factor</a></li>\n<li><a class=\"reference internal\" href=\"#map-laplace-s\">map_laplace_s</a></li>\n<li><a class=\"reference internal\" href=\"#map-laplace-t\">map_laplace_t</a></li>\n<li><a class=\"reference internal\" href=\"#map-laplace-u\">map_laplace_u</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-stu-reg-matrices\">mapmri_STU_reg_matrices</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-index-matrix\">mapmri_index_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-k-mu-dependent\">mapmri_isotropic_K_mu_dependent</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-k-mu-independent\">mapmri_isotropic_K_mu_independent</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-m-mu-dependent\">mapmri_isotropic_M_mu_dependent</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-m-mu-independent\">mapmri_isotropic_M_mu_independent</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-index-matrix\">mapmri_isotropic_index_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-laplacian-reg-matrix\">mapmri_isotropic_laplacian_reg_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-laplacian-reg-matrix-from-index-matrix\">mapmri_isotropic_laplacian_reg_matrix_from_index_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-odf-matrix\">mapmri_isotropic_odf_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-odf-sh-matrix\">mapmri_isotropic_odf_sh_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-phi-matrix\">mapmri_isotropic_phi_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-psi-matrix\">mapmri_isotropic_psi_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-radial-pdf-basis\">mapmri_isotropic_radial_pdf_basis</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-isotropic-radial-signal-basis\">mapmri_isotropic_radial_signal_basis</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-laplacian-reg-matrix\">mapmri_laplacian_reg_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-odf-matrix\">mapmri_odf_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-phi-1d\">mapmri_phi_1d</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-phi-matrix\">mapmri_phi_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-psi-1d\">mapmri_psi_1d</a></li>\n<li><a class=\"reference internal\" href=\"#mapmri-psi-matrix\">mapmri_psi_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mfactorial\">mfactorial</a></li>\n<li><a class=\"reference internal\" href=\"#id707\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id708\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#id709\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#sfactorial\">sfactorial</a></li>\n<li><a class=\"reference internal\" href=\"#id710\">sph_harm_ind_list</a></li>\n<li><a class=\"reference internal\" href=\"#id711\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#id712\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">GradientTable</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id713\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#msdeconvfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MSDeconvFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#multishelldeconvmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiShellDeconvModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#multishellresponse\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiShellResponse</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#qpfitter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QpFitter</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id721\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">TensorModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#auto-response-msmt\">auto_response_msmt</a></li>\n<li><a class=\"reference internal\" href=\"#id732\">fractional_anisotropy</a></li>\n<li><a class=\"reference internal\" href=\"#get-bval-indices\">get_bval_indices</a></li>\n<li><a class=\"reference internal\" href=\"#id733\">gradient_table</a></li>\n<li><a class=\"reference internal\" href=\"#mask-for-response-msmt\">mask_for_response_msmt</a></li>\n<li><a class=\"reference internal\" href=\"#id734\">mean_diffusivity</a></li>\n<li><a class=\"reference internal\" href=\"#multi-shell-fiber-response\">multi_shell_fiber_response</a></li>\n<li><a class=\"reference internal\" href=\"#multi-tissue-basis\">multi_tissue_basis</a></li>\n<li><a class=\"reference internal\" href=\"#id735\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id736\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#response-from-mask-msmt\">response_from_mask_msmt</a></li>\n<li><a class=\"reference internal\" href=\"#id737\">response_from_mask_ssst</a></li>\n<li><a class=\"reference internal\" href=\"#id739\">single_tensor</a></li>\n<li><a class=\"reference internal\" href=\"#solve-qp\">solve_qp</a></li>\n<li><a class=\"reference internal\" href=\"#unique-bvals-tolerance\">unique_bvals_tolerance</a></li>\n<li><a class=\"reference internal\" href=\"#meandiffusionkurtosisfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#meandiffusionkurtosismodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MeanDiffusionKurtosisModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id769\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id770\">auto_attr</a></li>\n<li><a class=\"reference internal\" href=\"#awf-from-msk\">awf_from_msk</a></li>\n<li><a class=\"reference internal\" href=\"#id776\">check_multi_b</a></li>\n<li><a class=\"reference internal\" href=\"#id777\">design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#mean-signal-bvalue\">mean_signal_bvalue</a></li>\n<li><a class=\"reference internal\" href=\"#msdki-prediction\">msdki_prediction</a></li>\n<li><a class=\"reference internal\" href=\"#msk-from-awf\">msk_from_awf</a></li>\n<li><a class=\"reference internal\" href=\"#id781\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#round-bvals\">round_bvals</a></li>\n<li><a class=\"reference internal\" href=\"#unique-bvals-magnitude\">unique_bvals_magnitude</a></li>\n<li><a class=\"reference internal\" href=\"#wls-fit-msdki\">wls_fit_msdki</a></li>\n<li><a class=\"reference internal\" href=\"#callablearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CallableArray</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#multivoxelfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">MultiVoxelFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id784\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#as-strided\">as_strided</a></li>\n<li><a class=\"reference internal\" href=\"#id785\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id786\">ndindex</a></li>\n<li><a class=\"reference internal\" href=\"#id787\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id788\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id789\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id790\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id791\">gfa</a></li>\n<li><a class=\"reference internal\" href=\"#minmax-normalize\">minmax_normalize</a></li>\n<li><a class=\"reference internal\" href=\"#eudxdirectiongetter\">EuDXDirectionGetter</a></li>\n<li><a class=\"reference internal\" href=\"#id793\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#id794\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id795\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#qtdmrifit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QtdmriFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#qtdmrimodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QtdmriModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id844\">GCV_cost_function</a></li>\n<li><a class=\"reference internal\" href=\"#h\">H</a></li>\n<li><a class=\"reference internal\" href=\"#angular-basis-eap-opt\">angular_basis_EAP_opt</a></li>\n<li><a class=\"reference internal\" href=\"#angular-basis-opt\">angular_basis_opt</a></li>\n<li><a class=\"reference internal\" href=\"#id846\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#create-rt-space-grid\">create_rt_space_grid</a></li>\n<li><a class=\"reference internal\" href=\"#design-matrix-spatial\">design_matrix_spatial</a></li>\n<li><a class=\"reference internal\" href=\"#elastic-crossvalidation\">elastic_crossvalidation</a></li>\n<li><a class=\"reference internal\" href=\"#factorial\">factorial</a></li>\n<li><a class=\"reference internal\" href=\"#id847\">factorial2</a></li>\n<li><a class=\"reference internal\" href=\"#fmin-l-bfgs-b\">fmin_l_bfgs_b</a></li>\n<li><a class=\"reference internal\" href=\"#id848\">generalized_crossvalidation</a></li>\n<li><a class=\"reference internal\" href=\"#id850\">genlaguerre</a></li>\n<li><a class=\"reference internal\" href=\"#gradient-table-from-gradient-strength-bvecs\">gradient_table_from_gradient_strength_bvecs</a></li>\n<li><a class=\"reference internal\" href=\"#l1-crossvalidation\">l1_crossvalidation</a></li>\n<li><a class=\"reference internal\" href=\"#id851\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#id852\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#part1-reg-matrix-tau\">part1_reg_matrix_tau</a></li>\n<li><a class=\"reference internal\" href=\"#part23-iso-reg-matrix-q\">part23_iso_reg_matrix_q</a></li>\n<li><a class=\"reference internal\" href=\"#part23-reg-matrix-q\">part23_reg_matrix_q</a></li>\n<li><a class=\"reference internal\" href=\"#part23-reg-matrix-tau\">part23_reg_matrix_tau</a></li>\n<li><a class=\"reference internal\" href=\"#part4-iso-reg-matrix-q\">part4_iso_reg_matrix_q</a></li>\n<li><a class=\"reference internal\" href=\"#part4-reg-matrix-q\">part4_reg_matrix_q</a></li>\n<li><a class=\"reference internal\" href=\"#part4-reg-matrix-tau\">part4_reg_matrix_tau</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-anisotropic-scaling\">qtdmri_anisotropic_scaling</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-eap-matrix\">qtdmri_eap_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id860\">qtdmri_eap_matrix_</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-index-matrix\">qtdmri_index_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-eap-matrix\">qtdmri_isotropic_eap_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id861\">qtdmri_isotropic_eap_matrix_</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-index-matrix\">qtdmri_isotropic_index_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-laplacian-reg-matrix\">qtdmri_isotropic_laplacian_reg_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-scaling\">qtdmri_isotropic_scaling</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-signal-matrix\">qtdmri_isotropic_signal_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id863\">qtdmri_isotropic_signal_matrix_</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-isotropic-to-mapmri-matrix\">qtdmri_isotropic_to_mapmri_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-laplacian-reg-matrix\">qtdmri_laplacian_reg_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-mapmri-isotropic-normalization\">qtdmri_mapmri_isotropic_normalization</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-mapmri-normalization\">qtdmri_mapmri_normalization</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-number-of-coefficients\">qtdmri_number_of_coefficients</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-signal-matrix\">qtdmri_signal_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id867\">qtdmri_signal_matrix_</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-temporal-normalization\">qtdmri_temporal_normalization</a></li>\n<li><a class=\"reference internal\" href=\"#qtdmri-to-mapmri-matrix\">qtdmri_to_mapmri_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#radial-basis-eap-opt\">radial_basis_EAP_opt</a></li>\n<li><a class=\"reference internal\" href=\"#radial-basis-opt\">radial_basis_opt</a></li>\n<li><a class=\"reference internal\" href=\"#id869\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#temporal-basis\">temporal_basis</a></li>\n<li><a class=\"reference internal\" href=\"#visualise-gradient-table-g-delta-rainbow\">visualise_gradient_table_G_Delta_rainbow</a></li>\n<li><a class=\"reference internal\" href=\"#id870\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#id871\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#exponentialisotropicfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#exponentialisotropicmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ExponentialIsotropicModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#isotropicfit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IsotropicFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#isotropicmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">IsotropicModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id872\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id873\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ReconstModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#sparsefasciclefit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SparseFascicleFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#sparsefasciclemodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SparseFascicleModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id877\">auto_attr</a></li>\n<li><a class=\"reference internal\" href=\"#nanmean\">nanmean</a></li>\n<li><a class=\"reference internal\" href=\"#id878\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#sfm-design-matrix\">sfm_design_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#id881\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#csaodfmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">CsaOdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id883\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id884\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OdfModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#opdtmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">OpdtModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#qballbasemodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QballBaseModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#qballmodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">QballModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#residualbootstrapwrapper\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ResidualBootstrapWrapper</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id888\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id889\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SphHarmModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#anisotropic-power\">anisotropic_power</a></li>\n<li><a class=\"reference internal\" href=\"#id891\">auto_attr</a></li>\n<li><a class=\"reference internal\" href=\"#bootstrap-data-array\">bootstrap_data_array</a></li>\n<li><a class=\"reference internal\" href=\"#bootstrap-data-voxel\">bootstrap_data_voxel</a></li>\n<li><a class=\"reference internal\" href=\"#calculate-max-order\">calculate_max_order</a></li>\n<li><a class=\"reference internal\" href=\"#id895\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#convert-sh-from-legacy\">convert_sh_from_legacy</a></li>\n<li><a class=\"reference internal\" href=\"#convert-sh-to-full-basis\">convert_sh_to_full_basis</a></li>\n<li><a class=\"reference internal\" href=\"#convert-sh-to-legacy\">convert_sh_to_legacy</a></li>\n<li><a class=\"reference internal\" href=\"#id906\">deprecate_with_version</a></li>\n<li><a class=\"reference internal\" href=\"#id907\">forward_sdeconv_mat</a></li>\n<li><a class=\"reference internal\" href=\"#gen-dirac\">gen_dirac</a></li>\n<li><a class=\"reference internal\" href=\"#hat\">hat</a></li>\n<li><a class=\"reference internal\" href=\"#id908\">lazy_index</a></li>\n<li><a class=\"reference internal\" href=\"#lcr-matrix\">lcr_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#normalize-data\">normalize_data</a></li>\n<li><a class=\"reference internal\" href=\"#order-from-ncoef\">order_from_ncoef</a></li>\n<li><a class=\"reference internal\" href=\"#randint\">randint</a></li>\n<li><a class=\"reference internal\" href=\"#real-sh-descoteaux\">real_sh_descoteaux</a></li>\n<li><a class=\"reference internal\" href=\"#real-sh-descoteaux-from-index\">real_sh_descoteaux_from_index</a></li>\n<li><a class=\"reference internal\" href=\"#real-sh-tournier\">real_sh_tournier</a></li>\n<li><a class=\"reference internal\" href=\"#real-sh-tournier-from-index\">real_sh_tournier_from_index</a></li>\n<li><a class=\"reference internal\" href=\"#id919\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#id920\">real_sym_sh_basis</a></li>\n<li><a class=\"reference internal\" href=\"#real-sym-sh-mrtrix\">real_sym_sh_mrtrix</a></li>\n<li><a class=\"reference internal\" href=\"#sf-to-sh\">sf_to_sh</a></li>\n<li><a class=\"reference internal\" href=\"#id932\">sh_to_rh</a></li>\n<li><a class=\"reference internal\" href=\"#sh-to-sf\">sh_to_sf</a></li>\n<li><a class=\"reference internal\" href=\"#sh-to-sf-matrix\">sh_to_sf_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#smooth-pinv\">smooth_pinv</a></li>\n<li><a class=\"reference internal\" href=\"#id942\">sph_harm_ind_list</a></li>\n<li><a class=\"reference internal\" href=\"#spherical-harmonics\">spherical_harmonics</a></li>\n<li><a class=\"reference internal\" href=\"#id943\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#id944\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Cache</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id945\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">LooseVersion</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#shorefit\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ShoreFit</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#shoremodel\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ShoreModel</span></code></a></li>\n<li><a class=\"reference internal\" href=\"#id967\">cart2sphere</a></li>\n<li><a class=\"reference internal\" href=\"#id968\">create_rspace</a></li>\n<li><a class=\"reference internal\" href=\"#id969\">factorial</a></li>\n<li><a class=\"reference internal\" href=\"#id970\">genlaguerre</a></li>\n<li><a class=\"reference internal\" href=\"#l-shore\">l_shore</a></li>\n<li><a class=\"reference internal\" href=\"#id971\">multi_voxel_fit</a></li>\n<li><a class=\"reference internal\" href=\"#n-shore\">n_shore</a></li>\n<li><a class=\"reference internal\" href=\"#id972\">optional_package</a></li>\n<li><a class=\"reference internal\" href=\"#id973\">real_sph_harm</a></li>\n<li><a class=\"reference internal\" href=\"#shore-indices\">shore_indices</a></li>\n<li><a class=\"reference internal\" href=\"#shore-matrix\">shore_matrix</a></li>\n<li><a class=\"reference internal\" href=\"#shore-matrix-odf\">shore_matrix_odf</a></li>\n<li><a class=\"reference internal\" href=\"#shore-matrix-pdf\">shore_matrix_pdf</a></li>\n<li><a class=\"reference internal\" href=\"#shore-order\">shore_order</a></li>\n<li><a class=\"reference internal\" href=\"#id980\">warn</a></li>\n<li><a class=\"reference internal\" href=\"#dki-design-matrix\">dki_design_matrix</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "reference/dipy.reconst", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}